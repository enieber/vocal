(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.MinMax.
Require int.ComputerDivision.
Require map.Map.
Require map.Const.
Require set.Set.
Require option.Option.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | mk_ref : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Implicit Arguments mk_ref [[a]].

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:(ref a)): a :=
  match v with
  | (mk_ref x) => x
  end.

Axiom t : Type.
Parameter t_WhyType : WhyType t.
Existing Instance t_WhyType.

Parameter v: t -> Z.

Parameter zero: t.

Axiom zero_def : ((v zero) = 0%Z).

Parameter one: t.

Axiom one_def : ((v one) = 1%Z).

(* Why3 assumption *)
Definition rank := t.

Axiom loc : forall (a:Type), Type.
Parameter loc_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (loc a).
Existing Instance loc_WhyType.

(* Why3 assumption *)
Inductive content
  (a:Type) :=
  | Link : (loc a) -> content a
  | Root : t -> a -> content a.
Axiom content_WhyType : forall (a:Type) {a_WT:WhyType a},
  WhyType (content a).
Existing Instance content_WhyType.
Implicit Arguments Link [[a]].
Implicit Arguments Root [[a]].

(* Why3 assumption *)
Inductive memo
  (a:Type) :=
  | mk_memo : ((loc a) -> (option (content a))) -> memo a.
Axiom memo_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (memo a).
Existing Instance memo_WhyType.
Implicit Arguments mk_memo [[a]].

(* Why3 assumption *)
Definition refs {a:Type} {a_WT:WhyType a} (v1:(memo a)): ((loc a) ->
  (option (content a))) := match v1 with
  | (mk_memo x) => x
  end.

Parameter empty_memory: forall {a:Type} {a_WT:WhyType a}, (memo a).

Axiom empty_memory_def : forall {a:Type} {a_WT:WhyType a},
  ((refs (empty_memory : (memo
  a))) = (map.Const.const Init.Datatypes.None: ((loc a) -> (option (content
  a))))).

(* Why3 assumption *)
Definition elem (a:Type) := (loc a).

(* Why3 assumption *)
Definition allocated {a:Type} {a_WT:WhyType a} (mem:(memo a)) (x:(loc
  a)): Prop := ~ (((refs mem) x) = Init.Datatypes.None).

(* Why3 assumption *)
Inductive path {a:Type} {a_WT:WhyType a}: (memo a) -> (loc a) -> (loc a) ->
  Prop :=
  | Path_nil : forall (mem:(memo a)) (x:(loc a)), (path mem x x)
  | Path_cons : forall (mem:(memo a)) (x:(loc a)) (y:(loc a)) (z:(loc a)),
      (((refs mem) x) = (Init.Datatypes.Some (Link y))) -> ((path mem y z) ->
      (path mem x z)).

Axiom uf : forall (a:Type), Type.
Parameter uf_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (uf a).
Existing Instance uf_WhyType.

Parameter memo1: forall {a:Type} {a_WT:WhyType a}, (uf a) -> (memo a).

Parameter dom: forall {a:Type} {a_WT:WhyType a}, (uf a) -> ((loc a) -> bool).

Parameter rep: forall {a:Type} {a_WT:WhyType a}, (uf a) -> ((loc a) -> (loc
  a)).

Parameter img: forall {a:Type} {a_WT:WhyType a}, (uf a) -> ((loc a) -> a).

Axiom uf'invariant : forall {a:Type} {a_WT:WhyType a}, forall (self:(uf a)),
  (forall (x:(loc a)), (set.Set.mem x (dom self)) -> (((img self)
  x) = ((img self) ((rep self) x)))) /\ ((forall (x:(loc a)), (set.Set.mem x
  (dom self)) -> (((rep self) ((rep self) x)) = ((rep self) x))) /\
  ((forall (x:(loc a)), (set.Set.mem x (dom self)) -> (set.Set.mem
  ((rep self) x) (dom self))) /\ ((forall (x:(loc a)), (set.Set.mem x
  (dom self)) <-> (allocated (memo1 self) x)) /\ ((forall (x:(loc a)),
  match ((refs (memo1 self))
  x) with
  | (Init.Datatypes.Some (Link y)) => (allocated (memo1 self) y) /\
      ((((rep self) x) = ((rep self) y)) /\ (path (memo1 self) x y))
  | (Init.Datatypes.Some (Root r v1)) => (((img self) x) = v1) /\
      (((rep self) x) = x)
  | Init.Datatypes.None => True
  end) /\ forall (x:(loc a)), (set.Set.mem x (dom self)) ->
  match ((refs (memo1 self)) ((rep self)
  x)) with
  | (Init.Datatypes.Some (Root r _)) => (path (memo1 self) x ((rep self) x))
  | _ => False
  end)))).

(* Why3 assumption *)
Definition all_reps_root {a:Type} {a_WT:WhyType a} (uf1:(uf a)) (x:(loc
  a)): Prop := exists y:t, exists z:a, (((refs (memo1 uf1)) ((rep uf1)
  x)) = (Init.Datatypes.Some (Root y z))).

(* Why3 assumption *)
Definition is_root {a:Type} {a_WT:WhyType a} (uf1:(uf a)) (x:(loc
  a)): Prop := match ((refs (memo1 uf1)) ((rep uf1)
  x)) with
  | (Init.Datatypes.Some (Root _ _)) => True
  | _ => False
  end.

Axiom aux : forall {a:Type} {a_WT:WhyType a}, forall (uf1:(uf a)) (x:(loc
  a)), (is_root uf1 x) -> (all_reps_root uf1 x).

Axiom aux2 : forall {a:Type} {a_WT:WhyType a}, forall (uf1:(uf a)) (x:(loc
  a)), (set.Set.mem x (dom uf1)) -> (path (memo1 uf1) x ((rep uf1) x)).

Axiom a : Type.
Parameter a_WhyType : WhyType a.
Existing Instance a_WhyType.

Parameter uf1: (uf a).

Parameter uf_img: ((loc a) -> a).

Parameter uf_rep: ((loc a) -> (loc a)).

Parameter uf_dom: ((loc a) -> bool).

Parameter uf_memo: ((loc a) -> (option (content a))).

Parameter v1: a.

Axiom H : (uf_img = (img uf1)) /\ ((uf_rep = (rep uf1)) /\
  ((uf_dom = (dom uf1)) /\ ((mk_memo uf_memo) = (memo1 uf1)))).

Parameter uf_img1: ((loc a) -> a).

Parameter uf_rep1: ((loc a) -> (loc a)).

Parameter uf_dom1: ((loc a) -> bool).

Parameter uf_memo1: ((loc a) -> (option (content a))).

Axiom H1 : (uf_dom1 = (dom uf1)).

Axiom H2 : (uf_rep1 = (rep uf1)).

Axiom H3 : (uf_img1 = (img uf1)).

Parameter x: (loc a).

Axiom H4 : (((refs (memo1 uf1)) x) = Init.Datatypes.None).

Axiom H5 : (uf_memo1 = (map.Map.set (refs (memo1 uf1)) x
  (Init.Datatypes.Some (Root zero v1)))).

Axiom H6 : forall (y:(loc a)), (set.Set.mem y (map.Map.set uf_dom1 x
  true)) <-> ((y = x) \/ (set.Set.mem y uf_dom1)).

Parameter uf_img2: ((loc a) -> a).

Parameter uf_rep2: ((loc a) -> (loc a)).

Parameter uf_dom2: ((loc a) -> bool).

Parameter uf_memo2: ((loc a) -> (option (content a))).

Axiom H7 : (uf_memo2 = uf_memo1).

Axiom H8 : (uf_dom2 = (map.Map.set uf_dom1 x true)).

Axiom H9 : (uf_rep2 = uf_rep1).

Axiom H10 : (uf_img2 = uf_img1).

Parameter uf_img3: ((loc a) -> a).

Parameter uf_rep3: ((loc a) -> (loc a)).

Parameter uf_dom3: ((loc a) -> bool).

Parameter uf_memo3: ((loc a) -> (option (content a))).

Axiom H11 : (uf_memo3 = uf_memo2).

Axiom H12 : (uf_dom3 = uf_dom2).

Axiom H13 : (uf_rep3 = (map.Map.set uf_rep2 x x)).

Axiom H14 : (uf_img3 = uf_img2).

Parameter uf2: (uf a).

Parameter uf_img4: ((loc a) -> a).

Parameter uf_rep4: ((loc a) -> (loc a)).

Parameter uf_dom4: ((loc a) -> bool).

Parameter uf_memo4: ((loc a) -> (option (content a))).

Axiom H15 : (uf_memo4 = uf_memo3).

Axiom H16 : (uf_dom4 = uf_dom3).

Axiom H17 : (uf_rep4 = uf_rep3).

Axiom H18 : (uf_img4 = (map.Map.set uf_img3 x v1)).

Axiom H19 : forall (x1:(loc a)), (set.Set.mem x1 uf_dom4) -> ((uf_img4
  x1) = (uf_img4 (uf_rep4 x1))).

Axiom H20 : forall (x1:(loc a)), (set.Set.mem x1 uf_dom4) -> ((uf_rep4
  (uf_rep4 x1)) = (uf_rep4 x1)).

Axiom H21 : forall (x1:(loc a)), (set.Set.mem x1 uf_dom4) -> (set.Set.mem
  (uf_rep4 x1) uf_dom4).

Axiom H22 : forall (x1:(loc a)), (set.Set.mem x1 uf_dom4) <-> (allocated
  (mk_memo uf_memo4) x1).

Axiom H23 : forall (x1:(loc a)), match (uf_memo4
  x1) with
  | (Init.Datatypes.Some (Link y)) => (allocated (mk_memo uf_memo4) y) /\
      (((uf_rep4 x1) = (uf_rep4 y)) /\ (path (mk_memo uf_memo4) x1 y))
  | (Init.Datatypes.Some (Root r v2)) => ((uf_img4 x1) = v2) /\ ((uf_rep4
      x1) = x1)
  | Init.Datatypes.None => True
  end.

Parameter x1: (loc a).

Axiom H24 : (set.Set.mem x1 uf_dom4).

Parameter x2: (content a).

Axiom H25 : ((uf_memo4 (uf_rep4 x1)) = (Init.Datatypes.Some x2)).

Parameter x3: t.

Parameter x4: a.

Axiom H26 : (x2 = (Root x3 x4)).

Axiom h : ~ (x1 = x).

Axiom h1 : (set.Set.mem x1 uf_dom4).

Axiom h2 : forall (uf3:(uf a)) (x5:(loc a)), (set.Set.mem x5 (dom uf3)) ->
  (path (memo1 uf3) x5 ((rep uf3) x5)).

(* Why3 goal *)
Theorem VC_make : (path (mk_memo uf_memo4) x1 (uf_rep4 x1)).


Qed.

