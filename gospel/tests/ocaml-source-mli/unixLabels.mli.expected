
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text
  " Interface to the Unix system.\n   To use as replacement to default {!Unix} module,\n   add [module Unix = UnixLabels] in your implementation.\n"]
[@@@ocaml.text " {1 Error report} "]
type error = Unix.error =
  | E2BIG [@ocaml.doc " Argument list too long "]
  | EACCES [@ocaml.doc " Permission denied "]
  | EAGAIN [@ocaml.doc " Resource temporarily unavailable; try again "]
  | EBADF [@ocaml.doc " Bad file descriptor "]
  | EBUSY [@ocaml.doc " Resource unavailable "]
  | ECHILD [@ocaml.doc " No child process "]
  | EDEADLK [@ocaml.doc " Resource deadlock would occur "]
  | EDOM [@ocaml.doc " Domain error for math functions, etc. "]
  | EEXIST [@ocaml.doc " File exists "]
  | EFAULT [@ocaml.doc " Bad address "]
  | EFBIG [@ocaml.doc " File too large "]
  | EINTR [@ocaml.doc " Function interrupted by signal "]
  | EINVAL [@ocaml.doc " Invalid argument "]
  | EIO [@ocaml.doc " Hardware I/O error "]
  | EISDIR [@ocaml.doc " Is a directory "]
  | EMFILE [@ocaml.doc " Too many open files by the process "]
  | EMLINK [@ocaml.doc " Too many links "]
  | ENAMETOOLONG [@ocaml.doc " Filename too long "]
  | ENFILE [@ocaml.doc " Too many open files in the system "]
  | ENODEV [@ocaml.doc " No such device "]
  | ENOENT [@ocaml.doc " No such file or directory "]
  | ENOEXEC [@ocaml.doc " Not an executable file "]
  | ENOLCK [@ocaml.doc " No locks available "]
  | ENOMEM [@ocaml.doc " Not enough memory "]
  | ENOSPC [@ocaml.doc " No space left on device "]
  | ENOSYS [@ocaml.doc " Function not supported "]
  | ENOTDIR [@ocaml.doc " Not a directory "]
  | ENOTEMPTY [@ocaml.doc " Directory not empty "]
  | ENOTTY [@ocaml.doc " Inappropriate I/O control operation "]
  | ENXIO [@ocaml.doc " No such device or address "]
  | EPERM [@ocaml.doc " Operation not permitted "]
  | EPIPE [@ocaml.doc " Broken pipe "]
  | ERANGE [@ocaml.doc " Result too large "]
  | EROFS [@ocaml.doc " Read-only file system "]
  | ESPIPE [@ocaml.doc " Invalid seek e.g. on a pipe "]
  | ESRCH [@ocaml.doc " No such process "]
  | EXDEV [@ocaml.doc " Invalid link "]
  | EWOULDBLOCK [@ocaml.doc " Operation would block "]
  | EINPROGRESS [@ocaml.doc " Operation now in progress "]
  | EALREADY [@ocaml.doc " Operation already in progress "]
  | ENOTSOCK [@ocaml.doc " Socket operation on non-socket "]
  | EDESTADDRREQ [@ocaml.doc " Destination address required "]
  | EMSGSIZE [@ocaml.doc " Message too long "]
  | EPROTOTYPE [@ocaml.doc " Protocol wrong type for socket "]
  | ENOPROTOOPT [@ocaml.doc " Protocol not available "]
  | EPROTONOSUPPORT [@ocaml.doc " Protocol not supported "]
  | ESOCKTNOSUPPORT [@ocaml.doc " Socket type not supported "]
  | EOPNOTSUPP [@ocaml.doc " Operation not supported on socket "]
  | EPFNOSUPPORT [@ocaml.doc " Protocol family not supported "]
  | EAFNOSUPPORT
  [@ocaml.doc " Address family not supported by protocol family "]
  | EADDRINUSE [@ocaml.doc " Address already in use "]
  | EADDRNOTAVAIL [@ocaml.doc " Can't assign requested address "]
  | ENETDOWN [@ocaml.doc " Network is down "]
  | ENETUNREACH [@ocaml.doc " Network is unreachable "]
  | ENETRESET [@ocaml.doc " Network dropped connection on reset "]
  | ECONNABORTED [@ocaml.doc " Software caused connection abort "]
  | ECONNRESET [@ocaml.doc " Connection reset by peer "]
  | ENOBUFS [@ocaml.doc " No buffer space available "]
  | EISCONN [@ocaml.doc " Socket is already connected "]
  | ENOTCONN [@ocaml.doc " Socket is not connected "]
  | ESHUTDOWN [@ocaml.doc " Can't send after socket shutdown "]
  | ETOOMANYREFS [@ocaml.doc " Too many references: can't splice "]
  | ETIMEDOUT [@ocaml.doc " Connection timed out "]
  | ECONNREFUSED [@ocaml.doc " Connection refused "]
  | EHOSTDOWN [@ocaml.doc " Host is down "]
  | EHOSTUNREACH [@ocaml.doc " No route to host "]
  | ELOOP [@ocaml.doc " Too many levels of symbolic links "]
  | EOVERFLOW [@ocaml.doc " File size or position not representable "]
  | EUNKNOWNERR of int [@ocaml.doc " Unknown error "][@@ocaml.doc
                                                       " The type of error codes.\n   Errors defined in the POSIX standard\n   and additional errors from UNIX98 and BSD.\n   All other errors are mapped to EUNKNOWNERR.\n"]
exception Unix_error of error * string * string
  [@ocaml.doc
    " Raised by the system calls below when an error is encountered.\n   The first component is the error code; the second component\n   is the function name; the third component is the string parameter\n   to the function, if it has one, or the empty string otherwise. "]
val error_message : error -> string[@@ocaml.doc
                                     " Return a string describing the given error code. "]
val handle_unix_error : ('a -> 'b) -> 'a -> 'b[@@ocaml.doc
                                                " [handle_unix_error f x] applies [f] to [x] and returns the result.\n   If the exception [Unix_error] is raised, it prints a message\n   describing the error and exits with code 2. "]
[@@@ocaml.text " {1 Access to the process environment} "]
val environment : unit -> string array[@@ocaml.doc
                                        " Return the process environment, as an array of strings\n    with the format ``variable=value''. "]
val getenv : string -> string[@@ocaml.doc
                               " Return the value associated to a variable in the process\n   environment. Raise [Not_found] if the variable is unbound.\n   (This function is identical to [Sys.getenv].) "]
val unsafe_getenv : string -> string[@@ocaml.doc
                                      " Return the value associated to a variable in the process\n   environment.\n\n   Unlike {!getenv}, this function returns the value even if the\n   process has special privileges. It is considered unsafe because the\n   programmer of a setuid or setgid program must be careful to avoid\n   using maliciously crafted environment variables in the search path\n   for executables, the locations for temporary files or logs, and the\n   like.\n\n   @raise Not_found if the variable is unbound.\n   @since 4.06.0  "]
val putenv : string -> string -> unit[@@ocaml.doc
                                       " [Unix.putenv name value] sets the value associated to a\n   variable in the process environment.\n   [name] is the name of the environment variable,\n   and [value] its new associated value. "]
[@@@ocaml.text " {1 Process handling} "]
type process_status = Unix.process_status =
  | WEXITED of int
  [@ocaml.doc
    " The process terminated normally by [exit];\n           the argument is the return code. "]
  | WSIGNALED of int
  [@ocaml.doc
    " The process was killed by a signal;\n           the argument is the signal number. "]
  | WSTOPPED of int
  [@ocaml.doc
    " The process was stopped by a signal; the argument is the\n           signal number. "]
[@@ocaml.doc
  " The termination status of a process.  See module {!Sys} for the\n    definitions of the standard signal numbers.  Note that they are\n    not the numbers used by the OS. "]
type wait_flag = Unix.wait_flag =
  | WNOHANG
  [@ocaml.doc
    " do not block if no child has\n               died yet, but immediately return with a pid equal to 0."]
  | WUNTRACED
  [@ocaml.doc " report also the children that receive stop signals. "]
[@@ocaml.doc " Flags for {!UnixLabels.waitpid}. "]
val execv : prog:string -> args:string array -> 'a[@@ocaml.doc
                                                    " [execv prog args] execute the program in file [prog], with\n   the arguments [args], and the current process environment.\n   These [execv*] functions never return: on success, the current\n   program is replaced by the new one;\n   on failure, a {!UnixLabels.Unix_error} exception is raised. "]
val execve : prog:string -> args:string array -> env:string array -> 'a
[@@ocaml.doc
  " Same as {!UnixLabels.execv}, except that the third argument provides the\n   environment to the program executed. "]
val execvp : prog:string -> args:string array -> 'a[@@ocaml.doc
                                                     " Same as {!UnixLabels.execv}, except that\n   the program is searched in the path. "]
val execvpe : prog:string -> args:string array -> env:string array -> 'a
[@@ocaml.doc
  " Same as {!UnixLabels.execve}, except that\n   the program is searched in the path. "]
val fork : unit -> int[@@ocaml.doc
                        " Fork a new process. The returned integer is 0 for the child\n   process, the pid of the child process for the parent process. "]
val wait : unit -> (int * process_status)[@@ocaml.doc
                                           " Wait until one of the children processes die, and return its pid\n   and termination status. "]
val waitpid : mode:wait_flag list -> int -> (int * process_status)[@@ocaml.doc
                                                                    " Same as {!UnixLabels.wait}, but waits for the child process whose pid\n   is given.\n   A pid of [-1] means wait for any child.\n   A pid of [0] means wait for any child in the same process group\n   as the current process.\n   Negative pid arguments represent process groups.\n   The list of options indicates whether [waitpid] should return\n   immediately without waiting, or also report stopped children. "]
val system : string -> process_status[@@ocaml.doc
                                       " Execute the given command, wait until it terminates, and return\n   its termination status. The string is interpreted by the shell\n   [/bin/sh] and therefore can contain redirections, quotes, variables,\n   etc. The result [WEXITED 127] indicates that the shell couldn't\n   be executed. "]
val getpid : unit -> int[@@ocaml.doc " Return the pid of the process. "]
val getppid : unit -> int[@@ocaml.doc
                           " Return the pid of the parent process. "]
val nice : int -> int[@@ocaml.doc
                       " Change the process priority. The integer argument is added to the\n   ``nice'' value. (Higher values of the ``nice'' value mean\n   lower priorities.) Return the new nice value. "]
[@@@ocaml.text " {1 Basic file input/output} "]
type file_descr = Unix.file_descr[@@ocaml.doc
                                   " The abstract type of file descriptors. "]
val stdin : file_descr[@@ocaml.doc " File descriptor for standard input."]
val stdout : file_descr[@@ocaml.doc " File descriptor for standard output."]
val stderr : file_descr[@@ocaml.doc " File descriptor for standard error. "]
type open_flag = Unix.open_flag =
  | O_RDONLY [@ocaml.doc " Open for reading "]
  | O_WRONLY [@ocaml.doc " Open for writing "]
  | O_RDWR [@ocaml.doc " Open for reading and writing "]
  | O_NONBLOCK [@ocaml.doc " Open in non-blocking mode "]
  | O_APPEND [@ocaml.doc " Open for append "]
  | O_CREAT [@ocaml.doc " Create if nonexistent "]
  | O_TRUNC [@ocaml.doc " Truncate to 0 length if existing "]
  | O_EXCL [@ocaml.doc " Fail if existing "]
  | O_NOCTTY [@ocaml.doc " Don't make this dev a controlling tty "]
  | O_DSYNC
  [@ocaml.doc
    " Writes complete as `Synchronised I/O data\n                                    integrity completion' "]
  | O_SYNC
  [@ocaml.doc
    " Writes complete as `Synchronised I/O file\n                                    integrity completion' "]
  | O_RSYNC
  [@ocaml.doc
    " Reads complete as writes (depending\n                                    on O_SYNC/O_DSYNC) "]
  | O_SHARE_DELETE
  [@ocaml.doc
    " Windows only: allow the file to be deleted\n                                    while still open "]
  | O_CLOEXEC
  [@ocaml.doc
    " Set the close-on-exec flag on the\n                                   descriptor returned by {!openfile} "]
  | O_KEEPEXEC
  [@ocaml.doc
    " Clear the close-on-exec flag.\n                                    This is currently the default. "]
[@@ocaml.doc " The flags to {!UnixLabels.openfile}. "]
type file_perm = int[@@ocaml.doc
                      " The type of file access rights, e.g. [0o640] is read and write for user,\n    read for group, none for others "]
val openfile : string -> mode:open_flag list -> perm:file_perm -> file_descr
[@@ocaml.doc
  " Open the named file with the given flags. Third argument is\n   the permissions to give to the file if it is created. Return\n   a file descriptor on the named file. "]
val close : file_descr -> unit[@@ocaml.doc " Close a file descriptor. "]
val read : file_descr -> buf:bytes -> pos:int -> len:int -> int[@@ocaml.doc
                                                                 " [read fd buff ofs len] reads [len] bytes from descriptor [fd],\n    storing them in byte sequence [buff], starting at position [ofs] in\n    [buff]. Return the number of bytes actually read. "]
val write : file_descr -> buf:bytes -> pos:int -> len:int -> int[@@ocaml.doc
                                                                  " [write fd buff ofs len] writes [len] bytes to descriptor [fd],\n    taking them from byte sequence [buff], starting at position [ofs]\n    in [buff]. Return the number of bytes actually written.  [write]\n    repeats the writing operation until all bytes have been written or\n    an error occurs.  "]
val single_write : file_descr -> buf:bytes -> pos:int -> len:int -> int
[@@ocaml.doc
  " Same as [write], but attempts to write only once.\n   Thus, if an error occurs, [single_write] guarantees that no data\n   has been written. "]
val write_substring : file_descr -> buf:string -> pos:int -> len:int -> int
[@@ocaml.doc
  " Same as [write], but take the data from a string instead of a byte\n    sequence.\n    @since 4.02.0 "]
val single_write_substring :
  file_descr -> buf:string -> pos:int -> len:int -> int[@@ocaml.doc
                                                         " Same as [single_write], but take the data from a string instead of\n    a byte sequence.\n    @since 4.02.0 "]
[@@@ocaml.text " {1 Interfacing with the standard input/output library} "]
val in_channel_of_descr : file_descr -> in_channel[@@ocaml.doc
                                                    " Create an input channel reading from the given descriptor.\n   The channel is initially in binary mode; use\n   [set_binary_mode_in ic false] if text mode is desired. "]
val out_channel_of_descr : file_descr -> out_channel[@@ocaml.doc
                                                      " Create an output channel writing on the given descriptor.\n   The channel is initially in binary mode; use\n   [set_binary_mode_out oc false] if text mode is desired. "]
val descr_of_in_channel : in_channel -> file_descr[@@ocaml.doc
                                                    " Return the descriptor corresponding to an input channel. "]
val descr_of_out_channel : out_channel -> file_descr[@@ocaml.doc
                                                      " Return the descriptor corresponding to an output channel. "]
[@@@ocaml.text " {1 Seeking and truncating} "]
type seek_command = Unix.seek_command =
  | SEEK_SET
  [@ocaml.doc " indicates positions relative to the beginning of the file "]
  | SEEK_CUR
  [@ocaml.doc " indicates positions relative to the current position "]
  | SEEK_END
  [@ocaml.doc " indicates positions relative to the end of the file "]
[@@ocaml.doc " Positioning modes for {!UnixLabels.lseek}. "]
val lseek : file_descr -> int -> mode:seek_command -> int[@@ocaml.doc
                                                           " Set the current position for a file descriptor, and return the resulting\n    offset (from the beginning of the file). "]
val truncate : string -> len:int -> unit[@@ocaml.doc
                                          " Truncates the named file to the given size. "]
val ftruncate : file_descr -> len:int -> unit[@@ocaml.doc
                                               " Truncates the file corresponding to the given descriptor\n   to the given size. "]
[@@@ocaml.text " {1 File status} "]
type file_kind = Unix.file_kind =
  | S_REG [@ocaml.doc " Regular file "]
  | S_DIR [@ocaml.doc " Directory "]
  | S_CHR [@ocaml.doc " Character device "]
  | S_BLK [@ocaml.doc " Block device "]
  | S_LNK [@ocaml.doc " Symbolic link "]
  | S_FIFO [@ocaml.doc " Named pipe "]
  | S_SOCK [@ocaml.doc " Socket "]
type stats = Unix.stats =
  {
  st_dev: int [@ocaml.doc " Device number "];
  st_ino: int [@ocaml.doc " Inode number "];
  st_kind: file_kind [@ocaml.doc " Kind of the file "];
  st_perm: file_perm [@ocaml.doc " Access rights "];
  st_nlink: int [@ocaml.doc " Number of links "];
  st_uid: int [@ocaml.doc " User id of the owner "];
  st_gid: int [@ocaml.doc " Group ID of the file's group "];
  st_rdev: int [@ocaml.doc " Device ID (if special file) "];
  st_size: int [@ocaml.doc " Size in bytes "];
  st_atime: float [@ocaml.doc " Last access time "];
  st_mtime: float [@ocaml.doc " Last modification time "];
  st_ctime: float [@ocaml.doc " Last status change time "]}[@@ocaml.doc
                                                             " The information returned by the {!UnixLabels.stat} calls. "]
val stat : string -> stats[@@ocaml.doc
                            " Return the information for the named file. "]
val lstat : string -> stats[@@ocaml.doc
                             " Same as {!UnixLabels.stat}, but in case the file is a symbolic link,\n   return the information for the link itself. "]
val fstat : file_descr -> stats[@@ocaml.doc
                                 " Return the information for the file associated with the given\n   descriptor. "]
val isatty : file_descr -> bool[@@ocaml.doc
                                 " Return [true] if the given file descriptor refers to a terminal or\n   console window, [false] otherwise. "]
[@@@ocaml.text " {1 File operations on large files} "]
module LargeFile :
sig
  val lseek : file_descr -> int64 -> mode:seek_command -> int64
  val truncate : string -> len:int64 -> unit
  val ftruncate : file_descr -> len:int64 -> unit
  type stats = Unix.LargeFile.stats =
    {
    st_dev: int [@ocaml.doc " Device number "];
    st_ino: int [@ocaml.doc " Inode number "];
    st_kind: file_kind [@ocaml.doc " Kind of the file "];
    st_perm: file_perm [@ocaml.doc " Access rights "];
    st_nlink: int [@ocaml.doc " Number of links "];
    st_uid: int [@ocaml.doc " User id of the owner "];
    st_gid: int [@ocaml.doc " Group ID of the file's group "];
    st_rdev: int [@ocaml.doc " Device ID (if special file) "];
    st_size: int64 [@ocaml.doc " Size in bytes "];
    st_atime: float [@ocaml.doc " Last access time "];
    st_mtime: float [@ocaml.doc " Last modification time "];
    st_ctime: float [@ocaml.doc " Last status change time "]}
  val stat : string -> stats
  val lstat : string -> stats
  val fstat : file_descr -> stats
end[@@ocaml.doc
     " File operations on large files.\n  This sub-module provides 64-bit variants of the functions\n  {!UnixLabels.lseek} (for positioning a file descriptor),\n  {!UnixLabels.truncate} and {!UnixLabels.ftruncate}\n  (for changing the size of a file),\n  and {!UnixLabels.stat}, {!UnixLabels.lstat} and {!UnixLabels.fstat}\n  (for obtaining information on files).  These alternate functions represent\n  positions and sizes by 64-bit integers (type [int64]) instead of\n  regular integers (type [int]), thus allowing operating on files\n  whose sizes are greater than [max_int]. "]
[@@@ocaml.text " {1 Mapping files into memory} "]
val map_file :
  file_descr ->
    ?pos:int64 ->
      kind:('a, 'b) Stdlib.Bigarray.kind ->
        layout:'c Stdlib.Bigarray.layout ->
          shared:bool ->
            dims:int array -> ('a, 'b, 'c) Stdlib.Bigarray.Genarray.t
[@@ocaml.doc
  " Memory mapping of a file as a big array.\n  [map_file fd kind layout shared dims]\n  returns a big array of kind [kind], layout [layout],\n  and dimensions as specified in [dims].  The data contained in\n  this big array are the contents of the file referred to by\n  the file descriptor [fd] (as opened previously with\n  [Unix.openfile], for example).  The optional [pos] parameter\n  is the byte offset in the file of the data being mapped;\n  it defaults to 0 (map from the beginning of the file).\n\n  If [shared] is [true], all modifications performed on the array\n  are reflected in the file.  This requires that [fd] be opened\n  with write permissions.  If [shared] is [false], modifications\n  performed on the array are done in memory only, using\n  copy-on-write of the modified pages; the underlying file is not\n  affected.\n\n  [Genarray.map_file] is much more efficient than reading\n  the whole file in a big array, modifying that big array,\n  and writing it afterwards.\n\n  To adjust automatically the dimensions of the big array to\n  the actual size of the file, the major dimension (that is,\n  the first dimension for an array with C layout, and the last\n  dimension for an array with Fortran layout) can be given as\n  [-1].  [Genarray.map_file] then determines the major dimension\n  from the size of the file.  The file must contain an integral\n  number of sub-arrays as determined by the non-major dimensions,\n  otherwise [Failure] is raised.\n\n  If all dimensions of the big array are given, the file size is\n  matched against the size of the big array.  If the file is larger\n  than the big array, only the initial portion of the file is\n  mapped to the big array.  If the file is smaller than the big\n  array, the file is automatically grown to the size of the big array.\n  This requires write permissions on [fd].\n\n  Array accesses are bounds-checked, but the bounds are determined by\n  the initial call to [map_file]. Therefore, you should make sure no\n  other process modifies the mapped file while you're accessing it,\n  or a SIGBUS signal may be raised. This happens, for instance, if the\n  file is shrunk.\n\n  [Invalid_argument] or [Failure] may be raised in cases where argument\n  validation fails.\n  @since 4.06.0 "]
[@@@ocaml.text " {1 Operations on file names} "]
val unlink : string -> unit[@@ocaml.doc " Removes the named file "]
val rename : src:string -> dst:string -> unit[@@ocaml.doc
                                               " [rename old new] changes the name of a file from [old] to [new]. "]
val link : ?follow:bool -> src:string -> dst:string -> unit[@@ocaml.doc
                                                             " [link ?follow source dest] creates a hard link named [dest] to the file\n   named [source].\n\n   @param follow indicates whether a [source] symlink is followed or a\n   hardlink to [source] itself will be created. On {e Unix} systems this is\n   done using the [linkat(2)] function. If [?follow] is not provided, then the\n   [link(2)] function is used whose behaviour is OS-dependent, but more widely\n   available.\n\n   @raise ENOSYS On {e Unix} if [~follow:_] is requested, but linkat is\n                 unavailable.\n   @raise ENOSYS On {e Windows} if [~follow:false] is requested. "]
[@@@ocaml.text " {1 File permissions and ownership} "]
type access_permission = Unix.access_permission =
  | R_OK [@ocaml.doc " Read permission "]
  | W_OK [@ocaml.doc " Write permission "]
  | X_OK [@ocaml.doc " Execution permission "]
  | F_OK [@ocaml.doc " File exists "][@@ocaml.doc
                                       " Flags for the {!UnixLabels.access} call. "]
val chmod : string -> perm:file_perm -> unit[@@ocaml.doc
                                              " Change the permissions of the named file. "]
val fchmod : file_descr -> perm:file_perm -> unit[@@ocaml.doc
                                                   " Change the permissions of an opened file. "]
val chown : string -> uid:int -> gid:int -> unit[@@ocaml.doc
                                                  " Change the owner uid and owner gid of the named file. "]
val fchown : file_descr -> uid:int -> gid:int -> unit[@@ocaml.doc
                                                       " Change the owner uid and owner gid of an opened file. "]
val umask : int -> int[@@ocaml.doc
                        " Set the process's file mode creation mask, and return the previous\n    mask. "]
val access : string -> perm:access_permission list -> unit[@@ocaml.doc
                                                            " Check that the process has the given permissions over the named\n   file. Raise [Unix_error] otherwise. "]
[@@@ocaml.text " {1 Operations on file descriptors} "]
val dup : ?cloexec:bool -> file_descr -> file_descr[@@ocaml.doc
                                                     " Return a new file descriptor referencing the same file as\n   the given descriptor. "]
val dup2 : ?cloexec:bool -> src:file_descr -> dst:file_descr -> unit[@@ocaml.doc
                                                                    " [dup2 fd1 fd2] duplicates [fd1] to [fd2], closing [fd2] if already\n   opened. "]
val set_nonblock : file_descr -> unit[@@ocaml.doc
                                       " Set the ``non-blocking'' flag on the given descriptor.\n   When the non-blocking flag is set, reading on a descriptor\n   on which there is temporarily no data available raises the\n   [EAGAIN] or [EWOULDBLOCK] error instead of blocking;\n   writing on a descriptor on which there is temporarily no room\n   for writing also raises [EAGAIN] or [EWOULDBLOCK]. "]
val clear_nonblock : file_descr -> unit[@@ocaml.doc
                                         " Clear the ``non-blocking'' flag on the given descriptor.\n   See {!UnixLabels.set_nonblock}."]
val set_close_on_exec : file_descr -> unit[@@ocaml.doc
                                            " Set the ``close-on-exec'' flag on the given descriptor.\n   A descriptor with the close-on-exec flag is automatically\n   closed when the current process starts another program with\n   one of the [exec] functions. "]
val clear_close_on_exec : file_descr -> unit[@@ocaml.doc
                                              " Clear the ``close-on-exec'' flag on the given descriptor.\n   See {!UnixLabels.set_close_on_exec}."]
[@@@ocaml.text " {1 Directories} "]
val mkdir : string -> perm:file_perm -> unit[@@ocaml.doc
                                              " Create a directory with the given permissions. "]
val rmdir : string -> unit[@@ocaml.doc " Remove an empty directory. "]
val chdir : string -> unit[@@ocaml.doc
                            " Change the process working directory. "]
val getcwd : unit -> string[@@ocaml.doc
                             " Return the name of the current working directory. "]
val chroot : string -> unit[@@ocaml.doc
                             " Change the process root directory. "]
type dir_handle = Unix.dir_handle[@@ocaml.doc
                                   " The type of descriptors over opened directories. "]
val opendir : string -> dir_handle[@@ocaml.doc
                                    " Open a descriptor on a directory "]
val readdir : dir_handle -> string[@@ocaml.doc
                                    " Return the next entry in a directory.\n   @raise End_of_file when the end of the directory has been reached. "]
val rewinddir : dir_handle -> unit[@@ocaml.doc
                                    " Reposition the descriptor to the beginning of the directory "]
val closedir : dir_handle -> unit[@@ocaml.doc
                                   " Close a directory descriptor. "]
[@@@ocaml.text " {1 Pipes and redirections} "]
val pipe : ?cloexec:bool -> unit -> (file_descr * file_descr)[@@ocaml.doc
                                                               " Create a pipe. The first component of the result is opened\n   for reading, that's the exit to the pipe. The second component is\n   opened for writing, that's the entrance to the pipe. "]
val mkfifo : string -> perm:file_perm -> unit[@@ocaml.doc
                                               " Create a named pipe with the given permissions. "]
[@@@ocaml.text " {1 High-level process and redirection management} "]
val create_process :
  prog:string ->
    args:string array ->
      stdin:file_descr -> stdout:file_descr -> stderr:file_descr -> int
[@@ocaml.doc
  " [create_process prog args new_stdin new_stdout new_stderr]\n   forks a new process that executes the program\n   in file [prog], with arguments [args]. The pid of the new\n   process is returned immediately; the new process executes\n   concurrently with the current process.\n   The standard input and outputs of the new process are connected\n   to the descriptors [new_stdin], [new_stdout] and [new_stderr].\n   Passing e.g. [stdout] for [new_stdout] prevents the redirection\n   and causes the new process to have the same standard output\n   as the current process.\n   The executable file [prog] is searched in the path.\n   The new process has the same environment as the current process. "]
val create_process_env :
  prog:string ->
    args:string array ->
      env:string array ->
        stdin:file_descr -> stdout:file_descr -> stderr:file_descr -> int
[@@ocaml.doc
  " [create_process_env prog args env new_stdin new_stdout new_stderr]\n   works as {!UnixLabels.create_process}, except that the extra argument\n   [env] specifies the environment passed to the program. "]
val open_process_in : string -> in_channel[@@ocaml.doc
                                            " High-level pipe and process management. This function\n   runs the given command in parallel with the program.\n   The standard output of the command is redirected to a pipe,\n   which can be read via the returned input channel.\n   The command is interpreted by the shell [/bin/sh] (cf. [system]). "]
val open_process_out : string -> out_channel[@@ocaml.doc
                                              " Same as {!UnixLabels.open_process_in}, but redirect the standard input of\n   the command to a pipe.  Data written to the returned output channel\n   is sent to the standard input of the command.\n   Warning: writes on output channels are buffered, hence be careful\n   to call {!Stdlib.flush} at the right times to ensure\n   correct synchronization. "]
val open_process : string -> (in_channel * out_channel)[@@ocaml.doc
                                                         " Same as {!UnixLabels.open_process_out}, but redirects both the standard\n   input and standard output of the command to pipes connected to the two\n   returned channels.  The input channel is connected to the output\n   of the command, and the output channel to the input of the command. "]
val open_process_full :
  string -> env:string array -> (in_channel * out_channel * in_channel)
[@@ocaml.doc
  " Similar to {!UnixLabels.open_process}, but the second argument specifies\n   the environment passed to the command.  The result is a triple\n   of channels connected respectively to the standard output, standard input,\n   and standard error of the command. "]
val open_process_args_in : string -> string array -> in_channel[@@ocaml.doc
                                                                 " High-level pipe and process management. The first argument specifies the\n   command to run, and the second argument specifies the argument array passed\n   to the command.  This function runs the command in parallel with the program.\n   The standard output of the command is redirected to a pipe, which can be read\n   via the returned input channel.\n\n    @since 4.08.0 "]
val open_process_args_out : string -> string array -> out_channel[@@ocaml.doc
                                                                   " Same as {!Unix.open_process_args_in}, but redirect the standard input of the\n   command to a pipe.  Data written to the returned output channel is sent to\n   the standard input of the command.  Warning: writes on output channels are\n   buffered, hence be careful to call {!Stdlib.flush} at the right times to\n   ensure correct synchronization.\n\n    @since 4.08.0 "]
val open_process_args : string -> string array -> (in_channel * out_channel)
[@@ocaml.doc
  " Same as {!Unix.open_process_args_out}, but redirects both the standard input\n   and standard output of the command to pipes connected to the two returned\n   channels.  The input channel is connected to the output of the command, and\n   the output channel to the input of the command.\n\n    @since 4.08.0 "]
val open_process_args_full :
  string ->
    string array -> string array -> (in_channel * out_channel * in_channel)
[@@ocaml.doc
  " Similar to {!Unix.open_process_args}, but the third argument specifies the\n   environment passed to the command.  The result is a triple of channels\n   connected respectively to the standard output, standard input, and standard\n   error of the command.\n\n    @since 4.08.0 "]
val close_process_in : in_channel -> process_status[@@ocaml.doc
                                                     " Close channels opened by {!UnixLabels.open_process_in},\n   wait for the associated command to terminate,\n   and return its termination status. "]
val close_process_out : out_channel -> process_status[@@ocaml.doc
                                                       " Close channels opened by {!UnixLabels.open_process_out},\n   wait for the associated command to terminate,\n   and return its termination status. "]
val close_process : (in_channel * out_channel) -> process_status[@@ocaml.doc
                                                                  " Close channels opened by {!UnixLabels.open_process},\n   wait for the associated command to terminate,\n   and return its termination status. "]
val close_process_full :
  (in_channel * out_channel * in_channel) -> process_status[@@ocaml.doc
                                                             " Close channels opened by {!UnixLabels.open_process_full},\n   wait for the associated command to terminate,\n   and return its termination status. "]
[@@@ocaml.text " {1 Symbolic links} "]
val symlink : ?to_dir:bool -> src:string -> dst:string -> unit[@@ocaml.doc
                                                                " [symlink source dest] creates the file [dest] as a symbolic link\n   to the file [source]. See {!Unix.symlink} for details of [~to_dir] "]
val has_symlink : unit -> bool[@@ocaml.doc
                                " Returns [true] if the user is able to create symbolic links. On Windows,\n   this indicates that the user not only has the SeCreateSymbolicLinkPrivilege\n   but is also running elevated, if necessary. On other platforms, this is\n   simply indicates that the symlink system call is available.\n   @since 4.03.0 "]
val readlink : string -> string[@@ocaml.doc " Read the contents of a link. "]
[@@@ocaml.text " {1 Polling} "]
val select :
  read:file_descr list ->
    write:file_descr list ->
      except:file_descr list ->
        timeout:float ->
          (file_descr list * file_descr list * file_descr list)[@@ocaml.doc
                                                                 " Wait until some input/output operations become possible on\n   some channels. The three list arguments are, respectively, a set\n   of descriptors to check for reading (first argument), for writing\n   (second argument), or for exceptional conditions (third argument).\n   The fourth argument is the maximal timeout, in seconds; a\n   negative fourth argument means no timeout (unbounded wait).\n   The result is composed of three sets of descriptors: those ready\n   for reading (first component), ready for writing (second component),\n   and over which an exceptional condition is pending (third\n   component). "]
[@@@ocaml.text " {1 Locking} "]
type lock_command = Unix.lock_command =
  | F_ULOCK [@ocaml.doc " Unlock a region "]
  | F_LOCK
  [@ocaml.doc " Lock a region for writing, and block if already locked "]
  | F_TLOCK
  [@ocaml.doc " Lock a region for writing, or fail if already locked "]
  | F_TEST [@ocaml.doc " Test a region for other process locks "]
  | F_RLOCK
  [@ocaml.doc " Lock a region for reading, and block if already locked "]
  | F_TRLOCK
  [@ocaml.doc " Lock a region for reading, or fail if already locked "]
[@@ocaml.doc " Commands for {!UnixLabels.lockf}. "]
val lockf : file_descr -> mode:lock_command -> len:int -> unit[@@ocaml.doc
                                                                " [lockf fd cmd size] puts a lock on a region of the file opened\n   as [fd]. The region starts at the current read/write position for\n   [fd] (as set by {!UnixLabels.lseek}), and extends [size] bytes forward if\n   [size] is positive, [size] bytes backwards if [size] is negative,\n   or to the end of the file if [size] is zero.\n   A write lock prevents any other\n   process from acquiring a read or write lock on the region.\n   A read lock prevents any other\n   process from acquiring a write lock on the region, but lets\n   other processes acquire read locks on it.\n\n   The [F_LOCK] and [F_TLOCK] commands attempts to put a write lock\n   on the specified region.\n   The [F_RLOCK] and [F_TRLOCK] commands attempts to put a read lock\n   on the specified region.\n   If one or several locks put by another process prevent the current process\n   from acquiring the lock, [F_LOCK] and [F_RLOCK] block until these locks\n   are removed, while [F_TLOCK] and [F_TRLOCK] fail immediately with an\n   exception.\n   The [F_ULOCK] removes whatever locks the current process has on\n   the specified region.\n   Finally, the [F_TEST] command tests whether a write lock can be\n   acquired on the specified region, without actually putting a lock.\n   It returns immediately if successful, or fails otherwise. "]
[@@@ocaml.text
  " {1 Signals}\n   Note: installation of signal handlers is performed via\n   the functions {!Sys.signal} and {!Sys.set_signal}.\n"]
val kill : pid:int -> signal:int -> unit[@@ocaml.doc
                                          " [kill pid sig] sends signal number [sig] to the process\n   with id [pid]. "]
type sigprocmask_command = Unix.sigprocmask_command =
  | SIG_SETMASK 
  | SIG_BLOCK 
  | SIG_UNBLOCK 
val sigprocmask : mode:sigprocmask_command -> int list -> int list[@@ocaml.doc
                                                                    " [sigprocmask cmd sigs] changes the set of blocked signals.\n   If [cmd] is [SIG_SETMASK], blocked signals are set to those in\n   the list [sigs].\n   If [cmd] is [SIG_BLOCK], the signals in [sigs] are added to\n   the set of blocked signals.\n   If [cmd] is [SIG_UNBLOCK], the signals in [sigs] are removed\n   from the set of blocked signals.\n   [sigprocmask] returns the set of previously blocked signals. "]
val sigpending : unit -> int list[@@ocaml.doc
                                   " Return the set of blocked signals that are currently pending. "]
val sigsuspend : int list -> unit[@@ocaml.doc
                                   " [sigsuspend sigs] atomically sets the blocked signals to [sigs]\n   and waits for a non-ignored, non-blocked signal to be delivered.\n   On return, the blocked signals are reset to their initial value. "]
val pause : unit -> unit[@@ocaml.doc
                          " Wait until a non-ignored, non-blocked signal is delivered. "]
[@@@ocaml.text " {1 Time functions} "]
type process_times = Unix.process_times =
  {
  tms_utime: float [@ocaml.doc " User time for the process "];
  tms_stime: float [@ocaml.doc " System time for the process "];
  tms_cutime: float [@ocaml.doc " User time for the children processes "];
  tms_cstime: float [@ocaml.doc " System time for the children processes "]}
[@@ocaml.doc " The execution times (CPU times) of a process. "]
type tm = Unix.tm =
  {
  tm_sec: int [@ocaml.doc " Seconds 0..60 "];
  tm_min: int [@ocaml.doc " Minutes 0..59 "];
  tm_hour: int [@ocaml.doc " Hours 0..23 "];
  tm_mday: int [@ocaml.doc " Day of month 1..31 "];
  tm_mon: int [@ocaml.doc " Month of year 0..11 "];
  tm_year: int [@ocaml.doc " Year - 1900 "];
  tm_wday: int [@ocaml.doc " Day of week (Sunday is 0) "];
  tm_yday: int [@ocaml.doc " Day of year 0..365 "];
  tm_isdst: bool [@ocaml.doc " Daylight time savings in effect "]}[@@ocaml.doc
                                                                    " The type representing wallclock time and calendar date. "]
val time : unit -> float[@@ocaml.doc
                          " Return the current time since 00:00:00 GMT, Jan. 1, 1970,\n   in seconds. "]
val gettimeofday : unit -> float[@@ocaml.doc
                                  " Same as {!UnixLabels.time}, but with resolution better than 1 second. "]
val gmtime : float -> tm[@@ocaml.doc
                          " Convert a time in seconds, as returned by {!UnixLabels.time}, into a date\n   and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. "]
val localtime : float -> tm[@@ocaml.doc
                             " Convert a time in seconds, as returned by {!UnixLabels.time}, into a date\n   and a time. Assumes the local time zone. "]
val mktime : tm -> (float * tm)[@@ocaml.doc
                                 " Convert a date and time, specified by the [tm] argument, into\n   a time in seconds, as returned by {!UnixLabels.time}.  The [tm_isdst],\n   [tm_wday] and [tm_yday] fields of [tm] are ignored.  Also return a\n   normalized copy of the given [tm] record, with the [tm_wday],\n   [tm_yday], and [tm_isdst] fields recomputed from the other fields,\n   and the other fields normalized (so that, e.g., 40 October is\n   changed into 9 November).  The [tm] argument is interpreted in the\n   local time zone. "]
val alarm : int -> int[@@ocaml.doc
                        " Schedule a [SIGALRM] signal after the given number of seconds. "]
val sleep : int -> unit[@@ocaml.doc
                         " Stop execution for the given number of seconds. "]
val times : unit -> process_times[@@ocaml.doc
                                   " Return the execution times of the process. "]
val utimes : string -> access:float -> modif:float -> unit[@@ocaml.doc
                                                            " Set the last access time (second arg) and last modification time\n   (third arg) for a file. Times are expressed in seconds from\n   00:00:00 GMT, Jan. 1, 1970.  A time of [0.0] is interpreted as the\n   current time. "]
type interval_timer = Unix.interval_timer =
  | ITIMER_REAL
  [@ocaml.doc
    " decrements in real time, and sends the signal [SIGALRM] when\n          expired."]
  | ITIMER_VIRTUAL
  [@ocaml.doc
    " decrements in process virtual time, and sends [SIGVTALRM] when\n          expired. "]
  | ITIMER_PROF
  [@ocaml.doc
    " (for profiling) decrements both when the process\n         is running and when the system is running on behalf of the\n         process; it sends [SIGPROF] when expired. "]
[@@ocaml.doc " The three kinds of interval timers. "]
type interval_timer_status = Unix.interval_timer_status =
  {
  it_interval: float [@ocaml.doc " Period "];
  it_value: float [@ocaml.doc " Current value of the timer "]}[@@ocaml.doc
                                                                " The type describing the status of an interval timer "]
val getitimer : interval_timer -> interval_timer_status[@@ocaml.doc
                                                         " Return the current status of the given interval timer. "]
val setitimer :
  interval_timer -> interval_timer_status -> interval_timer_status[@@ocaml.doc
                                                                    " [setitimer t s] sets the interval timer [t] and returns\n   its previous status. The [s] argument is interpreted as follows:\n   [s.it_value], if nonzero, is the time to the next timer expiration;\n   [s.it_interval], if nonzero, specifies a value to\n   be used in reloading it_value when the timer expires.\n   Setting [s.it_value] to zero disable the timer.\n   Setting [s.it_interval] to zero causes the timer to be disabled\n   after its next expiration. "]
[@@@ocaml.text " {1 User id, group id} "]
val getuid : unit -> int[@@ocaml.doc
                          " Return the user id of the user executing the process. "]
val geteuid : unit -> int[@@ocaml.doc
                           " Return the effective user id under which the process runs. "]
val setuid : int -> unit[@@ocaml.doc
                          " Set the real user id and effective user id for the process. "]
val getgid : unit -> int[@@ocaml.doc
                          " Return the group id of the user executing the process. "]
val getegid : unit -> int[@@ocaml.doc
                           " Return the effective group id under which the process runs. "]
val setgid : int -> unit[@@ocaml.doc
                          " Set the real group id and effective group id for the process. "]
val getgroups : unit -> int array[@@ocaml.doc
                                   " Return the list of groups to which the user executing the process\n   belongs. "]
val setgroups : int array -> unit[@@ocaml.doc
                                   " [setgroups groups] sets the supplementary group IDs for the\n      calling process. Appropriate privileges are required. "]
val initgroups : string -> int -> unit[@@ocaml.doc
                                        " [initgroups user group] initializes the group access list by\n      reading the group database /etc/group and using all groups of\n      which [user] is a member. The additional group [group] is also\n      added to the list. "]
type passwd_entry = Unix.passwd_entry =
  {
  pw_name: string ;
  pw_passwd: string ;
  pw_uid: int ;
  pw_gid: int ;
  pw_gecos: string ;
  pw_dir: string ;
  pw_shell: string }[@@ocaml.doc
                      " Structure of entries in the [passwd] database. "]
type group_entry = Unix.group_entry =
  {
  gr_name: string ;
  gr_passwd: string ;
  gr_gid: int ;
  gr_mem: string array }[@@ocaml.doc
                          " Structure of entries in the [groups] database. "]
val getlogin : unit -> string[@@ocaml.doc
                               " Return the login name of the user executing the process. "]
val getpwnam : string -> passwd_entry[@@ocaml.doc
                                       " Find an entry in [passwd] with the given name, or raise\n   [Not_found] if the matching entry is not found. "]
val getgrnam : string -> group_entry[@@ocaml.doc
                                      " Find an entry in [group] with the given name, or raise\n   [Not_found] if the matching entry is not found. "]
val getpwuid : int -> passwd_entry[@@ocaml.doc
                                    " Find an entry in [passwd] with the given user id, or raise\n   [Not_found] if the matching entry is not found. "]
val getgrgid : int -> group_entry[@@ocaml.doc
                                   " Find an entry in [group] with the given group id, or raise\n   [Not_found] if the matching entry is not found. "]
[@@@ocaml.text " {1 Internet addresses} "]
type inet_addr = Unix.inet_addr[@@ocaml.doc
                                 " The abstract type of Internet addresses. "]
val inet_addr_of_string : string -> inet_addr[@@ocaml.doc
                                               " Conversion from the printable representation of an Internet\n    address to its internal representation.  The argument string\n    consists of 4 numbers separated by periods ([XXX.YYY.ZZZ.TTT])\n    for IPv4 addresses, and up to 8 numbers separated by colons\n    for IPv6 addresses.  Raise [Failure] when given a string that\n    does not match these formats. "]
val string_of_inet_addr : inet_addr -> string[@@ocaml.doc
                                               " Return the printable representation of the given Internet address.\n    See {!Unix.inet_addr_of_string} for a description of the\n    printable representation. "]
val inet_addr_any : inet_addr[@@ocaml.doc
                               " A special IPv4 address, for use only with [bind], representing\n   all the Internet addresses that the host machine possesses. "]
val inet_addr_loopback : inet_addr[@@ocaml.doc
                                    " A special IPv4 address representing the host machine ([127.0.0.1]). "]
val inet6_addr_any : inet_addr[@@ocaml.doc
                                " A special IPv6 address, for use only with [bind], representing\n   all the Internet addresses that the host machine possesses. "]
val inet6_addr_loopback : inet_addr[@@ocaml.doc
                                     " A special IPv6 address representing the host machine ([::1]). "]
[@@@ocaml.text " {1 Sockets} "]
type socket_domain = Unix.socket_domain =
  | PF_UNIX [@ocaml.doc " Unix domain "]
  | PF_INET [@ocaml.doc " Internet domain (IPv4) "]
  | PF_INET6 [@ocaml.doc " Internet domain (IPv6) "][@@ocaml.doc
                                                      " The type of socket domains.  Not all platforms support\n    IPv6 sockets (type [PF_INET6]). "]
type socket_type = Unix.socket_type =
  | SOCK_STREAM [@ocaml.doc " Stream socket "]
  | SOCK_DGRAM [@ocaml.doc " Datagram socket "]
  | SOCK_RAW [@ocaml.doc " Raw socket "]
  | SOCK_SEQPACKET [@ocaml.doc " Sequenced packets socket "][@@ocaml.doc
                                                              " The type of socket kinds, specifying the semantics of\n   communications. "]
type sockaddr = Unix.sockaddr =
  | ADDR_UNIX of string 
  | ADDR_INET of inet_addr * int
  [@ocaml.doc
    " The type of socket addresses. [ADDR_UNIX name] is a socket\n   address in the Unix domain; [name] is a file name in the file\n   system. [ADDR_INET(addr,port)] is a socket address in the Internet\n   domain; [addr] is the Internet address of the machine, and\n   [port] is the port number. "]
val socket :
  ?cloexec:bool ->
    domain:socket_domain -> kind:socket_type -> protocol:int -> file_descr
[@@ocaml.doc
  " Create a new socket in the given domain, and with the\n   given kind. The third argument is the protocol type; 0 selects\n   the default protocol for that kind of sockets. "]
val domain_of_sockaddr : sockaddr -> socket_domain[@@ocaml.doc
                                                    " Return the socket domain adequate for the given socket address. "]
val socketpair :
  ?cloexec:bool ->
    domain:socket_domain ->
      kind:socket_type -> protocol:int -> (file_descr * file_descr)[@@ocaml.doc
                                                                    " Create a pair of unnamed sockets, connected together. "]
val accept : ?cloexec:bool -> file_descr -> (file_descr * sockaddr)[@@ocaml.doc
                                                                    " Accept connections on the given socket. The returned descriptor\n   is a socket connected to the client; the returned address is\n   the address of the connecting client. "]
val bind : file_descr -> addr:sockaddr -> unit[@@ocaml.doc
                                                " Bind a socket to an address. "]
val connect : file_descr -> addr:sockaddr -> unit[@@ocaml.doc
                                                   " Connect a socket to an address. "]
val listen : file_descr -> max:int -> unit[@@ocaml.doc
                                            " Set up a socket for receiving connection requests. The integer\n   argument is the maximal number of pending requests. "]
type shutdown_command = Unix.shutdown_command =
  | SHUTDOWN_RECEIVE [@ocaml.doc " Close for receiving "]
  | SHUTDOWN_SEND [@ocaml.doc " Close for sending "]
  | SHUTDOWN_ALL [@ocaml.doc " Close both "][@@ocaml.doc
                                              " The type of commands for [shutdown]. "]
val shutdown : file_descr -> mode:shutdown_command -> unit[@@ocaml.doc
                                                            " Shutdown a socket connection. [SHUTDOWN_SEND] as second argument\n   causes reads on the other end of the connection to return\n   an end-of-file condition.\n   [SHUTDOWN_RECEIVE] causes writes on the other end of the connection\n   to return a closed pipe condition ([SIGPIPE] signal). "]
val getsockname : file_descr -> sockaddr[@@ocaml.doc
                                          " Return the address of the given socket. "]
val getpeername : file_descr -> sockaddr[@@ocaml.doc
                                          " Return the address of the host connected to the given socket. "]
type msg_flag = Unix.msg_flag =
  | MSG_OOB 
  | MSG_DONTROUTE 
  | MSG_PEEK
  [@ocaml.doc
    " The flags for {!UnixLabels.recv},  {!UnixLabels.recvfrom},\n   {!UnixLabels.send} and {!UnixLabels.sendto}. "]
val recv :
  file_descr -> buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc " Receive data from a connected socket. "]
val recvfrom :
  file_descr ->
    buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> (int * sockaddr)
[@@ocaml.doc " Receive data from an unconnected socket. "]
val send :
  file_descr -> buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc " Send data over a connected socket. "]
val send_substring :
  file_descr -> buf:string -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc
  " Same as [send], but take the data from a string instead of a byte\n    sequence.\n    @since 4.02.0 "]
val sendto :
  file_descr ->
    buf:bytes ->
      pos:int -> len:int -> mode:msg_flag list -> addr:sockaddr -> int
[@@ocaml.doc " Send data over an unconnected socket. "]
val sendto_substring :
  file_descr ->
    buf:string -> pos:int -> len:int -> mode:msg_flag list -> sockaddr -> int
[@@ocaml.doc
  " Same as [sendto], but take the data from a string instead of a\n    byte sequence.\n    @since 4.02.0 "]
[@@@ocaml.text " {1 Socket options} "]
type socket_bool_option =
  | SO_DEBUG [@ocaml.doc " Record debugging information "]
  | SO_BROADCAST [@ocaml.doc " Permit sending of broadcast messages "]
  | SO_REUSEADDR [@ocaml.doc " Allow reuse of local addresses for bind "]
  | SO_KEEPALIVE [@ocaml.doc " Keep connection active "]
  | SO_DONTROUTE [@ocaml.doc " Bypass the standard routing algorithms "]
  | SO_OOBINLINE [@ocaml.doc " Leave out-of-band data in line "]
  | SO_ACCEPTCONN
  [@ocaml.doc " Report whether socket listening is enabled "]
  | TCP_NODELAY [@ocaml.doc " Control the Nagle algorithm for TCP sockets "]
  | IPV6_ONLY
  [@ocaml.doc " Forbid binding an IPv6 socket to an IPv4 address "][@@ocaml.doc
                                                                    " The socket options that can be consulted with {!UnixLabels.getsockopt}\n   and modified with {!UnixLabels.setsockopt}.  These options have a boolean\n   ([true]/[false]) value. "]
type socket_int_option =
  | SO_SNDBUF [@ocaml.doc " Size of send buffer "]
  | SO_RCVBUF [@ocaml.doc " Size of received buffer "]
  | SO_ERROR
  [@ocaml.doc " Deprecated.  Use {!Unix.getsockopt_error} instead. "]
  | SO_TYPE [@ocaml.doc " Report the socket type "]
  | SO_RCVLOWAT
  [@ocaml.doc " Minimum number of bytes to process for input operations "]
  | SO_SNDLOWAT
  [@ocaml.doc " Minimum number of bytes to process for output operations "]
[@@ocaml.doc
  " The socket options that can be consulted with {!UnixLabels.getsockopt_int}\n   and modified with {!UnixLabels.setsockopt_int}.  These options have an\n   integer value. "]
type socket_optint_option =
  | SO_LINGER
  [@ocaml.doc
    " Whether to linger on closed connections\n                    that have data present, and for how long\n                    (in seconds) "]
[@@ocaml.doc
  " The socket options that can be consulted with {!Unix.getsockopt_optint}\n   and modified with {!Unix.setsockopt_optint}.  These options have a\n   value of type [int option], with [None] meaning ``disabled''. "]
type socket_float_option =
  | SO_RCVTIMEO [@ocaml.doc " Timeout for input operations "]
  | SO_SNDTIMEO [@ocaml.doc " Timeout for output operations "][@@ocaml.doc
                                                                " The socket options that can be consulted with {!UnixLabels.getsockopt_float}\n   and modified with {!UnixLabels.setsockopt_float}.  These options have a\n   floating-point value representing a time in seconds.\n   The value 0 means infinite timeout. "]
val getsockopt : file_descr -> socket_bool_option -> bool[@@ocaml.doc
                                                           " Return the current status of a boolean-valued option\n   in the given socket. "]
val setsockopt : file_descr -> socket_bool_option -> bool -> unit[@@ocaml.doc
                                                                   " Set or clear a boolean-valued option in the given socket. "]
val getsockopt_int : file_descr -> socket_int_option -> int[@@ocaml.doc
                                                             " Same as {!Unix.getsockopt} for an integer-valued socket option. "]
val setsockopt_int : file_descr -> socket_int_option -> int -> unit[@@ocaml.doc
                                                                    " Same as {!Unix.setsockopt} for an integer-valued socket option. "]
val getsockopt_optint : file_descr -> socket_optint_option -> int option
[@@ocaml.doc
  " Same as {!Unix.getsockopt} for a socket option whose value is\n    an [int option]. "]
val setsockopt_optint :
  file_descr -> socket_optint_option -> int option -> unit[@@ocaml.doc
                                                            " Same as {!Unix.setsockopt} for a socket option whose value is\n    an [int option]. "]
val getsockopt_float : file_descr -> socket_float_option -> float[@@ocaml.doc
                                                                   " Same as {!Unix.getsockopt} for a socket option whose value is a\n    floating-point number. "]
val setsockopt_float : file_descr -> socket_float_option -> float -> unit
[@@ocaml.doc
  " Same as {!Unix.setsockopt} for a socket option whose value is a\n    floating-point number. "]
val getsockopt_error : file_descr -> error option[@@ocaml.doc
                                                   " Return the error condition associated with the given socket,\n    and clear it. "]
[@@@ocaml.text " {1 High-level network connection functions} "]
val open_connection : sockaddr -> (in_channel * out_channel)[@@ocaml.doc
                                                              " Connect to a server at the given address.\n   Return a pair of buffered channels connected to the server.\n   Remember to call {!Stdlib.flush} on the output channel at the right\n   times to ensure correct synchronization. "]
val shutdown_connection : in_channel -> unit[@@ocaml.doc
                                              " ``Shut down'' a connection established with {!UnixLabels.open_connection};\n   that is, transmit an end-of-file condition to the server reading\n   on the other side of the connection. "]
val establish_server :
  (in_channel -> out_channel -> unit) -> addr:sockaddr -> unit[@@ocaml.doc
                                                                " Establish a server on the given address.\n   The function given as first argument is called for each connection\n   with two buffered channels connected to the client. A new process\n   is created for each connection. The function {!UnixLabels.establish_server}\n   never returns normally. "]
[@@@ocaml.text " {1 Host and protocol databases} "]
type host_entry = Unix.host_entry =
  {
  h_name: string ;
  h_aliases: string array ;
  h_addrtype: socket_domain ;
  h_addr_list: inet_addr array }[@@ocaml.doc
                                  " Structure of entries in the [hosts] database. "]
type protocol_entry = Unix.protocol_entry =
  {
  p_name: string ;
  p_aliases: string array ;
  p_proto: int }[@@ocaml.doc
                  " Structure of entries in the [protocols] database. "]
type service_entry = Unix.service_entry =
  {
  s_name: string ;
  s_aliases: string array ;
  s_port: int ;
  s_proto: string }[@@ocaml.doc
                     " Structure of entries in the [services] database. "]
val gethostname : unit -> string[@@ocaml.doc
                                  " Return the name of the local host. "]
val gethostbyname : string -> host_entry[@@ocaml.doc
                                          " Find an entry in [hosts] with the given name, or raise\n   [Not_found]. "]
val gethostbyaddr : inet_addr -> host_entry[@@ocaml.doc
                                             " Find an entry in [hosts] with the given address, or raise\n   [Not_found]. "]
val getprotobyname : string -> protocol_entry[@@ocaml.doc
                                               " Find an entry in [protocols] with the given name, or raise\n   [Not_found]. "]
val getprotobynumber : int -> protocol_entry[@@ocaml.doc
                                              " Find an entry in [protocols] with the given protocol number,\n   or raise [Not_found]. "]
val getservbyname : string -> protocol:string -> service_entry[@@ocaml.doc
                                                                " Find an entry in [services] with the given name, or raise\n   [Not_found]. "]
val getservbyport : int -> protocol:string -> service_entry[@@ocaml.doc
                                                             " Find an entry in [services] with the given service number,\n   or raise [Not_found]. "]
type addr_info =
  {
  ai_family: socket_domain [@ocaml.doc " Socket domain "];
  ai_socktype: socket_type [@ocaml.doc " Socket type "];
  ai_protocol: int [@ocaml.doc " Socket protocol number "];
  ai_addr: sockaddr [@ocaml.doc " Address "];
  ai_canonname: string [@ocaml.doc " Canonical host name  "]}[@@ocaml.doc
                                                               " Address information returned by {!Unix.getaddrinfo}. "]
type getaddrinfo_option =
  | AI_FAMILY of socket_domain
  [@ocaml.doc " Impose the given socket domain "]
  | AI_SOCKTYPE of socket_type [@ocaml.doc " Impose the given socket type "]
  | AI_PROTOCOL of int [@ocaml.doc " Impose the given protocol  "]
  | AI_NUMERICHOST
  [@ocaml.doc
    " Do not call name resolver,\n                                            expect numeric IP address "]
  | AI_CANONNAME
  [@ocaml.doc
    " Fill the [ai_canonname] field\n                                            of the result "]
  | AI_PASSIVE
  [@ocaml.doc
    " Set address to ``any'' address\n                                            for use with {!Unix.bind} "]
[@@ocaml.doc " Options to {!Unix.getaddrinfo}. "]
val getaddrinfo :
  string -> string -> getaddrinfo_option list -> addr_info list[@@ocaml.doc
                                                                 " [getaddrinfo host service opts] returns a list of {!Unix.addr_info}\n    records describing socket parameters and addresses suitable for\n    communicating with the given host and service.  The empty list is\n    returned if the host or service names are unknown, or the constraints\n    expressed in [opts] cannot be satisfied.\n\n    [host] is either a host name or the string representation of an IP\n    address.  [host] can be given as the empty string; in this case,\n    the ``any'' address or the ``loopback'' address are used,\n    depending whether [opts] contains [AI_PASSIVE].\n    [service] is either a service name or the string representation of\n    a port number.  [service] can be given as the empty string;\n    in this case, the port field of the returned addresses is set to 0.\n    [opts] is a possibly empty list of options that allows the caller\n    to force a particular socket domain (e.g. IPv6 only or IPv4 only)\n    or a particular socket type (e.g. TCP only or UDP only). "]
type name_info =
  {
  ni_hostname: string [@ocaml.doc " Name or IP address of host "];
  ni_service: string [@ocaml.doc " Name of service or port number "]}
[@@ocaml.doc
  " Host and service information returned by {!Unix.getnameinfo}. "]
type getnameinfo_option =
  | NI_NOFQDN [@ocaml.doc " Do not qualify local host names "]
  | NI_NUMERICHOST [@ocaml.doc " Always return host as IP address "]
  | NI_NAMEREQD [@ocaml.doc " Fail if host name cannot be determined "]
  | NI_NUMERICSERV [@ocaml.doc " Always return service as port number "]
  | NI_DGRAM
  [@ocaml.doc
    " Consider the service as UDP-based\n                             instead of the default TCP "]
[@@ocaml.doc " Options to {!Unix.getnameinfo}. "]
val getnameinfo : sockaddr -> getnameinfo_option list -> name_info[@@ocaml.doc
                                                                    " [getnameinfo addr opts] returns the host name and service name\n    corresponding to the socket address [addr].  [opts] is a possibly\n    empty list of options that governs how these names are obtained.\n    Raise [Not_found] if an error occurs. "]
[@@@ocaml.text " {1 Terminal interface} "]
[@@@ocaml.text
  " The following functions implement the POSIX standard terminal\n   interface. They provide control over asynchronous communication ports\n   and pseudo-terminals. Refer to the [termios] man page for a\n   complete description. "]
type terminal_io = Unix.terminal_io =
  {
  mutable c_ignbrk: bool [@ocaml.doc " Ignore the break condition. "];
  mutable c_brkint: bool
    [@ocaml.doc " Signal interrupt on break condition. "];
  mutable c_ignpar: bool
    [@ocaml.doc " Ignore characters with parity errors. "];
  mutable c_parmrk: bool [@ocaml.doc " Mark parity errors. "];
  mutable c_inpck: bool [@ocaml.doc " Enable parity check on input. "];
  mutable c_istrip: bool [@ocaml.doc " Strip 8th bit on input characters. "];
  mutable c_inlcr: bool [@ocaml.doc " Map NL to CR on input. "];
  mutable c_igncr: bool [@ocaml.doc " Ignore CR on input. "];
  mutable c_icrnl: bool [@ocaml.doc " Map CR to NL on input. "];
  mutable c_ixon: bool
    [@ocaml.doc " Recognize XON/XOFF characters on input. "];
  mutable c_ixoff: bool
    [@ocaml.doc " Emit XON/XOFF chars to control input flow. "];
  mutable c_opost: bool [@ocaml.doc " Enable output processing. "];
  mutable c_obaud: int
    [@ocaml.doc " Output baud rate (0 means close connection)."];
  mutable c_ibaud: int [@ocaml.doc " Input baud rate. "];
  mutable c_csize: int [@ocaml.doc " Number of bits per character (5-8). "];
  mutable c_cstopb: int [@ocaml.doc " Number of stop bits (1-2). "];
  mutable c_cread: bool [@ocaml.doc " Reception is enabled. "];
  mutable c_parenb: bool
    [@ocaml.doc " Enable parity generation and detection. "];
  mutable c_parodd: bool [@ocaml.doc " Specify odd parity instead of even. "];
  mutable c_hupcl: bool [@ocaml.doc " Hang up on last close. "];
  mutable c_clocal: bool [@ocaml.doc " Ignore modem status lines. "];
  mutable c_isig: bool [@ocaml.doc " Generate signal on INTR, QUIT, SUSP. "];
  mutable c_icanon: bool
    [@ocaml.doc
      " Enable canonical processing\n                                 (line buffering and editing) "];
  mutable c_noflsh: bool
    [@ocaml.doc " Disable flush after INTR, QUIT, SUSP. "];
  mutable c_echo: bool [@ocaml.doc " Echo input characters. "];
  mutable c_echoe: bool
    [@ocaml.doc " Echo ERASE (to erase previous character). "];
  mutable c_echok: bool
    [@ocaml.doc " Echo KILL (to erase the current line). "];
  mutable c_echonl: bool [@ocaml.doc " Echo NL even if c_echo is not set. "];
  mutable c_vintr: char
    [@ocaml.doc " Interrupt character (usually ctrl-C). "];
  mutable c_vquit: char [@ocaml.doc " Quit character (usually ctrl-\\). "];
  mutable c_verase: char
    [@ocaml.doc " Erase character (usually DEL or ctrl-H). "];
  mutable c_vkill: char
    [@ocaml.doc " Kill line character (usually ctrl-U). "];
  mutable c_veof: char
    [@ocaml.doc " End-of-file character (usually ctrl-D). "];
  mutable c_veol: char
    [@ocaml.doc " Alternate end-of-line char. (usually none). "];
  mutable c_vmin: int
    [@ocaml.doc
      " Minimum number of characters to read\n                                 before the read request is satisfied. "];
  mutable c_vtime: int [@ocaml.doc " Maximum read wait (in 0.1s units). "];
  mutable c_vstart: char [@ocaml.doc " Start character (usually ctrl-Q). "];
  mutable c_vstop: char [@ocaml.doc " Stop character (usually ctrl-S). "]}
val tcgetattr : file_descr -> terminal_io[@@ocaml.doc
                                           " Return the status of the terminal referred to by the given\n   file descriptor. "]
type setattr_when = Unix.setattr_when =
  | TCSANOW 
  | TCSADRAIN 
  | TCSAFLUSH 
val tcsetattr : file_descr -> mode:setattr_when -> terminal_io -> unit
[@@ocaml.doc
  " Set the status of the terminal referred to by the given\n   file descriptor. The second argument indicates when the\n   status change takes place: immediately ([TCSANOW]),\n   when all pending output has been transmitted ([TCSADRAIN]),\n   or after flushing all input that has been received but not\n   read ([TCSAFLUSH]). [TCSADRAIN] is recommended when changing\n   the output parameters; [TCSAFLUSH], when changing the input\n   parameters. "]
val tcsendbreak : file_descr -> duration:int -> unit[@@ocaml.doc
                                                      " Send a break condition on the given file descriptor.\n   The second argument is the duration of the break, in 0.1s units;\n   0 means standard duration (0.25s). "]
val tcdrain : file_descr -> unit[@@ocaml.doc
                                  " Waits until all output written on the given file descriptor\n   has been transmitted. "]
type flush_queue = Unix.flush_queue =
  | TCIFLUSH 
  | TCOFLUSH 
  | TCIOFLUSH 
val tcflush : file_descr -> mode:flush_queue -> unit[@@ocaml.doc
                                                      " Discard data written on the given file descriptor but not yet\n   transmitted, or data received but not yet read, depending on the\n   second argument: [TCIFLUSH] flushes data received but not read,\n   [TCOFLUSH] flushes data written but not transmitted, and\n   [TCIOFLUSH] flushes both. "]
type flow_action = Unix.flow_action =
  | TCOOFF 
  | TCOON 
  | TCIOFF 
  | TCION 
val tcflow : file_descr -> mode:flow_action -> unit[@@ocaml.doc
                                                     " Suspend or restart reception or transmission of data on\n   the given file descriptor, depending on the second argument:\n   [TCOOFF] suspends output, [TCOON] restarts output,\n   [TCIOFF] transmits a STOP character to suspend input,\n   and [TCION] transmits a START character to restart input. "]
val setsid : unit -> int[@@ocaml.doc
                          " Put the calling process in a new session and detach it from\n   its controlling terminal. "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text
  " Interface to the Unix system.\n   To use as replacement to default {!Unix} module,\n   add [module Unix = UnixLabels] in your implementation.\n"]

[@@@ocaml.text " {1 Error report} "]

type error = Unix.error =
| E2BIG [@ocaml.doc " Argument list too long "]
| EACCES [@ocaml.doc " Permission denied "]
| EAGAIN [@ocaml.doc " Resource temporarily unavailable; try again "]
| EBADF [@ocaml.doc " Bad file descriptor "]
| EBUSY [@ocaml.doc " Resource unavailable "]
| ECHILD [@ocaml.doc " No child process "]
| EDEADLK [@ocaml.doc " Resource deadlock would occur "]
| EDOM [@ocaml.doc " Domain error for math functions, etc. "]
| EEXIST [@ocaml.doc " File exists "]
| EFAULT [@ocaml.doc " Bad address "]
| EFBIG [@ocaml.doc " File too large "]
| EINTR [@ocaml.doc " Function interrupted by signal "]
| EINVAL [@ocaml.doc " Invalid argument "]
| EIO [@ocaml.doc " Hardware I/O error "]
| EISDIR [@ocaml.doc " Is a directory "]
| EMFILE [@ocaml.doc " Too many open files by the process "]
| EMLINK [@ocaml.doc " Too many links "]
| ENAMETOOLONG [@ocaml.doc " Filename too long "]
| ENFILE [@ocaml.doc " Too many open files in the system "]
| ENODEV [@ocaml.doc " No such device "]
| ENOENT [@ocaml.doc " No such file or directory "]
| ENOEXEC [@ocaml.doc " Not an executable file "]
| ENOLCK [@ocaml.doc " No locks available "]
| ENOMEM [@ocaml.doc " Not enough memory "]
| ENOSPC [@ocaml.doc " No space left on device "]
| ENOSYS [@ocaml.doc " Function not supported "]
| ENOTDIR [@ocaml.doc " Not a directory "]
| ENOTEMPTY [@ocaml.doc " Directory not empty "]
| ENOTTY [@ocaml.doc " Inappropriate I/O control operation "]
| ENXIO [@ocaml.doc " No such device or address "]
| EPERM [@ocaml.doc " Operation not permitted "]
| EPIPE [@ocaml.doc " Broken pipe "]
| ERANGE [@ocaml.doc " Result too large "]
| EROFS [@ocaml.doc " Read-only file system "]
| ESPIPE [@ocaml.doc " Invalid seek e.g. on a pipe "]
| ESRCH [@ocaml.doc " No such process "]
| EXDEV [@ocaml.doc " Invalid link "]
| EWOULDBLOCK [@ocaml.doc " Operation would block "]
| EINPROGRESS [@ocaml.doc " Operation now in progress "]
| EALREADY [@ocaml.doc " Operation already in progress "]
| ENOTSOCK [@ocaml.doc " Socket operation on non-socket "]
| EDESTADDRREQ [@ocaml.doc " Destination address required "]
| EMSGSIZE [@ocaml.doc " Message too long "]
| EPROTOTYPE [@ocaml.doc " Protocol wrong type for socket "]
| ENOPROTOOPT [@ocaml.doc " Protocol not available "]
| EPROTONOSUPPORT [@ocaml.doc " Protocol not supported "]
| ESOCKTNOSUPPORT [@ocaml.doc " Socket type not supported "]
| EOPNOTSUPP [@ocaml.doc " Operation not supported on socket "]
| EPFNOSUPPORT [@ocaml.doc " Protocol family not supported "]
| EAFNOSUPPORT
[@ocaml.doc " Address family not supported by protocol family "]
| EADDRINUSE [@ocaml.doc " Address already in use "]
| EADDRNOTAVAIL [@ocaml.doc " Can't assign requested address "]
| ENETDOWN [@ocaml.doc " Network is down "]
| ENETUNREACH [@ocaml.doc " Network is unreachable "]
| ENETRESET [@ocaml.doc " Network dropped connection on reset "]
| ECONNABORTED [@ocaml.doc " Software caused connection abort "]
| ECONNRESET [@ocaml.doc " Connection reset by peer "]
| ENOBUFS [@ocaml.doc " No buffer space available "]
| EISCONN [@ocaml.doc " Socket is already connected "]
| ENOTCONN [@ocaml.doc " Socket is not connected "]
| ESHUTDOWN [@ocaml.doc " Can't send after socket shutdown "]
| ETOOMANYREFS [@ocaml.doc " Too many references: can't splice "]
| ETIMEDOUT [@ocaml.doc " Connection timed out "]
| ECONNREFUSED [@ocaml.doc " Connection refused "]
| EHOSTDOWN [@ocaml.doc " Host is down "]
| EHOSTUNREACH [@ocaml.doc " No route to host "]
| ELOOP [@ocaml.doc " Too many levels of symbolic links "]
| EOVERFLOW [@ocaml.doc " File size or position not representable "]
| EUNKNOWNERR of int [@ocaml.doc " Unknown error "][@@ocaml.doc
                                                     " The type of error codes.\n   Errors defined in the POSIX standard\n   and additional errors from UNIX98 and BSD.\n   All other errors are mapped to EUNKNOWNERR.\n"]
  

exception Unix_error of error * string * string
  [@ocaml.doc
    " Raised by the system calls below when an error is encountered.\n   The first component is the error code; the second component\n   is the function name; the third component is the string parameter\n   to the function, if it has one, or the empty string otherwise. "]

val error_message : error -> string[@@ocaml.doc
                                     " Return a string describing the given error code. "]


val handle_unix_error : ('a -> 'b) -> 'a -> 'b[@@ocaml.doc
                                                " [handle_unix_error f x] applies [f] to [x] and returns the result.\n   If the exception [Unix_error] is raised, it prints a message\n   describing the error and exits with code 2. "]


[@@@ocaml.text " {1 Access to the process environment} "]

val environment : unit -> string array[@@ocaml.doc
                                        " Return the process environment, as an array of strings\n    with the format ``variable=value''. "]


val getenv : string -> string[@@ocaml.doc
                               " Return the value associated to a variable in the process\n   environment. Raise [Not_found] if the variable is unbound.\n   (This function is identical to [Sys.getenv].) "]


val unsafe_getenv : string -> string[@@ocaml.doc
                                      " Return the value associated to a variable in the process\n   environment.\n\n   Unlike {!getenv}, this function returns the value even if the\n   process has special privileges. It is considered unsafe because the\n   programmer of a setuid or setgid program must be careful to avoid\n   using maliciously crafted environment variables in the search path\n   for executables, the locations for temporary files or logs, and the\n   like.\n\n   @raise Not_found if the variable is unbound.\n   @since 4.06.0  "]


val putenv : string -> string -> unit[@@ocaml.doc
                                       " [Unix.putenv name value] sets the value associated to a\n   variable in the process environment.\n   [name] is the name of the environment variable,\n   and [value] its new associated value. "]


[@@@ocaml.text " {1 Process handling} "]

type process_status = Unix.process_status =
| WEXITED of int
[@ocaml.doc
  " The process terminated normally by [exit];\n           the argument is the return code. "]
| WSIGNALED of int
[@ocaml.doc
  " The process was killed by a signal;\n           the argument is the signal number. "]
| WSTOPPED of int
[@ocaml.doc
  " The process was stopped by a signal; the argument is the\n           signal number. "]
[@@ocaml.doc
  " The termination status of a process.  See module {!Sys} for the\n    definitions of the standard signal numbers.  Note that they are\n    not the numbers used by the OS. "]
  

type wait_flag = Unix.wait_flag =
| WNOHANG
[@ocaml.doc
  " do not block if no child has\n               died yet, but immediately return with a pid equal to 0."]
| WUNTRACED
[@ocaml.doc " report also the children that receive stop signals. "][@@ocaml.doc
                                                                    " Flags for {!UnixLabels.waitpid}. "]
  

val execv : prog:string -> args:string array -> 'a[@@ocaml.doc
                                                    " [execv prog args] execute the program in file [prog], with\n   the arguments [args], and the current process environment.\n   These [execv*] functions never return: on success, the current\n   program is replaced by the new one;\n   on failure, a {!UnixLabels.Unix_error} exception is raised. "]


val execve : prog:string -> args:string array -> env:string array -> 'a
[@@ocaml.doc
  " Same as {!UnixLabels.execv}, except that the third argument provides the\n   environment to the program executed. "]


val execvp : prog:string -> args:string array -> 'a[@@ocaml.doc
                                                     " Same as {!UnixLabels.execv}, except that\n   the program is searched in the path. "]


val execvpe : prog:string -> args:string array -> env:string array -> 'a
[@@ocaml.doc
  " Same as {!UnixLabels.execve}, except that\n   the program is searched in the path. "]


val fork : unit -> int[@@ocaml.doc
                        " Fork a new process. The returned integer is 0 for the child\n   process, the pid of the child process for the parent process. "]


val wait : unit -> (int * process_status)[@@ocaml.doc
                                           " Wait until one of the children processes die, and return its pid\n   and termination status. "]


val waitpid : mode:wait_flag list -> int -> (int * process_status)[@@ocaml.doc
                                                                    " Same as {!UnixLabels.wait}, but waits for the child process whose pid\n   is given.\n   A pid of [-1] means wait for any child.\n   A pid of [0] means wait for any child in the same process group\n   as the current process.\n   Negative pid arguments represent process groups.\n   The list of options indicates whether [waitpid] should return\n   immediately without waiting, or also report stopped children. "]


val system : string -> process_status[@@ocaml.doc
                                       " Execute the given command, wait until it terminates, and return\n   its termination status. The string is interpreted by the shell\n   [/bin/sh] and therefore can contain redirections, quotes, variables,\n   etc. The result [WEXITED 127] indicates that the shell couldn't\n   be executed. "]


val getpid : unit -> int[@@ocaml.doc " Return the pid of the process. "]


val getppid : unit -> int[@@ocaml.doc
                           " Return the pid of the parent process. "]


val nice : int -> int[@@ocaml.doc
                       " Change the process priority. The integer argument is added to the\n   ``nice'' value. (Higher values of the ``nice'' value mean\n   lower priorities.) Return the new nice value. "]


[@@@ocaml.text " {1 Basic file input/output} "]

type file_descr = Unix.file_descr[@@ocaml.doc
                                   " The abstract type of file descriptors. "]
  

val stdin : file_descr[@@ocaml.doc " File descriptor for standard input."]


val stdout : file_descr[@@ocaml.doc " File descriptor for standard output."]


val stderr : file_descr[@@ocaml.doc " File descriptor for standard error. "]


type open_flag = Unix.open_flag =
| O_RDONLY [@ocaml.doc " Open for reading "]
| O_WRONLY [@ocaml.doc " Open for writing "]
| O_RDWR [@ocaml.doc " Open for reading and writing "]
| O_NONBLOCK [@ocaml.doc " Open in non-blocking mode "]
| O_APPEND [@ocaml.doc " Open for append "]
| O_CREAT [@ocaml.doc " Create if nonexistent "]
| O_TRUNC [@ocaml.doc " Truncate to 0 length if existing "]
| O_EXCL [@ocaml.doc " Fail if existing "]
| O_NOCTTY [@ocaml.doc " Don't make this dev a controlling tty "]
| O_DSYNC
[@ocaml.doc
  " Writes complete as `Synchronised I/O data\n                                    integrity completion' "]
| O_SYNC
[@ocaml.doc
  " Writes complete as `Synchronised I/O file\n                                    integrity completion' "]
| O_RSYNC
[@ocaml.doc
  " Reads complete as writes (depending\n                                    on O_SYNC/O_DSYNC) "]
| O_SHARE_DELETE
[@ocaml.doc
  " Windows only: allow the file to be deleted\n                                    while still open "]
| O_CLOEXEC
[@ocaml.doc
  " Set the close-on-exec flag on the\n                                   descriptor returned by {!openfile} "]
| O_KEEPEXEC
[@ocaml.doc
  " Clear the close-on-exec flag.\n                                    This is currently the default. "]
[@@ocaml.doc " The flags to {!UnixLabels.openfile}. "]
  

type file_perm = int[@@ocaml.doc
                      " The type of file access rights, e.g. [0o640] is read and write for user,\n    read for group, none for others "]
  

val openfile : string -> mode:open_flag list -> perm:file_perm -> file_descr
[@@ocaml.doc
  " Open the named file with the given flags. Third argument is\n   the permissions to give to the file if it is created. Return\n   a file descriptor on the named file. "]


val close : file_descr -> unit[@@ocaml.doc " Close a file descriptor. "]


val read : file_descr -> buf:bytes -> pos:int -> len:int -> int[@@ocaml.doc
                                                                 " [read fd buff ofs len] reads [len] bytes from descriptor [fd],\n    storing them in byte sequence [buff], starting at position [ofs] in\n    [buff]. Return the number of bytes actually read. "]


val write : file_descr -> buf:bytes -> pos:int -> len:int -> int[@@ocaml.doc
                                                                  " [write fd buff ofs len] writes [len] bytes to descriptor [fd],\n    taking them from byte sequence [buff], starting at position [ofs]\n    in [buff]. Return the number of bytes actually written.  [write]\n    repeats the writing operation until all bytes have been written or\n    an error occurs.  "]


val single_write : file_descr -> buf:bytes -> pos:int -> len:int -> int
[@@ocaml.doc
  " Same as [write], but attempts to write only once.\n   Thus, if an error occurs, [single_write] guarantees that no data\n   has been written. "]


val write_substring : file_descr -> buf:string -> pos:int -> len:int -> int
[@@ocaml.doc
  " Same as [write], but take the data from a string instead of a byte\n    sequence.\n    @since 4.02.0 "]


val single_write_substring :
  file_descr -> buf:string -> pos:int -> len:int -> int[@@ocaml.doc
                                                         " Same as [single_write], but take the data from a string instead of\n    a byte sequence.\n    @since 4.02.0 "]


[@@@ocaml.text " {1 Interfacing with the standard input/output library} "]

val in_channel_of_descr : file_descr -> in_channel[@@ocaml.doc
                                                    " Create an input channel reading from the given descriptor.\n   The channel is initially in binary mode; use\n   [set_binary_mode_in ic false] if text mode is desired. "]


val out_channel_of_descr : file_descr -> out_channel[@@ocaml.doc
                                                      " Create an output channel writing on the given descriptor.\n   The channel is initially in binary mode; use\n   [set_binary_mode_out oc false] if text mode is desired. "]


val descr_of_in_channel : in_channel -> file_descr[@@ocaml.doc
                                                    " Return the descriptor corresponding to an input channel. "]


val descr_of_out_channel : out_channel -> file_descr[@@ocaml.doc
                                                      " Return the descriptor corresponding to an output channel. "]


[@@@ocaml.text " {1 Seeking and truncating} "]

type seek_command = Unix.seek_command =
| SEEK_SET
[@ocaml.doc " indicates positions relative to the beginning of the file "]
| SEEK_CUR
[@ocaml.doc " indicates positions relative to the current position "]
| SEEK_END
[@ocaml.doc " indicates positions relative to the end of the file "][@@ocaml.doc
                                                                    " Positioning modes for {!UnixLabels.lseek}. "]
  

val lseek : file_descr -> int -> mode:seek_command -> int[@@ocaml.doc
                                                           " Set the current position for a file descriptor, and return the resulting\n    offset (from the beginning of the file). "]


val truncate : string -> len:int -> unit[@@ocaml.doc
                                          " Truncates the named file to the given size. "]


val ftruncate : file_descr -> len:int -> unit[@@ocaml.doc
                                               " Truncates the file corresponding to the given descriptor\n   to the given size. "]


[@@@ocaml.text " {1 File status} "]

type file_kind = Unix.file_kind =
| S_REG [@ocaml.doc " Regular file "]
| S_DIR [@ocaml.doc " Directory "]
| S_CHR [@ocaml.doc " Character device "]
| S_BLK [@ocaml.doc " Block device "]
| S_LNK [@ocaml.doc " Symbolic link "]
| S_FIFO [@ocaml.doc " Named pipe "]
| S_SOCK [@ocaml.doc " Socket "]
  

type stats = Unix.stats =
{
st_dev: int [@ocaml.doc " Device number "];
st_ino: int [@ocaml.doc " Inode number "];
st_kind: file_kind [@ocaml.doc " Kind of the file "];
st_perm: file_perm [@ocaml.doc " Access rights "];
st_nlink: int [@ocaml.doc " Number of links "];
st_uid: int [@ocaml.doc " User id of the owner "];
st_gid: int [@ocaml.doc " Group ID of the file's group "];
st_rdev: int [@ocaml.doc " Device ID (if special file) "];
st_size: int [@ocaml.doc " Size in bytes "];
st_atime: float [@ocaml.doc " Last access time "];
st_mtime: float [@ocaml.doc " Last modification time "];
st_ctime: float [@ocaml.doc " Last status change time "]}[@@ocaml.doc
                                                           " The information returned by the {!UnixLabels.stat} calls. "]
  

val stat : string -> stats[@@ocaml.doc
                            " Return the information for the named file. "]


val lstat : string -> stats[@@ocaml.doc
                             " Same as {!UnixLabels.stat}, but in case the file is a symbolic link,\n   return the information for the link itself. "]


val fstat : file_descr -> stats[@@ocaml.doc
                                 " Return the information for the file associated with the given\n   descriptor. "]


val isatty : file_descr -> bool[@@ocaml.doc
                                 " Return [true] if the given file descriptor refers to a terminal or\n   console window, [false] otherwise. "]


[@@@ocaml.text " {1 File operations on large files} "]

module LargeFile :
sig
  val lseek : file_descr -> int64 -> mode:seek_command -> int64
  
  val truncate : string -> len:int64 -> unit
  
  val ftruncate : file_descr -> len:int64 -> unit
  
  type stats = Unix.LargeFile.stats =
  {
  st_dev: int [@ocaml.doc " Device number "];
  st_ino: int [@ocaml.doc " Inode number "];
  st_kind: file_kind [@ocaml.doc " Kind of the file "];
  st_perm: file_perm [@ocaml.doc " Access rights "];
  st_nlink: int [@ocaml.doc " Number of links "];
  st_uid: int [@ocaml.doc " User id of the owner "];
  st_gid: int [@ocaml.doc " Group ID of the file's group "];
  st_rdev: int [@ocaml.doc " Device ID (if special file) "];
  st_size: int64 [@ocaml.doc " Size in bytes "];
  st_atime: float [@ocaml.doc " Last access time "];
  st_mtime: float [@ocaml.doc " Last modification time "];
  st_ctime: float [@ocaml.doc " Last status change time "]}
    
  val stat : string -> stats
  
  val lstat : string -> stats
  
  val fstat : file_descr -> stats
  
end[@@ocaml.doc
     " File operations on large files.\n  This sub-module provides 64-bit variants of the functions\n  {!UnixLabels.lseek} (for positioning a file descriptor),\n  {!UnixLabels.truncate} and {!UnixLabels.ftruncate}\n  (for changing the size of a file),\n  and {!UnixLabels.stat}, {!UnixLabels.lstat} and {!UnixLabels.fstat}\n  (for obtaining information on files).  These alternate functions represent\n  positions and sizes by 64-bit integers (type [int64]) instead of\n  regular integers (type [int]), thus allowing operating on files\n  whose sizes are greater than [max_int]. "]

[@@@ocaml.text " {1 Mapping files into memory} "]

val map_file :
  file_descr ->
    ?pos:int64 ->
      kind:('a, 'b) Stdlib.Bigarray.kind ->
        layout:'c Stdlib.Bigarray.layout ->
          shared:bool ->
            dims:int array -> ('a, 'b, 'c) Stdlib.Bigarray.Genarray.t
[@@ocaml.doc
  " Memory mapping of a file as a big array.\n  [map_file fd kind layout shared dims]\n  returns a big array of kind [kind], layout [layout],\n  and dimensions as specified in [dims].  The data contained in\n  this big array are the contents of the file referred to by\n  the file descriptor [fd] (as opened previously with\n  [Unix.openfile], for example).  The optional [pos] parameter\n  is the byte offset in the file of the data being mapped;\n  it defaults to 0 (map from the beginning of the file).\n\n  If [shared] is [true], all modifications performed on the array\n  are reflected in the file.  This requires that [fd] be opened\n  with write permissions.  If [shared] is [false], modifications\n  performed on the array are done in memory only, using\n  copy-on-write of the modified pages; the underlying file is not\n  affected.\n\n  [Genarray.map_file] is much more efficient than reading\n  the whole file in a big array, modifying that big array,\n  and writing it afterwards.\n\n  To adjust automatically the dimensions of the big array to\n  the actual size of the file, the major dimension (that is,\n  the first dimension for an array with C layout, and the last\n  dimension for an array with Fortran layout) can be given as\n  [-1].  [Genarray.map_file] then determines the major dimension\n  from the size of the file.  The file must contain an integral\n  number of sub-arrays as determined by the non-major dimensions,\n  otherwise [Failure] is raised.\n\n  If all dimensions of the big array are given, the file size is\n  matched against the size of the big array.  If the file is larger\n  than the big array, only the initial portion of the file is\n  mapped to the big array.  If the file is smaller than the big\n  array, the file is automatically grown to the size of the big array.\n  This requires write permissions on [fd].\n\n  Array accesses are bounds-checked, but the bounds are determined by\n  the initial call to [map_file]. Therefore, you should make sure no\n  other process modifies the mapped file while you're accessing it,\n  or a SIGBUS signal may be raised. This happens, for instance, if the\n  file is shrunk.\n\n  [Invalid_argument] or [Failure] may be raised in cases where argument\n  validation fails.\n  @since 4.06.0 "]


[@@@ocaml.text " {1 Operations on file names} "]

val unlink : string -> unit[@@ocaml.doc " Removes the named file "]


val rename : src:string -> dst:string -> unit[@@ocaml.doc
                                               " [rename old new] changes the name of a file from [old] to [new]. "]


val link : ?follow:bool -> src:string -> dst:string -> unit[@@ocaml.doc
                                                             " [link ?follow source dest] creates a hard link named [dest] to the file\n   named [source].\n\n   @param follow indicates whether a [source] symlink is followed or a\n   hardlink to [source] itself will be created. On {e Unix} systems this is\n   done using the [linkat(2)] function. If [?follow] is not provided, then the\n   [link(2)] function is used whose behaviour is OS-dependent, but more widely\n   available.\n\n   @raise ENOSYS On {e Unix} if [~follow:_] is requested, but linkat is\n                 unavailable.\n   @raise ENOSYS On {e Windows} if [~follow:false] is requested. "]


[@@@ocaml.text " {1 File permissions and ownership} "]

type access_permission = Unix.access_permission =
| R_OK [@ocaml.doc " Read permission "]
| W_OK [@ocaml.doc " Write permission "]
| X_OK [@ocaml.doc " Execution permission "]
| F_OK [@ocaml.doc " File exists "][@@ocaml.doc
                                     " Flags for the {!UnixLabels.access} call. "]
  

val chmod : string -> perm:file_perm -> unit[@@ocaml.doc
                                              " Change the permissions of the named file. "]


val fchmod : file_descr -> perm:file_perm -> unit[@@ocaml.doc
                                                   " Change the permissions of an opened file. "]


val chown : string -> uid:int -> gid:int -> unit[@@ocaml.doc
                                                  " Change the owner uid and owner gid of the named file. "]


val fchown : file_descr -> uid:int -> gid:int -> unit[@@ocaml.doc
                                                       " Change the owner uid and owner gid of an opened file. "]


val umask : int -> int[@@ocaml.doc
                        " Set the process's file mode creation mask, and return the previous\n    mask. "]


val access : string -> perm:access_permission list -> unit[@@ocaml.doc
                                                            " Check that the process has the given permissions over the named\n   file. Raise [Unix_error] otherwise. "]


[@@@ocaml.text " {1 Operations on file descriptors} "]

val dup : ?cloexec:bool -> file_descr -> file_descr[@@ocaml.doc
                                                     " Return a new file descriptor referencing the same file as\n   the given descriptor. "]


val dup2 : ?cloexec:bool -> src:file_descr -> dst:file_descr -> unit[@@ocaml.doc
                                                                    " [dup2 fd1 fd2] duplicates [fd1] to [fd2], closing [fd2] if already\n   opened. "]


val set_nonblock : file_descr -> unit[@@ocaml.doc
                                       " Set the ``non-blocking'' flag on the given descriptor.\n   When the non-blocking flag is set, reading on a descriptor\n   on which there is temporarily no data available raises the\n   [EAGAIN] or [EWOULDBLOCK] error instead of blocking;\n   writing on a descriptor on which there is temporarily no room\n   for writing also raises [EAGAIN] or [EWOULDBLOCK]. "]


val clear_nonblock : file_descr -> unit[@@ocaml.doc
                                         " Clear the ``non-blocking'' flag on the given descriptor.\n   See {!UnixLabels.set_nonblock}."]


val set_close_on_exec : file_descr -> unit[@@ocaml.doc
                                            " Set the ``close-on-exec'' flag on the given descriptor.\n   A descriptor with the close-on-exec flag is automatically\n   closed when the current process starts another program with\n   one of the [exec] functions. "]


val clear_close_on_exec : file_descr -> unit[@@ocaml.doc
                                              " Clear the ``close-on-exec'' flag on the given descriptor.\n   See {!UnixLabels.set_close_on_exec}."]


[@@@ocaml.text " {1 Directories} "]

val mkdir : string -> perm:file_perm -> unit[@@ocaml.doc
                                              " Create a directory with the given permissions. "]


val rmdir : string -> unit[@@ocaml.doc " Remove an empty directory. "]


val chdir : string -> unit[@@ocaml.doc
                            " Change the process working directory. "]


val getcwd : unit -> string[@@ocaml.doc
                             " Return the name of the current working directory. "]


val chroot : string -> unit[@@ocaml.doc
                             " Change the process root directory. "]


type dir_handle = Unix.dir_handle[@@ocaml.doc
                                   " The type of descriptors over opened directories. "]
  

val opendir : string -> dir_handle[@@ocaml.doc
                                    " Open a descriptor on a directory "]


val readdir : dir_handle -> string[@@ocaml.doc
                                    " Return the next entry in a directory.\n   @raise End_of_file when the end of the directory has been reached. "]


val rewinddir : dir_handle -> unit[@@ocaml.doc
                                    " Reposition the descriptor to the beginning of the directory "]


val closedir : dir_handle -> unit[@@ocaml.doc
                                   " Close a directory descriptor. "]


[@@@ocaml.text " {1 Pipes and redirections} "]

val pipe : ?cloexec:bool -> unit -> (file_descr * file_descr)[@@ocaml.doc
                                                               " Create a pipe. The first component of the result is opened\n   for reading, that's the exit to the pipe. The second component is\n   opened for writing, that's the entrance to the pipe. "]


val mkfifo : string -> perm:file_perm -> unit[@@ocaml.doc
                                               " Create a named pipe with the given permissions. "]


[@@@ocaml.text " {1 High-level process and redirection management} "]

val create_process :
  prog:string ->
    args:string array ->
      stdin:file_descr -> stdout:file_descr -> stderr:file_descr -> int
[@@ocaml.doc
  " [create_process prog args new_stdin new_stdout new_stderr]\n   forks a new process that executes the program\n   in file [prog], with arguments [args]. The pid of the new\n   process is returned immediately; the new process executes\n   concurrently with the current process.\n   The standard input and outputs of the new process are connected\n   to the descriptors [new_stdin], [new_stdout] and [new_stderr].\n   Passing e.g. [stdout] for [new_stdout] prevents the redirection\n   and causes the new process to have the same standard output\n   as the current process.\n   The executable file [prog] is searched in the path.\n   The new process has the same environment as the current process. "]


val create_process_env :
  prog:string ->
    args:string array ->
      env:string array ->
        stdin:file_descr -> stdout:file_descr -> stderr:file_descr -> int
[@@ocaml.doc
  " [create_process_env prog args env new_stdin new_stdout new_stderr]\n   works as {!UnixLabels.create_process}, except that the extra argument\n   [env] specifies the environment passed to the program. "]


val open_process_in : string -> in_channel[@@ocaml.doc
                                            " High-level pipe and process management. This function\n   runs the given command in parallel with the program.\n   The standard output of the command is redirected to a pipe,\n   which can be read via the returned input channel.\n   The command is interpreted by the shell [/bin/sh] (cf. [system]). "]


val open_process_out : string -> out_channel[@@ocaml.doc
                                              " Same as {!UnixLabels.open_process_in}, but redirect the standard input of\n   the command to a pipe.  Data written to the returned output channel\n   is sent to the standard input of the command.\n   Warning: writes on output channels are buffered, hence be careful\n   to call {!Stdlib.flush} at the right times to ensure\n   correct synchronization. "]


val open_process : string -> (in_channel * out_channel)[@@ocaml.doc
                                                         " Same as {!UnixLabels.open_process_out}, but redirects both the standard\n   input and standard output of the command to pipes connected to the two\n   returned channels.  The input channel is connected to the output\n   of the command, and the output channel to the input of the command. "]


val open_process_full :
  string -> env:string array -> (in_channel * out_channel * in_channel)
[@@ocaml.doc
  " Similar to {!UnixLabels.open_process}, but the second argument specifies\n   the environment passed to the command.  The result is a triple\n   of channels connected respectively to the standard output, standard input,\n   and standard error of the command. "]


val open_process_args_in : string -> string array -> in_channel[@@ocaml.doc
                                                                 " High-level pipe and process management. The first argument specifies the\n   command to run, and the second argument specifies the argument array passed\n   to the command.  This function runs the command in parallel with the program.\n   The standard output of the command is redirected to a pipe, which can be read\n   via the returned input channel.\n\n    @since 4.08.0 "]


val open_process_args_out : string -> string array -> out_channel[@@ocaml.doc
                                                                   " Same as {!Unix.open_process_args_in}, but redirect the standard input of the\n   command to a pipe.  Data written to the returned output channel is sent to\n   the standard input of the command.  Warning: writes on output channels are\n   buffered, hence be careful to call {!Stdlib.flush} at the right times to\n   ensure correct synchronization.\n\n    @since 4.08.0 "]


val open_process_args : string -> string array -> (in_channel * out_channel)
[@@ocaml.doc
  " Same as {!Unix.open_process_args_out}, but redirects both the standard input\n   and standard output of the command to pipes connected to the two returned\n   channels.  The input channel is connected to the output of the command, and\n   the output channel to the input of the command.\n\n    @since 4.08.0 "]


val open_process_args_full :
  string ->
    string array -> string array -> (in_channel * out_channel * in_channel)
[@@ocaml.doc
  " Similar to {!Unix.open_process_args}, but the third argument specifies the\n   environment passed to the command.  The result is a triple of channels\n   connected respectively to the standard output, standard input, and standard\n   error of the command.\n\n    @since 4.08.0 "]


val close_process_in : in_channel -> process_status[@@ocaml.doc
                                                     " Close channels opened by {!UnixLabels.open_process_in},\n   wait for the associated command to terminate,\n   and return its termination status. "]


val close_process_out : out_channel -> process_status[@@ocaml.doc
                                                       " Close channels opened by {!UnixLabels.open_process_out},\n   wait for the associated command to terminate,\n   and return its termination status. "]


val close_process : (in_channel * out_channel) -> process_status[@@ocaml.doc
                                                                  " Close channels opened by {!UnixLabels.open_process},\n   wait for the associated command to terminate,\n   and return its termination status. "]


val close_process_full :
  (in_channel * out_channel * in_channel) -> process_status[@@ocaml.doc
                                                             " Close channels opened by {!UnixLabels.open_process_full},\n   wait for the associated command to terminate,\n   and return its termination status. "]


[@@@ocaml.text " {1 Symbolic links} "]

val symlink : ?to_dir:bool -> src:string -> dst:string -> unit[@@ocaml.doc
                                                                " [symlink source dest] creates the file [dest] as a symbolic link\n   to the file [source]. See {!Unix.symlink} for details of [~to_dir] "]


val has_symlink : unit -> bool[@@ocaml.doc
                                " Returns [true] if the user is able to create symbolic links. On Windows,\n   this indicates that the user not only has the SeCreateSymbolicLinkPrivilege\n   but is also running elevated, if necessary. On other platforms, this is\n   simply indicates that the symlink system call is available.\n   @since 4.03.0 "]


val readlink : string -> string[@@ocaml.doc " Read the contents of a link. "]


[@@@ocaml.text " {1 Polling} "]

val select :
  read:file_descr list ->
    write:file_descr list ->
      except:file_descr list ->
        timeout:float ->
          (file_descr list * file_descr list * file_descr list)[@@ocaml.doc
                                                                 " Wait until some input/output operations become possible on\n   some channels. The three list arguments are, respectively, a set\n   of descriptors to check for reading (first argument), for writing\n   (second argument), or for exceptional conditions (third argument).\n   The fourth argument is the maximal timeout, in seconds; a\n   negative fourth argument means no timeout (unbounded wait).\n   The result is composed of three sets of descriptors: those ready\n   for reading (first component), ready for writing (second component),\n   and over which an exceptional condition is pending (third\n   component). "]


[@@@ocaml.text " {1 Locking} "]

type lock_command = Unix.lock_command =
| F_ULOCK [@ocaml.doc " Unlock a region "]
| F_LOCK
[@ocaml.doc " Lock a region for writing, and block if already locked "]
| F_TLOCK
[@ocaml.doc " Lock a region for writing, or fail if already locked "]
| F_TEST [@ocaml.doc " Test a region for other process locks "]
| F_RLOCK
[@ocaml.doc " Lock a region for reading, and block if already locked "]
| F_TRLOCK
[@ocaml.doc " Lock a region for reading, or fail if already locked "]
[@@ocaml.doc " Commands for {!UnixLabels.lockf}. "]
  

val lockf : file_descr -> mode:lock_command -> len:int -> unit[@@ocaml.doc
                                                                " [lockf fd cmd size] puts a lock on a region of the file opened\n   as [fd]. The region starts at the current read/write position for\n   [fd] (as set by {!UnixLabels.lseek}), and extends [size] bytes forward if\n   [size] is positive, [size] bytes backwards if [size] is negative,\n   or to the end of the file if [size] is zero.\n   A write lock prevents any other\n   process from acquiring a read or write lock on the region.\n   A read lock prevents any other\n   process from acquiring a write lock on the region, but lets\n   other processes acquire read locks on it.\n\n   The [F_LOCK] and [F_TLOCK] commands attempts to put a write lock\n   on the specified region.\n   The [F_RLOCK] and [F_TRLOCK] commands attempts to put a read lock\n   on the specified region.\n   If one or several locks put by another process prevent the current process\n   from acquiring the lock, [F_LOCK] and [F_RLOCK] block until these locks\n   are removed, while [F_TLOCK] and [F_TRLOCK] fail immediately with an\n   exception.\n   The [F_ULOCK] removes whatever locks the current process has on\n   the specified region.\n   Finally, the [F_TEST] command tests whether a write lock can be\n   acquired on the specified region, without actually putting a lock.\n   It returns immediately if successful, or fails otherwise. "]


[@@@ocaml.text
  " {1 Signals}\n   Note: installation of signal handlers is performed via\n   the functions {!Sys.signal} and {!Sys.set_signal}.\n"]

val kill : pid:int -> signal:int -> unit[@@ocaml.doc
                                          " [kill pid sig] sends signal number [sig] to the process\n   with id [pid]. "]


type sigprocmask_command = Unix.sigprocmask_command =
| SIG_SETMASK 
| SIG_BLOCK 
| SIG_UNBLOCK 
  

val sigprocmask : mode:sigprocmask_command -> int list -> int list[@@ocaml.doc
                                                                    " [sigprocmask cmd sigs] changes the set of blocked signals.\n   If [cmd] is [SIG_SETMASK], blocked signals are set to those in\n   the list [sigs].\n   If [cmd] is [SIG_BLOCK], the signals in [sigs] are added to\n   the set of blocked signals.\n   If [cmd] is [SIG_UNBLOCK], the signals in [sigs] are removed\n   from the set of blocked signals.\n   [sigprocmask] returns the set of previously blocked signals. "]


val sigpending : unit -> int list[@@ocaml.doc
                                   " Return the set of blocked signals that are currently pending. "]


val sigsuspend : int list -> unit[@@ocaml.doc
                                   " [sigsuspend sigs] atomically sets the blocked signals to [sigs]\n   and waits for a non-ignored, non-blocked signal to be delivered.\n   On return, the blocked signals are reset to their initial value. "]


val pause : unit -> unit[@@ocaml.doc
                          " Wait until a non-ignored, non-blocked signal is delivered. "]


[@@@ocaml.text " {1 Time functions} "]

type process_times = Unix.process_times =
{
tms_utime: float [@ocaml.doc " User time for the process "];
tms_stime: float [@ocaml.doc " System time for the process "];
tms_cutime: float [@ocaml.doc " User time for the children processes "];
tms_cstime: float [@ocaml.doc " System time for the children processes "]}
[@@ocaml.doc " The execution times (CPU times) of a process. "]
  

type tm = Unix.tm =
{
tm_sec: int [@ocaml.doc " Seconds 0..60 "];
tm_min: int [@ocaml.doc " Minutes 0..59 "];
tm_hour: int [@ocaml.doc " Hours 0..23 "];
tm_mday: int [@ocaml.doc " Day of month 1..31 "];
tm_mon: int [@ocaml.doc " Month of year 0..11 "];
tm_year: int [@ocaml.doc " Year - 1900 "];
tm_wday: int [@ocaml.doc " Day of week (Sunday is 0) "];
tm_yday: int [@ocaml.doc " Day of year 0..365 "];
tm_isdst: bool [@ocaml.doc " Daylight time savings in effect "]}[@@ocaml.doc
                                                                  " The type representing wallclock time and calendar date. "]
  

val time : unit -> float[@@ocaml.doc
                          " Return the current time since 00:00:00 GMT, Jan. 1, 1970,\n   in seconds. "]


val gettimeofday : unit -> float[@@ocaml.doc
                                  " Same as {!UnixLabels.time}, but with resolution better than 1 second. "]


val gmtime : float -> tm[@@ocaml.doc
                          " Convert a time in seconds, as returned by {!UnixLabels.time}, into a date\n   and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. "]


val localtime : float -> tm[@@ocaml.doc
                             " Convert a time in seconds, as returned by {!UnixLabels.time}, into a date\n   and a time. Assumes the local time zone. "]


val mktime : tm -> (float * tm)[@@ocaml.doc
                                 " Convert a date and time, specified by the [tm] argument, into\n   a time in seconds, as returned by {!UnixLabels.time}.  The [tm_isdst],\n   [tm_wday] and [tm_yday] fields of [tm] are ignored.  Also return a\n   normalized copy of the given [tm] record, with the [tm_wday],\n   [tm_yday], and [tm_isdst] fields recomputed from the other fields,\n   and the other fields normalized (so that, e.g., 40 October is\n   changed into 9 November).  The [tm] argument is interpreted in the\n   local time zone. "]


val alarm : int -> int[@@ocaml.doc
                        " Schedule a [SIGALRM] signal after the given number of seconds. "]


val sleep : int -> unit[@@ocaml.doc
                         " Stop execution for the given number of seconds. "]


val times : unit -> process_times[@@ocaml.doc
                                   " Return the execution times of the process. "]


val utimes : string -> access:float -> modif:float -> unit[@@ocaml.doc
                                                            " Set the last access time (second arg) and last modification time\n   (third arg) for a file. Times are expressed in seconds from\n   00:00:00 GMT, Jan. 1, 1970.  A time of [0.0] is interpreted as the\n   current time. "]


type interval_timer = Unix.interval_timer =
| ITIMER_REAL
[@ocaml.doc
  " decrements in real time, and sends the signal [SIGALRM] when\n          expired."]
| ITIMER_VIRTUAL
[@ocaml.doc
  " decrements in process virtual time, and sends [SIGVTALRM] when\n          expired. "]
| ITIMER_PROF
[@ocaml.doc
  " (for profiling) decrements both when the process\n         is running and when the system is running on behalf of the\n         process; it sends [SIGPROF] when expired. "]
[@@ocaml.doc " The three kinds of interval timers. "]
  

type interval_timer_status = Unix.interval_timer_status =
{
it_interval: float [@ocaml.doc " Period "];
it_value: float [@ocaml.doc " Current value of the timer "]}[@@ocaml.doc
                                                              " The type describing the status of an interval timer "]
  

val getitimer : interval_timer -> interval_timer_status[@@ocaml.doc
                                                         " Return the current status of the given interval timer. "]


val setitimer :
  interval_timer -> interval_timer_status -> interval_timer_status[@@ocaml.doc
                                                                    " [setitimer t s] sets the interval timer [t] and returns\n   its previous status. The [s] argument is interpreted as follows:\n   [s.it_value], if nonzero, is the time to the next timer expiration;\n   [s.it_interval], if nonzero, specifies a value to\n   be used in reloading it_value when the timer expires.\n   Setting [s.it_value] to zero disable the timer.\n   Setting [s.it_interval] to zero causes the timer to be disabled\n   after its next expiration. "]


[@@@ocaml.text " {1 User id, group id} "]

val getuid : unit -> int[@@ocaml.doc
                          " Return the user id of the user executing the process. "]


val geteuid : unit -> int[@@ocaml.doc
                           " Return the effective user id under which the process runs. "]


val setuid : int -> unit[@@ocaml.doc
                          " Set the real user id and effective user id for the process. "]


val getgid : unit -> int[@@ocaml.doc
                          " Return the group id of the user executing the process. "]


val getegid : unit -> int[@@ocaml.doc
                           " Return the effective group id under which the process runs. "]


val setgid : int -> unit[@@ocaml.doc
                          " Set the real group id and effective group id for the process. "]


val getgroups : unit -> int array[@@ocaml.doc
                                   " Return the list of groups to which the user executing the process\n   belongs. "]


val setgroups : int array -> unit[@@ocaml.doc
                                   " [setgroups groups] sets the supplementary group IDs for the\n      calling process. Appropriate privileges are required. "]


val initgroups : string -> int -> unit[@@ocaml.doc
                                        " [initgroups user group] initializes the group access list by\n      reading the group database /etc/group and using all groups of\n      which [user] is a member. The additional group [group] is also\n      added to the list. "]


type passwd_entry = Unix.passwd_entry =
{
pw_name: string ;
pw_passwd: string ;
pw_uid: int ;
pw_gid: int ;
pw_gecos: string ;
pw_dir: string ;
pw_shell: string }[@@ocaml.doc
                    " Structure of entries in the [passwd] database. "]
  

type group_entry = Unix.group_entry =
{
gr_name: string ;
gr_passwd: string ;
gr_gid: int ;
gr_mem: string array }[@@ocaml.doc
                        " Structure of entries in the [groups] database. "]
  

val getlogin : unit -> string[@@ocaml.doc
                               " Return the login name of the user executing the process. "]


val getpwnam : string -> passwd_entry[@@ocaml.doc
                                       " Find an entry in [passwd] with the given name, or raise\n   [Not_found] if the matching entry is not found. "]


val getgrnam : string -> group_entry[@@ocaml.doc
                                      " Find an entry in [group] with the given name, or raise\n   [Not_found] if the matching entry is not found. "]


val getpwuid : int -> passwd_entry[@@ocaml.doc
                                    " Find an entry in [passwd] with the given user id, or raise\n   [Not_found] if the matching entry is not found. "]


val getgrgid : int -> group_entry[@@ocaml.doc
                                   " Find an entry in [group] with the given group id, or raise\n   [Not_found] if the matching entry is not found. "]


[@@@ocaml.text " {1 Internet addresses} "]

type inet_addr = Unix.inet_addr[@@ocaml.doc
                                 " The abstract type of Internet addresses. "]
  

val inet_addr_of_string : string -> inet_addr[@@ocaml.doc
                                               " Conversion from the printable representation of an Internet\n    address to its internal representation.  The argument string\n    consists of 4 numbers separated by periods ([XXX.YYY.ZZZ.TTT])\n    for IPv4 addresses, and up to 8 numbers separated by colons\n    for IPv6 addresses.  Raise [Failure] when given a string that\n    does not match these formats. "]


val string_of_inet_addr : inet_addr -> string[@@ocaml.doc
                                               " Return the printable representation of the given Internet address.\n    See {!Unix.inet_addr_of_string} for a description of the\n    printable representation. "]


val inet_addr_any : inet_addr[@@ocaml.doc
                               " A special IPv4 address, for use only with [bind], representing\n   all the Internet addresses that the host machine possesses. "]


val inet_addr_loopback : inet_addr[@@ocaml.doc
                                    " A special IPv4 address representing the host machine ([127.0.0.1]). "]


val inet6_addr_any : inet_addr[@@ocaml.doc
                                " A special IPv6 address, for use only with [bind], representing\n   all the Internet addresses that the host machine possesses. "]


val inet6_addr_loopback : inet_addr[@@ocaml.doc
                                     " A special IPv6 address representing the host machine ([::1]). "]


[@@@ocaml.text " {1 Sockets} "]

type socket_domain = Unix.socket_domain =
| PF_UNIX [@ocaml.doc " Unix domain "]
| PF_INET [@ocaml.doc " Internet domain (IPv4) "]
| PF_INET6 [@ocaml.doc " Internet domain (IPv6) "][@@ocaml.doc
                                                    " The type of socket domains.  Not all platforms support\n    IPv6 sockets (type [PF_INET6]). "]
  

type socket_type = Unix.socket_type =
| SOCK_STREAM [@ocaml.doc " Stream socket "]
| SOCK_DGRAM [@ocaml.doc " Datagram socket "]
| SOCK_RAW [@ocaml.doc " Raw socket "]
| SOCK_SEQPACKET [@ocaml.doc " Sequenced packets socket "][@@ocaml.doc
                                                            " The type of socket kinds, specifying the semantics of\n   communications. "]
  

type sockaddr = Unix.sockaddr =
| ADDR_UNIX of string 
| ADDR_INET of inet_addr * int
[@ocaml.doc
  " The type of socket addresses. [ADDR_UNIX name] is a socket\n   address in the Unix domain; [name] is a file name in the file\n   system. [ADDR_INET(addr,port)] is a socket address in the Internet\n   domain; [addr] is the Internet address of the machine, and\n   [port] is the port number. "]
  

val socket :
  ?cloexec:bool ->
    domain:socket_domain -> kind:socket_type -> protocol:int -> file_descr
[@@ocaml.doc
  " Create a new socket in the given domain, and with the\n   given kind. The third argument is the protocol type; 0 selects\n   the default protocol for that kind of sockets. "]


val domain_of_sockaddr : sockaddr -> socket_domain[@@ocaml.doc
                                                    " Return the socket domain adequate for the given socket address. "]


val socketpair :
  ?cloexec:bool ->
    domain:socket_domain ->
      kind:socket_type -> protocol:int -> (file_descr * file_descr)[@@ocaml.doc
                                                                    " Create a pair of unnamed sockets, connected together. "]


val accept : ?cloexec:bool -> file_descr -> (file_descr * sockaddr)[@@ocaml.doc
                                                                    " Accept connections on the given socket. The returned descriptor\n   is a socket connected to the client; the returned address is\n   the address of the connecting client. "]


val bind : file_descr -> addr:sockaddr -> unit[@@ocaml.doc
                                                " Bind a socket to an address. "]


val connect : file_descr -> addr:sockaddr -> unit[@@ocaml.doc
                                                   " Connect a socket to an address. "]


val listen : file_descr -> max:int -> unit[@@ocaml.doc
                                            " Set up a socket for receiving connection requests. The integer\n   argument is the maximal number of pending requests. "]


type shutdown_command = Unix.shutdown_command =
| SHUTDOWN_RECEIVE [@ocaml.doc " Close for receiving "]
| SHUTDOWN_SEND [@ocaml.doc " Close for sending "]
| SHUTDOWN_ALL [@ocaml.doc " Close both "][@@ocaml.doc
                                            " The type of commands for [shutdown]. "]
  

val shutdown : file_descr -> mode:shutdown_command -> unit[@@ocaml.doc
                                                            " Shutdown a socket connection. [SHUTDOWN_SEND] as second argument\n   causes reads on the other end of the connection to return\n   an end-of-file condition.\n   [SHUTDOWN_RECEIVE] causes writes on the other end of the connection\n   to return a closed pipe condition ([SIGPIPE] signal). "]


val getsockname : file_descr -> sockaddr[@@ocaml.doc
                                          " Return the address of the given socket. "]


val getpeername : file_descr -> sockaddr[@@ocaml.doc
                                          " Return the address of the host connected to the given socket. "]


type msg_flag = Unix.msg_flag =
| MSG_OOB 
| MSG_DONTROUTE 
| MSG_PEEK
[@ocaml.doc
  " The flags for {!UnixLabels.recv},  {!UnixLabels.recvfrom},\n   {!UnixLabels.send} and {!UnixLabels.sendto}. "]
  

val recv :
  file_descr -> buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc " Receive data from a connected socket. "]


val recvfrom :
  file_descr ->
    buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> (int * sockaddr)
[@@ocaml.doc " Receive data from an unconnected socket. "]


val send :
  file_descr -> buf:bytes -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc " Send data over a connected socket. "]


val send_substring :
  file_descr -> buf:string -> pos:int -> len:int -> mode:msg_flag list -> int
[@@ocaml.doc
  " Same as [send], but take the data from a string instead of a byte\n    sequence.\n    @since 4.02.0 "]


val sendto :
  file_descr ->
    buf:bytes ->
      pos:int -> len:int -> mode:msg_flag list -> addr:sockaddr -> int
[@@ocaml.doc " Send data over an unconnected socket. "]


val sendto_substring :
  file_descr ->
    buf:string -> pos:int -> len:int -> mode:msg_flag list -> sockaddr -> int
[@@ocaml.doc
  " Same as [sendto], but take the data from a string instead of a\n    byte sequence.\n    @since 4.02.0 "]


[@@@ocaml.text " {1 Socket options} "]

type socket_bool_option =
| SO_DEBUG [@ocaml.doc " Record debugging information "]
| SO_BROADCAST [@ocaml.doc " Permit sending of broadcast messages "]
| SO_REUSEADDR [@ocaml.doc " Allow reuse of local addresses for bind "]
| SO_KEEPALIVE [@ocaml.doc " Keep connection active "]
| SO_DONTROUTE [@ocaml.doc " Bypass the standard routing algorithms "]
| SO_OOBINLINE [@ocaml.doc " Leave out-of-band data in line "]
| SO_ACCEPTCONN [@ocaml.doc " Report whether socket listening is enabled "]
| TCP_NODELAY [@ocaml.doc " Control the Nagle algorithm for TCP sockets "]
| IPV6_ONLY [@ocaml.doc " Forbid binding an IPv6 socket to an IPv4 address "]
[@@ocaml.doc
  " The socket options that can be consulted with {!UnixLabels.getsockopt}\n   and modified with {!UnixLabels.setsockopt}.  These options have a boolean\n   ([true]/[false]) value. "]
  

type socket_int_option =
| SO_SNDBUF [@ocaml.doc " Size of send buffer "]
| SO_RCVBUF [@ocaml.doc " Size of received buffer "]
| SO_ERROR
[@ocaml.doc " Deprecated.  Use {!Unix.getsockopt_error} instead. "]
| SO_TYPE [@ocaml.doc " Report the socket type "]
| SO_RCVLOWAT
[@ocaml.doc " Minimum number of bytes to process for input operations "]
| SO_SNDLOWAT
[@ocaml.doc " Minimum number of bytes to process for output operations "]
[@@ocaml.doc
  " The socket options that can be consulted with {!UnixLabels.getsockopt_int}\n   and modified with {!UnixLabels.setsockopt_int}.  These options have an\n   integer value. "]
  

type socket_optint_option =
| SO_LINGER
[@ocaml.doc
  " Whether to linger on closed connections\n                    that have data present, and for how long\n                    (in seconds) "]
[@@ocaml.doc
  " The socket options that can be consulted with {!Unix.getsockopt_optint}\n   and modified with {!Unix.setsockopt_optint}.  These options have a\n   value of type [int option], with [None] meaning ``disabled''. "]
  

type socket_float_option =
| SO_RCVTIMEO [@ocaml.doc " Timeout for input operations "]
| SO_SNDTIMEO [@ocaml.doc " Timeout for output operations "][@@ocaml.doc
                                                              " The socket options that can be consulted with {!UnixLabels.getsockopt_float}\n   and modified with {!UnixLabels.setsockopt_float}.  These options have a\n   floating-point value representing a time in seconds.\n   The value 0 means infinite timeout. "]
  

val getsockopt : file_descr -> socket_bool_option -> bool[@@ocaml.doc
                                                           " Return the current status of a boolean-valued option\n   in the given socket. "]


val setsockopt : file_descr -> socket_bool_option -> bool -> unit[@@ocaml.doc
                                                                   " Set or clear a boolean-valued option in the given socket. "]


val getsockopt_int : file_descr -> socket_int_option -> int[@@ocaml.doc
                                                             " Same as {!Unix.getsockopt} for an integer-valued socket option. "]


val setsockopt_int : file_descr -> socket_int_option -> int -> unit[@@ocaml.doc
                                                                    " Same as {!Unix.setsockopt} for an integer-valued socket option. "]


val getsockopt_optint : file_descr -> socket_optint_option -> int option
[@@ocaml.doc
  " Same as {!Unix.getsockopt} for a socket option whose value is\n    an [int option]. "]


val setsockopt_optint :
  file_descr -> socket_optint_option -> int option -> unit[@@ocaml.doc
                                                            " Same as {!Unix.setsockopt} for a socket option whose value is\n    an [int option]. "]


val getsockopt_float : file_descr -> socket_float_option -> float[@@ocaml.doc
                                                                   " Same as {!Unix.getsockopt} for a socket option whose value is a\n    floating-point number. "]


val setsockopt_float : file_descr -> socket_float_option -> float -> unit
[@@ocaml.doc
  " Same as {!Unix.setsockopt} for a socket option whose value is a\n    floating-point number. "]


val getsockopt_error : file_descr -> error option[@@ocaml.doc
                                                   " Return the error condition associated with the given socket,\n    and clear it. "]


[@@@ocaml.text " {1 High-level network connection functions} "]

val open_connection : sockaddr -> (in_channel * out_channel)[@@ocaml.doc
                                                              " Connect to a server at the given address.\n   Return a pair of buffered channels connected to the server.\n   Remember to call {!Stdlib.flush} on the output channel at the right\n   times to ensure correct synchronization. "]


val shutdown_connection : in_channel -> unit[@@ocaml.doc
                                              " ``Shut down'' a connection established with {!UnixLabels.open_connection};\n   that is, transmit an end-of-file condition to the server reading\n   on the other side of the connection. "]


val establish_server :
  (in_channel -> out_channel -> unit) -> addr:sockaddr -> unit[@@ocaml.doc
                                                                " Establish a server on the given address.\n   The function given as first argument is called for each connection\n   with two buffered channels connected to the client. A new process\n   is created for each connection. The function {!UnixLabels.establish_server}\n   never returns normally. "]


[@@@ocaml.text " {1 Host and protocol databases} "]

type host_entry = Unix.host_entry =
{
h_name: string ;
h_aliases: string array ;
h_addrtype: socket_domain ;
h_addr_list: inet_addr array }[@@ocaml.doc
                                " Structure of entries in the [hosts] database. "]
  

type protocol_entry = Unix.protocol_entry =
{
p_name: string ;
p_aliases: string array ;
p_proto: int }[@@ocaml.doc
                " Structure of entries in the [protocols] database. "]
  

type service_entry = Unix.service_entry =
{
s_name: string ;
s_aliases: string array ;
s_port: int ;
s_proto: string }[@@ocaml.doc
                   " Structure of entries in the [services] database. "]
  

val gethostname : unit -> string[@@ocaml.doc
                                  " Return the name of the local host. "]


val gethostbyname : string -> host_entry[@@ocaml.doc
                                          " Find an entry in [hosts] with the given name, or raise\n   [Not_found]. "]


val gethostbyaddr : inet_addr -> host_entry[@@ocaml.doc
                                             " Find an entry in [hosts] with the given address, or raise\n   [Not_found]. "]


val getprotobyname : string -> protocol_entry[@@ocaml.doc
                                               " Find an entry in [protocols] with the given name, or raise\n   [Not_found]. "]


val getprotobynumber : int -> protocol_entry[@@ocaml.doc
                                              " Find an entry in [protocols] with the given protocol number,\n   or raise [Not_found]. "]


val getservbyname : string -> protocol:string -> service_entry[@@ocaml.doc
                                                                " Find an entry in [services] with the given name, or raise\n   [Not_found]. "]


val getservbyport : int -> protocol:string -> service_entry[@@ocaml.doc
                                                             " Find an entry in [services] with the given service number,\n   or raise [Not_found]. "]


type addr_info =
{
ai_family: socket_domain [@ocaml.doc " Socket domain "];
ai_socktype: socket_type [@ocaml.doc " Socket type "];
ai_protocol: int [@ocaml.doc " Socket protocol number "];
ai_addr: sockaddr [@ocaml.doc " Address "];
ai_canonname: string [@ocaml.doc " Canonical host name  "]}[@@ocaml.doc
                                                             " Address information returned by {!Unix.getaddrinfo}. "]
  

type getaddrinfo_option =
| AI_FAMILY of socket_domain [@ocaml.doc " Impose the given socket domain "]
| AI_SOCKTYPE of socket_type [@ocaml.doc " Impose the given socket type "]
| AI_PROTOCOL of int [@ocaml.doc " Impose the given protocol  "]
| AI_NUMERICHOST
[@ocaml.doc
  " Do not call name resolver,\n                                            expect numeric IP address "]
| AI_CANONNAME
[@ocaml.doc
  " Fill the [ai_canonname] field\n                                            of the result "]
| AI_PASSIVE
[@ocaml.doc
  " Set address to ``any'' address\n                                            for use with {!Unix.bind} "]
[@@ocaml.doc " Options to {!Unix.getaddrinfo}. "]
  

val getaddrinfo :
  string -> string -> getaddrinfo_option list -> addr_info list[@@ocaml.doc
                                                                 " [getaddrinfo host service opts] returns a list of {!Unix.addr_info}\n    records describing socket parameters and addresses suitable for\n    communicating with the given host and service.  The empty list is\n    returned if the host or service names are unknown, or the constraints\n    expressed in [opts] cannot be satisfied.\n\n    [host] is either a host name or the string representation of an IP\n    address.  [host] can be given as the empty string; in this case,\n    the ``any'' address or the ``loopback'' address are used,\n    depending whether [opts] contains [AI_PASSIVE].\n    [service] is either a service name or the string representation of\n    a port number.  [service] can be given as the empty string;\n    in this case, the port field of the returned addresses is set to 0.\n    [opts] is a possibly empty list of options that allows the caller\n    to force a particular socket domain (e.g. IPv6 only or IPv4 only)\n    or a particular socket type (e.g. TCP only or UDP only). "]


type name_info =
{
ni_hostname: string [@ocaml.doc " Name or IP address of host "];
ni_service: string [@ocaml.doc " Name of service or port number "]}[@@ocaml.doc
                                                                    " Host and service information returned by {!Unix.getnameinfo}. "]
  

type getnameinfo_option =
| NI_NOFQDN [@ocaml.doc " Do not qualify local host names "]
| NI_NUMERICHOST [@ocaml.doc " Always return host as IP address "]
| NI_NAMEREQD [@ocaml.doc " Fail if host name cannot be determined "]
| NI_NUMERICSERV [@ocaml.doc " Always return service as port number "]
| NI_DGRAM
[@ocaml.doc
  " Consider the service as UDP-based\n                             instead of the default TCP "]
[@@ocaml.doc " Options to {!Unix.getnameinfo}. "]
  

val getnameinfo : sockaddr -> getnameinfo_option list -> name_info[@@ocaml.doc
                                                                    " [getnameinfo addr opts] returns the host name and service name\n    corresponding to the socket address [addr].  [opts] is a possibly\n    empty list of options that governs how these names are obtained.\n    Raise [Not_found] if an error occurs. "]


[@@@ocaml.text " {1 Terminal interface} "]

[@@@ocaml.text
  " The following functions implement the POSIX standard terminal\n   interface. They provide control over asynchronous communication ports\n   and pseudo-terminals. Refer to the [termios] man page for a\n   complete description. "]

type terminal_io = Unix.terminal_io =
{
mutable c_ignbrk: bool [@ocaml.doc " Ignore the break condition. "];
mutable c_brkint: bool [@ocaml.doc " Signal interrupt on break condition. "];
mutable c_ignpar: bool [@ocaml.doc " Ignore characters with parity errors. "];
mutable c_parmrk: bool [@ocaml.doc " Mark parity errors. "];
mutable c_inpck: bool [@ocaml.doc " Enable parity check on input. "];
mutable c_istrip: bool [@ocaml.doc " Strip 8th bit on input characters. "];
mutable c_inlcr: bool [@ocaml.doc " Map NL to CR on input. "];
mutable c_igncr: bool [@ocaml.doc " Ignore CR on input. "];
mutable c_icrnl: bool [@ocaml.doc " Map CR to NL on input. "];
mutable c_ixon: bool [@ocaml.doc " Recognize XON/XOFF characters on input. "];
mutable c_ixoff: bool
  [@ocaml.doc " Emit XON/XOFF chars to control input flow. "];
mutable c_opost: bool [@ocaml.doc " Enable output processing. "];
mutable c_obaud: int
  [@ocaml.doc " Output baud rate (0 means close connection)."];
mutable c_ibaud: int [@ocaml.doc " Input baud rate. "];
mutable c_csize: int [@ocaml.doc " Number of bits per character (5-8). "];
mutable c_cstopb: int [@ocaml.doc " Number of stop bits (1-2). "];
mutable c_cread: bool [@ocaml.doc " Reception is enabled. "];
mutable c_parenb: bool
  [@ocaml.doc " Enable parity generation and detection. "];
mutable c_parodd: bool [@ocaml.doc " Specify odd parity instead of even. "];
mutable c_hupcl: bool [@ocaml.doc " Hang up on last close. "];
mutable c_clocal: bool [@ocaml.doc " Ignore modem status lines. "];
mutable c_isig: bool [@ocaml.doc " Generate signal on INTR, QUIT, SUSP. "];
mutable c_icanon: bool
  [@ocaml.doc
    " Enable canonical processing\n                                 (line buffering and editing) "];
mutable c_noflsh: bool [@ocaml.doc " Disable flush after INTR, QUIT, SUSP. "];
mutable c_echo: bool [@ocaml.doc " Echo input characters. "];
mutable c_echoe: bool
  [@ocaml.doc " Echo ERASE (to erase previous character). "];
mutable c_echok: bool [@ocaml.doc " Echo KILL (to erase the current line). "];
mutable c_echonl: bool [@ocaml.doc " Echo NL even if c_echo is not set. "];
mutable c_vintr: char [@ocaml.doc " Interrupt character (usually ctrl-C). "];
mutable c_vquit: char [@ocaml.doc " Quit character (usually ctrl-\\). "];
mutable c_verase: char
  [@ocaml.doc " Erase character (usually DEL or ctrl-H). "];
mutable c_vkill: char [@ocaml.doc " Kill line character (usually ctrl-U). "];
mutable c_veof: char [@ocaml.doc " End-of-file character (usually ctrl-D). "];
mutable c_veol: char
  [@ocaml.doc " Alternate end-of-line char. (usually none). "];
mutable c_vmin: int
  [@ocaml.doc
    " Minimum number of characters to read\n                                 before the read request is satisfied. "];
mutable c_vtime: int [@ocaml.doc " Maximum read wait (in 0.1s units). "];
mutable c_vstart: char [@ocaml.doc " Start character (usually ctrl-Q). "];
mutable c_vstop: char [@ocaml.doc " Stop character (usually ctrl-S). "]}
  

val tcgetattr : file_descr -> terminal_io[@@ocaml.doc
                                           " Return the status of the terminal referred to by the given\n   file descriptor. "]


type setattr_when = Unix.setattr_when =
| TCSANOW 
| TCSADRAIN 
| TCSAFLUSH 
  

val tcsetattr : file_descr -> mode:setattr_when -> terminal_io -> unit
[@@ocaml.doc
  " Set the status of the terminal referred to by the given\n   file descriptor. The second argument indicates when the\n   status change takes place: immediately ([TCSANOW]),\n   when all pending output has been transmitted ([TCSADRAIN]),\n   or after flushing all input that has been received but not\n   read ([TCSAFLUSH]). [TCSADRAIN] is recommended when changing\n   the output parameters; [TCSAFLUSH], when changing the input\n   parameters. "]


val tcsendbreak : file_descr -> duration:int -> unit[@@ocaml.doc
                                                      " Send a break condition on the given file descriptor.\n   The second argument is the duration of the break, in 0.1s units;\n   0 means standard duration (0.25s). "]


val tcdrain : file_descr -> unit[@@ocaml.doc
                                  " Waits until all output written on the given file descriptor\n   has been transmitted. "]


type flush_queue = Unix.flush_queue =
| TCIFLUSH 
| TCOFLUSH 
| TCIOFLUSH 
  

val tcflush : file_descr -> mode:flush_queue -> unit[@@ocaml.doc
                                                      " Discard data written on the given file descriptor but not yet\n   transmitted, or data received but not yet read, depending on the\n   second argument: [TCIFLUSH] flushes data received but not read,\n   [TCOFLUSH] flushes data written but not transmitted, and\n   [TCIOFLUSH] flushes both. "]


type flow_action = Unix.flow_action =
| TCOOFF 
| TCOON 
| TCIOFF 
| TCION 
  

val tcflow : file_descr -> mode:flow_action -> unit[@@ocaml.doc
                                                     " Suspend or restart reception or transmission of data on\n   the given file descriptor, depending on the second argument:\n   [TCOOFF] suspends output, [TCOON] restarts output,\n   [TCIOFF] transmits a STOP character to suspend input,\n   and [TCION] transmits a START character to restart input. "]


val setsid : unit -> int[@@ocaml.doc
                          " Put the calling process in a new session and detach it from\n   its controlling terminal. "]

File "./unix.mli", line 477, characters 18-23:
Error: Symbol int64 not found
