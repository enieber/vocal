
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.warning "+a-4-9-30-40-41-42"]
val lift :
  backend:(module Backend_intf.S) -> Flambda.program -> Flambda.program
[@@ocaml.doc
  " Lift toplevel [Let]-expressions to Flambda [program] constructions such\n    that the results of evaluation of such expressions may be accessed\n    directly, through symbols, rather than through closures.  The\n    [Let]-expressions typically come from the compilation of modules (using\n    the bytecode strategy) in [Translmod].\n\n    This means of compilation supersedes the old \"transl_store_\" methodology\n    for native code.\n\n    An [Initialize_symbol] construction generated by this pass may be\n    subsequently rewritten to [Let_symbol] if it is discovered that the\n    initializer is in fact constant.  (See [Initialize_symbol_to_let_symbol].)\n\n    The [program] constructions generated by this pass will be joined by\n    others that arise from the lifting of constants (see [Lift_constants]).\n"]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.warning "+a-4-9-30-40-41-42"]

val lift :
  backend:(module Backend_intf.S) -> Flambda.program -> Flambda.program
[@@ocaml.doc
  " Lift toplevel [Let]-expressions to Flambda [program] constructions such\n    that the results of evaluation of such expressions may be accessed\n    directly, through symbols, rather than through closures.  The\n    [Let]-expressions typically come from the compilation of modules (using\n    the bytecode strategy) in [Translmod].\n\n    This means of compilation supersedes the old \"transl_store_\" methodology\n    for native code.\n\n    An [Initialize_symbol] construction generated by this pass may be\n    subsequently rewritten to [Let_symbol] if it is discovered that the\n    initializer is in fact constant.  (See [Initialize_symbol_to_let_symbol].)\n\n    The [program] constructions generated by this pass will be joined by\n    others that arise from the lifting of constants (see [Lift_constants]).\n"]


*******************************
********* Typed GOSPEL ********
*******************************
module lift_let_to_initialize_symbol.mli

  Namespace: lift_let_to_initialize_symbol.mli
    Type symbols
      
    Logic Symbols
      
    Exception Symbols
      
    Namespaces
      
    Type Namespaces
      
  Signatures
    (*@ open Gospelstdlib *)
    
    [@@@ocaml.warning "+a-4-9-30-40-41-42"]
    
    val lift :
    backend:(module Backend_intf.S) -> Flambda.program -> Flambda.program
    [@@ocaml.doc
      " Lift toplevel [Let]-expressions to Flambda [program] constructions such\n    that the results of evaluation of such expressions may be accessed\n    directly, through symbols, rather than through closures.  The\n    [Let]-expressions typically come from the compilation of modules (using\n    the bytecode strategy) in [Translmod].\n\n    This means of compilation supersedes the old \"transl_store_\" methodology\n    for native code.\n\n    An [Initialize_symbol] construction generated by this pass may be\n    subsequently rewritten to [Let_symbol] if it is discovered that the\n    initializer is in fact constant.  (See [Initialize_symbol_to_let_symbol].)\n\n    The [program] constructions generated by this pass will be joined by\n    others that arise from the lifting of constants (see [Lift_constants]).\n"]
    


*** OK ***

