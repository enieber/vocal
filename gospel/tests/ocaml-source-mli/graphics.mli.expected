
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text " Machine-independent graphics primitives. "]
exception Graphic_failure of string
  [@ocaml.doc
    " Raised by the functions below when they encounter an error. "]
[@@@ocaml.text " {1 Initializations} "]
val open_graph : string -> unit[@@ocaml.doc
                                 " Show the graphics window or switch the screen to graphic mode.\n   The graphics window is cleared and the current point is set\n   to (0, 0). The string argument is used to pass optional\n   information on the desired graphics mode, the graphics window\n   size, and so on. Its interpretation is implementation-dependent.\n   If the empty string is given, a sensible default is selected. "]
val close_graph : unit -> unit[@@ocaml.doc
                                " Delete the graphics window or switch the screen back to text mode. "]
val set_window_title : string -> unit[@@ocaml.doc
                                       " Set the title of the graphics window. "]
val resize_window : int -> int -> unit[@@ocaml.doc
                                        " Resize and erase the graphics window. "]
external clear_graph : unit -> unit = "caml_gr_clear_graph"[@@ocaml.doc
                                                             " Erase the graphics window. "]
external size_x : unit -> int = "caml_gr_size_x"[@@ocaml.doc
                                                  " See {!Graphics.size_y}. "]
external size_y : unit -> int = "caml_gr_size_y"[@@ocaml.doc
                                                  " Return the size of the graphics window. Coordinates of the screen\n   pixels range over [0 .. size_x()-1] and [0 .. size_y()-1].\n   Drawings outside of this rectangle are clipped, without causing\n   an error. The origin (0,0) is at the lower left corner.\n   Some implementation (e.g. X Windows) represent coordinates by\n   16-bit integers, hence wrong clipping may occur with coordinates\n   below [-32768] or above [32676]. "]
[@@@ocaml.text " {1 Colors} "]
type color = int[@@ocaml.doc
                  " A color is specified by its R, G, B components. Each component\n   is in the range [0..255]. The three components are packed in\n   an [int]: [0xRRGGBB], where [RR] are the two hexadecimal digits for\n   the red component, [GG] for the green component, [BB] for the\n   blue component. "]
val rgb : int -> int -> int -> color[@@ocaml.doc
                                      " [rgb r g b] returns the integer encoding the color with red\n   component [r], green component [g], and blue component [b].\n   [r], [g] and [b] are in the range [0..255]. "]
external set_color : color -> unit = "caml_gr_set_color"[@@ocaml.doc
                                                          " Set the current drawing color. "]
val background : color[@@ocaml.doc " See {!Graphics.foreground}."]
val foreground : color[@@ocaml.doc
                        " Default background and foreground colors (usually, either black\n   foreground on a white background or white foreground on a\n   black background).\n   {!Graphics.clear_graph} fills the screen with the [background] color.\n   The initial drawing color is [foreground]. "]
[@@@ocaml.text " {7 Some predefined colors} "]
val black : color
val white : color
val red : color
val green : color
val blue : color
val yellow : color
val cyan : color
val magenta : color
[@@@ocaml.text " {1 Point and line drawing} "]
external plot : int -> int -> unit = "caml_gr_plot"[@@ocaml.doc
                                                     " Plot the given point with the current drawing color. "]
val plots : (int * int) array -> unit[@@ocaml.doc
                                       " Plot the given points with the current drawing color. "]
external point_color : int -> int -> color = "caml_gr_point_color"[@@ocaml.doc
                                                                    " Return the color of the given point in the backing store\n   (see \"Double buffering\" below). "]
external moveto : int -> int -> unit = "caml_gr_moveto"[@@ocaml.doc
                                                         " Position the current point. "]
val rmoveto : int -> int -> unit[@@ocaml.doc
                                  " [rmoveto dx dy] translates the current point by the given vector. "]
external current_x : unit -> int = "caml_gr_current_x"[@@ocaml.doc
                                                        " Return the abscissa of the current point. "]
external current_y : unit -> int = "caml_gr_current_y"[@@ocaml.doc
                                                        " Return the ordinate of the current point. "]
val current_point : unit -> (int * int)[@@ocaml.doc
                                         " Return the position of the current point. "]
external lineto : int -> int -> unit = "caml_gr_lineto"[@@ocaml.doc
                                                         " Draw a line with endpoints the current point and the given point,\n   and move the current point to the given point. "]
val rlineto : int -> int -> unit[@@ocaml.doc
                                  " Draw a line with endpoints the current point and the\n   current point translated of the given vector,\n   and move the current point to this point. "]
val curveto : (int * int) -> (int * int) -> (int * int) -> unit[@@ocaml.doc
                                                                 " [curveto b c d] draws a cubic Bezier curve starting from\n   the current point to point [d], with control points [b] and\n   [c], and moves the current point to [d]. "]
val draw_rect : int -> int -> int -> int -> unit[@@ocaml.doc
                                                  " [draw_rect x y w h] draws the rectangle with lower left corner\n   at [x,y], width [w] and height [h].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]
val draw_poly_line : (int * int) array -> unit[@@ocaml.doc
                                                " [draw_poly_line points] draws the line that joins the\n   points given by the array argument.\n   The array contains the coordinates of the vertices of the\n   polygonal line, which need not be closed.\n   The current point is unchanged. "]
val draw_poly : (int * int) array -> unit[@@ocaml.doc
                                           " [draw_poly polygon] draws the given polygon.\n   The array contains the coordinates of the vertices of the\n   polygon.\n   The current point is unchanged. "]
val draw_segments : (int * int * int * int) array -> unit[@@ocaml.doc
                                                           " [draw_segments segments] draws the segments given in the array\n   argument. Each segment is specified as a quadruple\n   [(x0, y0, x1, y1)] where [(x0, y0)] and [(x1, y1)] are\n   the coordinates of the end points of the segment.\n   The current point is unchanged. "]
val draw_arc : int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                               " [draw_arc x y rx ry a1 a2] draws an elliptical arc with center\n   [x,y], horizontal radius [rx], vertical radius [ry], from angle\n   [a1] to angle [a2] (in degrees). The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]
val draw_ellipse : int -> int -> int -> int -> unit[@@ocaml.doc
                                                     " [draw_ellipse x y rx ry] draws an ellipse with center\n   [x,y], horizontal radius [rx] and vertical radius [ry].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]
val draw_circle : int -> int -> int -> unit[@@ocaml.doc
                                             " [draw_circle x y r] draws a circle with center [x,y] and\n   radius [r]. The current point is unchanged.\n   Raise [Invalid_argument] if [r] is negative. "]
val set_line_width : int -> unit[@@ocaml.doc
                                  " Set the width of points and lines drawn with the functions above.\n   Under X Windows, [set_line_width 0] selects a width of 1 pixel\n   and a faster, but less precise drawing algorithm than the one\n   used when [set_line_width 1] is specified.\n   Raise [Invalid_argument] if the argument is negative. "]
[@@@ocaml.text " {1 Text drawing} "]
external draw_char : char -> unit = "caml_gr_draw_char"[@@ocaml.doc
                                                         " See {!Graphics.draw_string}."]
external draw_string : string -> unit = "caml_gr_draw_string"[@@ocaml.doc
                                                               " Draw a character or a character string with lower left corner\n   at current position. After drawing, the current position is set\n   to the lower right corner of the text drawn. "]
external set_font : string -> unit = "caml_gr_set_font"[@@ocaml.doc
                                                         " Set the font used for drawing text.\n   The interpretation of the argument to [set_font]\n   is implementation-dependent. "]
val set_text_size : int -> unit[@@ocaml.doc
                                 " Set the character size used for drawing text.\n   The interpretation of the argument to [set_text_size]\n   is implementation-dependent. "]
external text_size : string -> (int * int) = "caml_gr_text_size"[@@ocaml.doc
                                                                  " Return the dimensions of the given text, if it were drawn with\n   the current font and size. "]
[@@@ocaml.text " {1 Filling} "]
val fill_rect : int -> int -> int -> int -> unit[@@ocaml.doc
                                                  " [fill_rect x y w h] fills the rectangle with lower left corner\n   at [x,y], width [w] and height [h], with the current color.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]
external fill_poly : (int * int) array -> unit = "caml_gr_fill_poly"[@@ocaml.doc
                                                                    " Fill the given polygon with the current color. The array\n   contains the coordinates of the vertices of the polygon. "]
val fill_arc : int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                               " Fill an elliptical pie slice with the current color. The\n   parameters are the same as for {!Graphics.draw_arc}. "]
val fill_ellipse : int -> int -> int -> int -> unit[@@ocaml.doc
                                                     " Fill an ellipse with the current color. The\n   parameters are the same as for {!Graphics.draw_ellipse}. "]
val fill_circle : int -> int -> int -> unit[@@ocaml.doc
                                             " Fill a circle with the current color. The\n   parameters are the same as for {!Graphics.draw_circle}. "]
[@@@ocaml.text " {1 Images} "]
type image[@@ocaml.doc
            " The abstract type for images, in internal representation.\n   Externally, images are represented as matrices of colors. "]
val transp : color[@@ocaml.doc
                    " In matrices of colors, this color represent a 'transparent'\n   point: when drawing the corresponding image, all pixels on the\n   screen corresponding to a transparent pixel in the image will\n   not be modified, while other points will be set to the color\n   of the corresponding point in the image. This allows superimposing\n   an image over an existing background. "]
external make_image : color array array -> image = "caml_gr_make_image"
[@@ocaml.doc
  " Convert the given color matrix to an image.\n   Each sub-array represents one horizontal line. All sub-arrays\n   must have the same length; otherwise, exception [Graphic_failure]\n   is raised. "]
external dump_image : image -> color array array = "caml_gr_dump_image"
[@@ocaml.doc " Convert an image to a color matrix. "]
external draw_image : image -> int -> int -> unit = "caml_gr_draw_image"
[@@ocaml.doc
  " Draw the given image with lower left corner at the given point. "]
val get_image : int -> int -> int -> int -> image[@@ocaml.doc
                                                   " Capture the contents of a rectangle on the screen as an image.\n   The parameters are the same as for {!Graphics.fill_rect}. "]
external create_image : int -> int -> image = "caml_gr_create_image"[@@ocaml.doc
                                                                    " [create_image w h] returns a new image [w] pixels wide and [h]\n   pixels tall, to be used in conjunction with [blit_image].\n   The initial image contents are random, except that no point\n   is transparent. "]
external blit_image : image -> int -> int -> unit = "caml_gr_blit_image"
[@@ocaml.doc
  " [blit_image img x y] copies screen pixels into the image [img],\n   modifying [img] in-place. The pixels copied are those inside the\n   rectangle with lower left corner at [x,y], and width and height\n   equal to those of the image. Pixels that were transparent in\n   [img] are left unchanged. "]
[@@@ocaml.text " {1 Mouse and keyboard events} "]
type status =
  {
  mouse_x: int [@ocaml.doc " X coordinate of the mouse "];
  mouse_y: int [@ocaml.doc " Y coordinate of the mouse "];
  button: bool [@ocaml.doc " true if a mouse button is pressed "];
  keypressed: bool [@ocaml.doc " true if a key has been pressed "];
  key: char [@ocaml.doc " the character for the key pressed "]}[@@ocaml.doc
                                                                 " To report events. "]
type event =
  | Button_down [@ocaml.doc " A mouse button is pressed "]
  | Button_up [@ocaml.doc " A mouse button is released "]
  | Key_pressed [@ocaml.doc " A key is pressed "]
  | Mouse_motion [@ocaml.doc " The mouse is moved "]
  | Poll [@ocaml.doc " Don't wait; return immediately "][@@ocaml.doc
                                                          " To specify events to wait for. "]
external wait_next_event : event list -> status = "caml_gr_wait_event"
[@@ocaml.doc
  " Wait until one of the events specified in the given event list\n   occurs, and return the status of the mouse and keyboard at\n   that time. If [Poll] is given in the event list, return immediately\n   with the current status. If the mouse cursor is outside of the\n   graphics window, the [mouse_x] and [mouse_y] fields of the event are\n   outside the range [0..size_x()-1, 0..size_y()-1]. Keypresses\n   are queued, and dequeued one by one when the [Key_pressed]\n   event is specified and the [Poll] event is not specified. "]
val loop_at_exit : event list -> (status -> unit) -> unit[@@ocaml.doc
                                                           " Loop before exiting the program, the list given as argument is the\n    list of handlers and the events on which these handlers are called.\n    To exit cleanly the loop, the handler should raise Exit. Any other\n    exception will be propagated outside of the loop.\n    @since 4.01\n"]
[@@@ocaml.text " {1 Mouse and keyboard polling} "]
val mouse_pos : unit -> (int * int)[@@ocaml.doc
                                     " Return the position of the mouse cursor, relative to the\n   graphics window. If the mouse cursor is outside of the graphics\n   window, [mouse_pos()] returns a point outside of the range\n   [0..size_x()-1, 0..size_y()-1]. "]
val button_down : unit -> bool[@@ocaml.doc
                                " Return [true] if the mouse button is pressed, [false] otherwise. "]
val read_key : unit -> char[@@ocaml.doc
                             " Wait for a key to be pressed, and return the corresponding\n   character. Keypresses are queued. "]
val key_pressed : unit -> bool[@@ocaml.doc
                                " Return [true] if a keypress is available; that is, if [read_key]\n   would not block. "]
[@@@ocaml.text " {1 Sound} "]
external sound : int -> int -> unit = "caml_gr_sound"[@@ocaml.doc
                                                       " [sound freq dur] plays a sound at frequency [freq] (in hertz)\n   for a duration [dur] (in milliseconds). "]
[@@@ocaml.text " {1 Double buffering} "]
val auto_synchronize : bool -> unit[@@ocaml.doc
                                     " By default, drawing takes place both on the window displayed\n   on screen, and in a memory area (the 'backing store').\n   The backing store image is used to re-paint the on-screen\n   window when necessary.\n\n   To avoid flicker during animations, it is possible to turn\n   off on-screen drawing, perform a number of drawing operations\n   in the backing store only, then refresh the on-screen window\n   explicitly.\n\n   [auto_synchronize false] turns on-screen drawing off.  All\n   subsequent drawing commands are performed on the backing store\n   only.\n\n   [auto_synchronize true] refreshes the on-screen window from\n   the backing store (as per [synchronize]), then turns on-screen\n   drawing back on.  All subsequent drawing commands are performed\n   both on screen and in the backing store.\n\n   The default drawing mode corresponds to [auto_synchronize true]. "]
external synchronize : unit -> unit = "caml_gr_synchronize"[@@ocaml.doc
                                                             " Synchronize the backing store and the on-screen window, by\n   copying the contents of the backing store onto the graphics\n   window. "]
external display_mode : bool -> unit = "caml_gr_display_mode"[@@ocaml.doc
                                                               " Set display mode on or off. When turned on, drawings are done\n   in the graphics window; when turned off, drawings do not affect\n   the graphics window.  This occurs independently of\n   drawing into the backing store (see the function {!Graphics.remember_mode}\n   below). Default display mode is on. "]
external remember_mode : bool -> unit = "caml_gr_remember_mode"[@@ocaml.doc
                                                                 " Set remember mode on or off. When turned on, drawings are done\n   in the backing store; when turned off, the backing store is\n   unaffected by drawings.  This occurs independently of drawing\n   onto the graphics window (see the function {!Graphics.display_mode} above).\n   Default remember mode is on.  "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text " Machine-independent graphics primitives. "]

exception Graphic_failure of string
  [@ocaml.doc
    " Raised by the functions below when they encounter an error. "]

[@@@ocaml.text " {1 Initializations} "]

val open_graph : string -> unit[@@ocaml.doc
                                 " Show the graphics window or switch the screen to graphic mode.\n   The graphics window is cleared and the current point is set\n   to (0, 0). The string argument is used to pass optional\n   information on the desired graphics mode, the graphics window\n   size, and so on. Its interpretation is implementation-dependent.\n   If the empty string is given, a sensible default is selected. "]


val close_graph : unit -> unit[@@ocaml.doc
                                " Delete the graphics window or switch the screen back to text mode. "]


val set_window_title : string -> unit[@@ocaml.doc
                                       " Set the title of the graphics window. "]


val resize_window : int -> int -> unit[@@ocaml.doc
                                        " Resize and erase the graphics window. "]


external clear_graph : unit -> unit = "caml_gr_clear_graph"[@@ocaml.doc
                                                             " Erase the graphics window. "]


external size_x : unit -> int = "caml_gr_size_x"[@@ocaml.doc
                                                  " See {!Graphics.size_y}. "]


external size_y : unit -> int = "caml_gr_size_y"[@@ocaml.doc
                                                  " Return the size of the graphics window. Coordinates of the screen\n   pixels range over [0 .. size_x()-1] and [0 .. size_y()-1].\n   Drawings outside of this rectangle are clipped, without causing\n   an error. The origin (0,0) is at the lower left corner.\n   Some implementation (e.g. X Windows) represent coordinates by\n   16-bit integers, hence wrong clipping may occur with coordinates\n   below [-32768] or above [32676]. "]


[@@@ocaml.text " {1 Colors} "]

type color = int[@@ocaml.doc
                  " A color is specified by its R, G, B components. Each component\n   is in the range [0..255]. The three components are packed in\n   an [int]: [0xRRGGBB], where [RR] are the two hexadecimal digits for\n   the red component, [GG] for the green component, [BB] for the\n   blue component. "]
  

val rgb : int -> int -> int -> color[@@ocaml.doc
                                      " [rgb r g b] returns the integer encoding the color with red\n   component [r], green component [g], and blue component [b].\n   [r], [g] and [b] are in the range [0..255]. "]


external set_color : color -> unit = "caml_gr_set_color"[@@ocaml.doc
                                                          " Set the current drawing color. "]


val background : color[@@ocaml.doc " See {!Graphics.foreground}."]


val foreground : color[@@ocaml.doc
                        " Default background and foreground colors (usually, either black\n   foreground on a white background or white foreground on a\n   black background).\n   {!Graphics.clear_graph} fills the screen with the [background] color.\n   The initial drawing color is [foreground]. "]


[@@@ocaml.text " {7 Some predefined colors} "]

val black : color


val white : color


val red : color


val green : color


val blue : color


val yellow : color


val cyan : color


val magenta : color


[@@@ocaml.text " {1 Point and line drawing} "]

external plot : int -> int -> unit = "caml_gr_plot"[@@ocaml.doc
                                                     " Plot the given point with the current drawing color. "]


val plots : (int * int) array -> unit[@@ocaml.doc
                                       " Plot the given points with the current drawing color. "]


external point_color : int -> int -> color = "caml_gr_point_color"[@@ocaml.doc
                                                                    " Return the color of the given point in the backing store\n   (see \"Double buffering\" below). "]


external moveto : int -> int -> unit = "caml_gr_moveto"[@@ocaml.doc
                                                         " Position the current point. "]


val rmoveto : int -> int -> unit[@@ocaml.doc
                                  " [rmoveto dx dy] translates the current point by the given vector. "]


external current_x : unit -> int = "caml_gr_current_x"[@@ocaml.doc
                                                        " Return the abscissa of the current point. "]


external current_y : unit -> int = "caml_gr_current_y"[@@ocaml.doc
                                                        " Return the ordinate of the current point. "]


val current_point : unit -> (int * int)[@@ocaml.doc
                                         " Return the position of the current point. "]


external lineto : int -> int -> unit = "caml_gr_lineto"[@@ocaml.doc
                                                         " Draw a line with endpoints the current point and the given point,\n   and move the current point to the given point. "]


val rlineto : int -> int -> unit[@@ocaml.doc
                                  " Draw a line with endpoints the current point and the\n   current point translated of the given vector,\n   and move the current point to this point. "]


val curveto : (int * int) -> (int * int) -> (int * int) -> unit[@@ocaml.doc
                                                                 " [curveto b c d] draws a cubic Bezier curve starting from\n   the current point to point [d], with control points [b] and\n   [c], and moves the current point to [d]. "]


val draw_rect : int -> int -> int -> int -> unit[@@ocaml.doc
                                                  " [draw_rect x y w h] draws the rectangle with lower left corner\n   at [x,y], width [w] and height [h].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]


val draw_poly_line : (int * int) array -> unit[@@ocaml.doc
                                                " [draw_poly_line points] draws the line that joins the\n   points given by the array argument.\n   The array contains the coordinates of the vertices of the\n   polygonal line, which need not be closed.\n   The current point is unchanged. "]


val draw_poly : (int * int) array -> unit[@@ocaml.doc
                                           " [draw_poly polygon] draws the given polygon.\n   The array contains the coordinates of the vertices of the\n   polygon.\n   The current point is unchanged. "]


val draw_segments : (int * int * int * int) array -> unit[@@ocaml.doc
                                                           " [draw_segments segments] draws the segments given in the array\n   argument. Each segment is specified as a quadruple\n   [(x0, y0, x1, y1)] where [(x0, y0)] and [(x1, y1)] are\n   the coordinates of the end points of the segment.\n   The current point is unchanged. "]


val draw_arc : int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                               " [draw_arc x y rx ry a1 a2] draws an elliptical arc with center\n   [x,y], horizontal radius [rx], vertical radius [ry], from angle\n   [a1] to angle [a2] (in degrees). The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]


val draw_ellipse : int -> int -> int -> int -> unit[@@ocaml.doc
                                                     " [draw_ellipse x y rx ry] draws an ellipse with center\n   [x,y], horizontal radius [rx] and vertical radius [ry].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]


val draw_circle : int -> int -> int -> unit[@@ocaml.doc
                                             " [draw_circle x y r] draws a circle with center [x,y] and\n   radius [r]. The current point is unchanged.\n   Raise [Invalid_argument] if [r] is negative. "]


val set_line_width : int -> unit[@@ocaml.doc
                                  " Set the width of points and lines drawn with the functions above.\n   Under X Windows, [set_line_width 0] selects a width of 1 pixel\n   and a faster, but less precise drawing algorithm than the one\n   used when [set_line_width 1] is specified.\n   Raise [Invalid_argument] if the argument is negative. "]


[@@@ocaml.text " {1 Text drawing} "]

external draw_char : char -> unit = "caml_gr_draw_char"[@@ocaml.doc
                                                         " See {!Graphics.draw_string}."]


external draw_string : string -> unit = "caml_gr_draw_string"[@@ocaml.doc
                                                               " Draw a character or a character string with lower left corner\n   at current position. After drawing, the current position is set\n   to the lower right corner of the text drawn. "]


external set_font : string -> unit = "caml_gr_set_font"[@@ocaml.doc
                                                         " Set the font used for drawing text.\n   The interpretation of the argument to [set_font]\n   is implementation-dependent. "]


val set_text_size : int -> unit[@@ocaml.doc
                                 " Set the character size used for drawing text.\n   The interpretation of the argument to [set_text_size]\n   is implementation-dependent. "]


external text_size : string -> (int * int) = "caml_gr_text_size"[@@ocaml.doc
                                                                  " Return the dimensions of the given text, if it were drawn with\n   the current font and size. "]


[@@@ocaml.text " {1 Filling} "]

val fill_rect : int -> int -> int -> int -> unit[@@ocaml.doc
                                                  " [fill_rect x y w h] fills the rectangle with lower left corner\n   at [x,y], width [w] and height [h], with the current color.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]


external fill_poly : (int * int) array -> unit = "caml_gr_fill_poly"[@@ocaml.doc
                                                                    " Fill the given polygon with the current color. The array\n   contains the coordinates of the vertices of the polygon. "]


val fill_arc : int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                               " Fill an elliptical pie slice with the current color. The\n   parameters are the same as for {!Graphics.draw_arc}. "]


val fill_ellipse : int -> int -> int -> int -> unit[@@ocaml.doc
                                                     " Fill an ellipse with the current color. The\n   parameters are the same as for {!Graphics.draw_ellipse}. "]


val fill_circle : int -> int -> int -> unit[@@ocaml.doc
                                             " Fill a circle with the current color. The\n   parameters are the same as for {!Graphics.draw_circle}. "]


[@@@ocaml.text " {1 Images} "]

type image[@@ocaml.doc
            " The abstract type for images, in internal representation.\n   Externally, images are represented as matrices of colors. "]
  

val transp : color[@@ocaml.doc
                    " In matrices of colors, this color represent a 'transparent'\n   point: when drawing the corresponding image, all pixels on the\n   screen corresponding to a transparent pixel in the image will\n   not be modified, while other points will be set to the color\n   of the corresponding point in the image. This allows superimposing\n   an image over an existing background. "]


external make_image : color array array -> image = "caml_gr_make_image"
[@@ocaml.doc
  " Convert the given color matrix to an image.\n   Each sub-array represents one horizontal line. All sub-arrays\n   must have the same length; otherwise, exception [Graphic_failure]\n   is raised. "]


external dump_image : image -> color array array = "caml_gr_dump_image"
[@@ocaml.doc " Convert an image to a color matrix. "]


external draw_image : image -> int -> int -> unit = "caml_gr_draw_image"
[@@ocaml.doc
  " Draw the given image with lower left corner at the given point. "]


val get_image : int -> int -> int -> int -> image[@@ocaml.doc
                                                   " Capture the contents of a rectangle on the screen as an image.\n   The parameters are the same as for {!Graphics.fill_rect}. "]


external create_image : int -> int -> image = "caml_gr_create_image"[@@ocaml.doc
                                                                    " [create_image w h] returns a new image [w] pixels wide and [h]\n   pixels tall, to be used in conjunction with [blit_image].\n   The initial image contents are random, except that no point\n   is transparent. "]


external blit_image : image -> int -> int -> unit = "caml_gr_blit_image"
[@@ocaml.doc
  " [blit_image img x y] copies screen pixels into the image [img],\n   modifying [img] in-place. The pixels copied are those inside the\n   rectangle with lower left corner at [x,y], and width and height\n   equal to those of the image. Pixels that were transparent in\n   [img] are left unchanged. "]


[@@@ocaml.text " {1 Mouse and keyboard events} "]

type status =
{
mouse_x: int [@ocaml.doc " X coordinate of the mouse "];
mouse_y: int [@ocaml.doc " Y coordinate of the mouse "];
button: bool [@ocaml.doc " true if a mouse button is pressed "];
keypressed: bool [@ocaml.doc " true if a key has been pressed "];
key: char [@ocaml.doc " the character for the key pressed "]}[@@ocaml.doc
                                                               " To report events. "]
  

type event =
| Button_down [@ocaml.doc " A mouse button is pressed "]
| Button_up [@ocaml.doc " A mouse button is released "]
| Key_pressed [@ocaml.doc " A key is pressed "]
| Mouse_motion [@ocaml.doc " The mouse is moved "]
| Poll [@ocaml.doc " Don't wait; return immediately "][@@ocaml.doc
                                                        " To specify events to wait for. "]
  

external wait_next_event : event list -> status = "caml_gr_wait_event"
[@@ocaml.doc
  " Wait until one of the events specified in the given event list\n   occurs, and return the status of the mouse and keyboard at\n   that time. If [Poll] is given in the event list, return immediately\n   with the current status. If the mouse cursor is outside of the\n   graphics window, the [mouse_x] and [mouse_y] fields of the event are\n   outside the range [0..size_x()-1, 0..size_y()-1]. Keypresses\n   are queued, and dequeued one by one when the [Key_pressed]\n   event is specified and the [Poll] event is not specified. "]


val loop_at_exit : event list -> (status -> unit) -> unit[@@ocaml.doc
                                                           " Loop before exiting the program, the list given as argument is the\n    list of handlers and the events on which these handlers are called.\n    To exit cleanly the loop, the handler should raise Exit. Any other\n    exception will be propagated outside of the loop.\n    @since 4.01\n"]


[@@@ocaml.text " {1 Mouse and keyboard polling} "]

val mouse_pos : unit -> (int * int)[@@ocaml.doc
                                     " Return the position of the mouse cursor, relative to the\n   graphics window. If the mouse cursor is outside of the graphics\n   window, [mouse_pos()] returns a point outside of the range\n   [0..size_x()-1, 0..size_y()-1]. "]


val button_down : unit -> bool[@@ocaml.doc
                                " Return [true] if the mouse button is pressed, [false] otherwise. "]


val read_key : unit -> char[@@ocaml.doc
                             " Wait for a key to be pressed, and return the corresponding\n   character. Keypresses are queued. "]


val key_pressed : unit -> bool[@@ocaml.doc
                                " Return [true] if a keypress is available; that is, if [read_key]\n   would not block. "]


[@@@ocaml.text " {1 Sound} "]

external sound : int -> int -> unit = "caml_gr_sound"[@@ocaml.doc
                                                       " [sound freq dur] plays a sound at frequency [freq] (in hertz)\n   for a duration [dur] (in milliseconds). "]


[@@@ocaml.text " {1 Double buffering} "]

val auto_synchronize : bool -> unit[@@ocaml.doc
                                     " By default, drawing takes place both on the window displayed\n   on screen, and in a memory area (the 'backing store').\n   The backing store image is used to re-paint the on-screen\n   window when necessary.\n\n   To avoid flicker during animations, it is possible to turn\n   off on-screen drawing, perform a number of drawing operations\n   in the backing store only, then refresh the on-screen window\n   explicitly.\n\n   [auto_synchronize false] turns on-screen drawing off.  All\n   subsequent drawing commands are performed on the backing store\n   only.\n\n   [auto_synchronize true] refreshes the on-screen window from\n   the backing store (as per [synchronize]), then turns on-screen\n   drawing back on.  All subsequent drawing commands are performed\n   both on screen and in the backing store.\n\n   The default drawing mode corresponds to [auto_synchronize true]. "]


external synchronize : unit -> unit = "caml_gr_synchronize"[@@ocaml.doc
                                                             " Synchronize the backing store and the on-screen window, by\n   copying the contents of the backing store onto the graphics\n   window. "]


external display_mode : bool -> unit = "caml_gr_display_mode"[@@ocaml.doc
                                                               " Set display mode on or off. When turned on, drawings are done\n   in the graphics window; when turned off, drawings do not affect\n   the graphics window.  This occurs independently of\n   drawing into the backing store (see the function {!Graphics.remember_mode}\n   below). Default display mode is on. "]


external remember_mode : bool -> unit = "caml_gr_remember_mode"[@@ocaml.doc
                                                                 " Set remember mode on or off. When turned on, drawings are done\n   in the backing store; when turned off, the backing store is\n   unaffected by drawings.  This occurs independently of drawing\n   onto the graphics window (see the function {!Graphics.display_mode} above).\n   Default remember mode is on.  "]


*******************************
********* Typed GOSPEL ********
*******************************
module graphics.mli

  Namespace: graphics.mli
    Type symbols
       color [=int]
       event
       image
       status
      
    Logic Symbols
      function Button_down  : event
      function Button_up  : event
      function Key_pressed  : event
      function Mouse_motion  : event
      function Poll  : event
      function button (_:status) : bool
      function constr#status (_:int) (_:int) (_:bool) (_:bool) (_:char) : 
      status
      function key (_:status) : char
      function keypressed (_:status) : bool
      function mouse_x (_:status) : int
      function mouse_y (_:status) : int
      
    Exception Symbols
      Graphic_failure
      
    Namespaces
      
    Type Namespaces
      
  Signatures
    (*@ open Gospelstdlib *)
    
    [@@@ocaml.text " Machine-independent graphics primitives. "]
    
    exception Graphic_failure
    
    [@@@ocaml.text " {1 Initializations} "]
    
    val open_graph :
    string -> unit[@@ocaml.doc
                    " Show the graphics window or switch the screen to graphic mode.\n   The graphics window is cleared and the current point is set\n   to (0, 0). The string argument is used to pass optional\n   information on the desired graphics mode, the graphics window\n   size, and so on. Its interpretation is implementation-dependent.\n   If the empty string is given, a sensible default is selected. "]
    
    
    val close_graph :
    unit -> unit[@@ocaml.doc
                  " Delete the graphics window or switch the screen back to text mode. "]
    
    
    val set_window_title :
    string -> unit[@@ocaml.doc " Set the title of the graphics window. "]
    
    
    val resize_window :
    int -> int -> unit[@@ocaml.doc " Resize and erase the graphics window. "]
    
    
    external clear_graph : unit -> unit =
    "caml_gr_clear_graph"[@@ocaml.doc " Erase the graphics window. "]
    
    
    external size_x : unit -> int =
    "caml_gr_size_x"[@@ocaml.doc " See {!Graphics.size_y}. "]
    
    
    external size_y : unit -> int =
    "caml_gr_size_y"[@@ocaml.doc
                      " Return the size of the graphics window. Coordinates of the screen\n   pixels range over [0 .. size_x()-1] and [0 .. size_y()-1].\n   Drawings outside of this rectangle are clipped, without causing\n   an error. The origin (0,0) is at the lower left corner.\n   Some implementation (e.g. X Windows) represent coordinates by\n   16-bit integers, hence wrong clipping may occur with coordinates\n   below [-32768] or above [32676]. "]
    
    
    [@@@ocaml.text " {1 Colors} "]
    
    type color = int
    
    
    val rgb :
    int -> int -> int -> color[@@ocaml.doc
                                " [rgb r g b] returns the integer encoding the color with red\n   component [r], green component [g], and blue component [b].\n   [r], [g] and [b] are in the range [0..255]. "]
    
    
    external set_color : color -> unit =
    "caml_gr_set_color"[@@ocaml.doc " Set the current drawing color. "]
    
    
    val background : color[@@ocaml.doc " See {!Graphics.foreground}."]
    
    
    val foreground :
    color[@@ocaml.doc
           " Default background and foreground colors (usually, either black\n   foreground on a white background or white foreground on a\n   black background).\n   {!Graphics.clear_graph} fills the screen with the [background] color.\n   The initial drawing color is [foreground]. "]
    
    
    [@@@ocaml.text " {7 Some predefined colors} "]
    
    val black : color
    
    
    val white : color
    
    
    val red : color
    
    
    val green : color
    
    
    val blue : color
    
    
    val yellow : color
    
    
    val cyan : color
    
    
    val magenta : color
    
    
    [@@@ocaml.text " {1 Point and line drawing} "]
    
    external plot : int -> int -> unit =
    "caml_gr_plot"[@@ocaml.doc
                    " Plot the given point with the current drawing color. "]
    
    
    val plots :
    (int * int) array -> unit[@@ocaml.doc
                               " Plot the given points with the current drawing color. "]
    
    
    external point_color : int -> int -> color =
    "caml_gr_point_color"[@@ocaml.doc
                           " Return the color of the given point in the backing store\n   (see \"Double buffering\" below). "]
    
    
    external moveto : int -> int -> unit =
    "caml_gr_moveto"[@@ocaml.doc " Position the current point. "]
    
    
    val rmoveto :
    int -> int -> unit[@@ocaml.doc
                        " [rmoveto dx dy] translates the current point by the given vector. "]
    
    
    external current_x : unit -> int =
    "caml_gr_current_x"[@@ocaml.doc
                         " Return the abscissa of the current point. "]
    
    
    external current_y : unit -> int =
    "caml_gr_current_y"[@@ocaml.doc
                         " Return the ordinate of the current point. "]
    
    
    val current_point :
    unit -> (int * int)[@@ocaml.doc
                         " Return the position of the current point. "]
    
    
    external lineto : int -> int -> unit =
    "caml_gr_lineto"[@@ocaml.doc
                      " Draw a line with endpoints the current point and the given point,\n   and move the current point to the given point. "]
    
    
    val rlineto :
    int -> int -> unit[@@ocaml.doc
                        " Draw a line with endpoints the current point and the\n   current point translated of the given vector,\n   and move the current point to this point. "]
    
    
    val curveto :
    (int * int) -> (int * int) -> (int * int) -> unit[@@ocaml.doc
                                                       " [curveto b c d] draws a cubic Bezier curve starting from\n   the current point to point [d], with control points [b] and\n   [c], and moves the current point to [d]. "]
    
    
    val draw_rect :
    int -> int -> int -> int -> unit[@@ocaml.doc
                                      " [draw_rect x y w h] draws the rectangle with lower left corner\n   at [x,y], width [w] and height [h].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]
    
    
    val draw_poly_line :
    (int * int) array -> unit[@@ocaml.doc
                               " [draw_poly_line points] draws the line that joins the\n   points given by the array argument.\n   The array contains the coordinates of the vertices of the\n   polygonal line, which need not be closed.\n   The current point is unchanged. "]
    
    
    val draw_poly :
    (int * int) array -> unit[@@ocaml.doc
                               " [draw_poly polygon] draws the given polygon.\n   The array contains the coordinates of the vertices of the\n   polygon.\n   The current point is unchanged. "]
    
    
    val draw_segments :
    (int * int * int * int) array -> unit[@@ocaml.doc
                                           " [draw_segments segments] draws the segments given in the array\n   argument. Each segment is specified as a quadruple\n   [(x0, y0, x1, y1)] where [(x0, y0)] and [(x1, y1)] are\n   the coordinates of the end points of the segment.\n   The current point is unchanged. "]
    
    
    val draw_arc :
    int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                    " [draw_arc x y rx ry a1 a2] draws an elliptical arc with center\n   [x,y], horizontal radius [rx], vertical radius [ry], from angle\n   [a1] to angle [a2] (in degrees). The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]
    
    
    val draw_ellipse :
    int -> int -> int -> int -> unit[@@ocaml.doc
                                      " [draw_ellipse x y rx ry] draws an ellipse with center\n   [x,y], horizontal radius [rx] and vertical radius [ry].\n   The current point is unchanged.\n   Raise [Invalid_argument] if [rx] or [ry] is negative. "]
    
    
    val draw_circle :
    int -> int -> int -> unit[@@ocaml.doc
                               " [draw_circle x y r] draws a circle with center [x,y] and\n   radius [r]. The current point is unchanged.\n   Raise [Invalid_argument] if [r] is negative. "]
    
    
    val set_line_width :
    int -> unit[@@ocaml.doc
                 " Set the width of points and lines drawn with the functions above.\n   Under X Windows, [set_line_width 0] selects a width of 1 pixel\n   and a faster, but less precise drawing algorithm than the one\n   used when [set_line_width 1] is specified.\n   Raise [Invalid_argument] if the argument is negative. "]
    
    
    [@@@ocaml.text " {1 Text drawing} "]
    
    external draw_char : char -> unit =
    "caml_gr_draw_char"[@@ocaml.doc " See {!Graphics.draw_string}."]
    
    
    external draw_string : string -> unit =
    "caml_gr_draw_string"[@@ocaml.doc
                           " Draw a character or a character string with lower left corner\n   at current position. After drawing, the current position is set\n   to the lower right corner of the text drawn. "]
    
    
    external set_font : string -> unit =
    "caml_gr_set_font"[@@ocaml.doc
                        " Set the font used for drawing text.\n   The interpretation of the argument to [set_font]\n   is implementation-dependent. "]
    
    
    val set_text_size :
    int -> unit[@@ocaml.doc
                 " Set the character size used for drawing text.\n   The interpretation of the argument to [set_text_size]\n   is implementation-dependent. "]
    
    
    external text_size : string -> (int * int) =
    "caml_gr_text_size"[@@ocaml.doc
                         " Return the dimensions of the given text, if it were drawn with\n   the current font and size. "]
    
    
    [@@@ocaml.text " {1 Filling} "]
    
    val fill_rect :
    int -> int -> int -> int -> unit[@@ocaml.doc
                                      " [fill_rect x y w h] fills the rectangle with lower left corner\n   at [x,y], width [w] and height [h], with the current color.\n   Raise [Invalid_argument] if [w] or [h] is negative. "]
    
    
    external fill_poly : (int * int) array -> unit =
    "caml_gr_fill_poly"[@@ocaml.doc
                         " Fill the given polygon with the current color. The array\n   contains the coordinates of the vertices of the polygon. "]
    
    
    val fill_arc :
    int -> int -> int -> int -> int -> int -> unit[@@ocaml.doc
                                                    " Fill an elliptical pie slice with the current color. The\n   parameters are the same as for {!Graphics.draw_arc}. "]
    
    
    val fill_ellipse :
    int -> int -> int -> int -> unit[@@ocaml.doc
                                      " Fill an ellipse with the current color. The\n   parameters are the same as for {!Graphics.draw_ellipse}. "]
    
    
    val fill_circle :
    int -> int -> int -> unit[@@ocaml.doc
                               " Fill a circle with the current color. The\n   parameters are the same as for {!Graphics.draw_circle}. "]
    
    
    [@@@ocaml.text " {1 Images} "]
    
    type image
    
    
    val transp :
    color[@@ocaml.doc
           " In matrices of colors, this color represent a 'transparent'\n   point: when drawing the corresponding image, all pixels on the\n   screen corresponding to a transparent pixel in the image will\n   not be modified, while other points will be set to the color\n   of the corresponding point in the image. This allows superimposing\n   an image over an existing background. "]
    
    
    external make_image : color array array -> image =
    "caml_gr_make_image"[@@ocaml.doc
                          " Convert the given color matrix to an image.\n   Each sub-array represents one horizontal line. All sub-arrays\n   must have the same length; otherwise, exception [Graphic_failure]\n   is raised. "]
    
    
    external dump_image : image -> color array array =
    "caml_gr_dump_image"[@@ocaml.doc " Convert an image to a color matrix. "]
    
    
    external draw_image : image -> int -> int -> unit =
    "caml_gr_draw_image"[@@ocaml.doc
                          " Draw the given image with lower left corner at the given point. "]
    
    
    val get_image :
    int -> int -> int -> int -> image[@@ocaml.doc
                                       " Capture the contents of a rectangle on the screen as an image.\n   The parameters are the same as for {!Graphics.fill_rect}. "]
    
    
    external create_image : int -> int -> image =
    "caml_gr_create_image"[@@ocaml.doc
                            " [create_image w h] returns a new image [w] pixels wide and [h]\n   pixels tall, to be used in conjunction with [blit_image].\n   The initial image contents are random, except that no point\n   is transparent. "]
    
    
    external blit_image : image -> int -> int -> unit =
    "caml_gr_blit_image"[@@ocaml.doc
                          " [blit_image img x y] copies screen pixels into the image [img],\n   modifying [img] in-place. The pixels copied are those inside the\n   rectangle with lower left corner at [x,y], and width and height\n   equal to those of the image. Pixels that were transparent in\n   [img] are left unchanged. "]
    
    
    [@@@ocaml.text " {1 Mouse and keyboard events} "]
    
    type status = {mouse_x:int; mouse_y:int; button:bool; keypressed:
               bool; key:char}
               function constr#status (_:int) (_:int) (_:bool) (_:bool) (_:char) : status
                 function mouse_x (_:status) : int
                 function mouse_y (_:status) : int
                 function button (_:status) : bool
                 function keypressed (_:status) : bool
                 function key (_:status) : char
    
    
    type event = Button_down of 
                 function Button_down  : event
              | Button_up of 
                function Button_up  : event
              | Key_pressed of 
                function Key_pressed  : event
              | Mouse_motion of 
                function Mouse_motion  : event
              | Poll of 
                function Poll  : event
    
    
    external wait_next_event : event list -> status =
    "caml_gr_wait_event"[@@ocaml.doc
                          " Wait until one of the events specified in the given event list\n   occurs, and return the status of the mouse and keyboard at\n   that time. If [Poll] is given in the event list, return immediately\n   with the current status. If the mouse cursor is outside of the\n   graphics window, the [mouse_x] and [mouse_y] fields of the event are\n   outside the range [0..size_x()-1, 0..size_y()-1]. Keypresses\n   are queued, and dequeued one by one when the [Key_pressed]\n   event is specified and the [Poll] event is not specified. "]
    
    
    val loop_at_exit :
    event list -> (status -> unit) -> unit[@@ocaml.doc
                                            " Loop before exiting the program, the list given as argument is the\n    list of handlers and the events on which these handlers are called.\n    To exit cleanly the loop, the handler should raise Exit. Any other\n    exception will be propagated outside of the loop.\n    @since 4.01\n"]
    
    
    [@@@ocaml.text " {1 Mouse and keyboard polling} "]
    
    val mouse_pos :
    unit -> (int * int)[@@ocaml.doc
                         " Return the position of the mouse cursor, relative to the\n   graphics window. If the mouse cursor is outside of the graphics\n   window, [mouse_pos()] returns a point outside of the range\n   [0..size_x()-1, 0..size_y()-1]. "]
    
    
    val button_down :
    unit -> bool[@@ocaml.doc
                  " Return [true] if the mouse button is pressed, [false] otherwise. "]
    
    
    val read_key :
    unit -> char[@@ocaml.doc
                  " Wait for a key to be pressed, and return the corresponding\n   character. Keypresses are queued. "]
    
    
    val key_pressed :
    unit -> bool[@@ocaml.doc
                  " Return [true] if a keypress is available; that is, if [read_key]\n   would not block. "]
    
    
    [@@@ocaml.text " {1 Sound} "]
    
    external sound : int -> int -> unit =
    "caml_gr_sound"[@@ocaml.doc
                     " [sound freq dur] plays a sound at frequency [freq] (in hertz)\n   for a duration [dur] (in milliseconds). "]
    
    
    [@@@ocaml.text " {1 Double buffering} "]
    
    val auto_synchronize :
    bool -> unit[@@ocaml.doc
                  " By default, drawing takes place both on the window displayed\n   on screen, and in a memory area (the 'backing store').\n   The backing store image is used to re-paint the on-screen\n   window when necessary.\n\n   To avoid flicker during animations, it is possible to turn\n   off on-screen drawing, perform a number of drawing operations\n   in the backing store only, then refresh the on-screen window\n   explicitly.\n\n   [auto_synchronize false] turns on-screen drawing off.  All\n   subsequent drawing commands are performed on the backing store\n   only.\n\n   [auto_synchronize true] refreshes the on-screen window from\n   the backing store (as per [synchronize]), then turns on-screen\n   drawing back on.  All subsequent drawing commands are performed\n   both on screen and in the backing store.\n\n   The default drawing mode corresponds to [auto_synchronize true]. "]
    
    
    external synchronize : unit -> unit =
    "caml_gr_synchronize"[@@ocaml.doc
                           " Synchronize the backing store and the on-screen window, by\n   copying the contents of the backing store onto the graphics\n   window. "]
    
    
    external display_mode : bool -> unit =
    "caml_gr_display_mode"[@@ocaml.doc
                            " Set display mode on or off. When turned on, drawings are done\n   in the graphics window; when turned off, drawings do not affect\n   the graphics window.  This occurs independently of\n   drawing into the backing store (see the function {!Graphics.remember_mode}\n   below). Default display mode is on. "]
    
    
    external remember_mode : bool -> unit =
    "caml_gr_remember_mode"[@@ocaml.doc
                             " Set remember mode on or off. When turned on, drawings are done\n   in the backing store; when turned off, the backing store is\n   unaffected by drawings.  This occurs independently of drawing\n   onto the graphics window (see the function {!Graphics.display_mode} above).\n   Default remember mode is on.  "]
    


*** OK ***

