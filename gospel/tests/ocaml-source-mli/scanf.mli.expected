
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text " Formatted input functions. "]
[@@@ocaml.text " {1 Introduction} "]
[@@@ocaml.text " {2 Functional input with format strings} "]
[@@@ocaml.text
  " The module {!Scanf} provides formatted input functions or {e scanners}.\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a {e formatted input channel} (or {e\n    scanning buffer}) and has type {!Scanning.in_channel}. The more general\n    formatted input function reads from any scanning buffer and is named\n    [bscanf].\n\n    Generally speaking, the formatted input functions have 3 arguments:\n    - the first argument is a source of characters for the input,\n    - the second argument is a format string that specifies the values to\n      read,\n    - the third argument is a {e receiver function} that is applied to the\n      values read.\n\n    Hence, a typical call to the formatted input function {!Scanf.bscanf} is\n    [bscanf ic fmt f], where:\n\n    - [ic] is a source of characters (typically a {e\n    formatted input channel} with type {!Scanning.in_channel}),\n\n    - [fmt] is a format string (the same format strings as those used to print\n    material with module {!Printf} or {!Format}),\n\n    - [f] is a function that has as many arguments as the number of values to\n    read in the input according to [fmt].\n"]
[@@@ocaml.text " {2 A simple example} "]
[@@@ocaml.text
  " As suggested above, the expression [bscanf ic \"%d\" f] reads a decimal\n    integer [n] from the source of characters [ic] and returns [f n].\n\n    For instance,\n\n    - if we use [stdin] as the source of characters ({!Scanning.stdin} is\n    the predefined formatted input channel that reads from standard input),\n\n    - if we define the receiver [f] as [let f x = x + 1],\n\n    then [bscanf Scanning.stdin \"%d\" f] reads an integer [n] from the\n    standard input and returns [f n] (that is [n + 1]). Thus, if we\n    evaluate [bscanf stdin \"%d\" f], and then enter [41] at the\n    keyboard, the result we get is [42].\n"]
[@@@ocaml.text " {2 Formatted input as a functional feature} "]
[@@@ocaml.text
  " The OCaml scanning facility is reminiscent of the corresponding C feature.\n    However, it is also largely different, simpler, and yet more powerful:\n    the formatted input functions are higher-order functionals and the\n    parameter passing mechanism is just the regular function application not\n    the variable assignment based mechanism which is typical for formatted\n    input in imperative languages; the OCaml format strings also feature\n    useful additions to easily define complex tokens; as expected within a\n    functional programming language, the formatted input functions also\n    support polymorphism, in particular arbitrary interaction with\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\n    facility is fully type-checked at compile time.\n"]
[@@@ocaml.text " {1 Formatted input channel} "]
module Scanning :
sig
  type in_channel[@@ocaml.doc
                   " The notion of input channel for the {!Scanf} module:\n   those channels provide all the machinery necessary to read from any source\n   of characters, including a {!Stdlib.in_channel} value.\n   A Scanf.Scanning.in_channel value is also called a {i formatted input\n   channel} or equivalently a {i scanning buffer}.\n   The type {!Scanning.scanbuf} below is an alias for [Scanning.in_channel].\n   @since 3.12.0\n"]
  type scanbuf = in_channel[@@ocaml.doc
                             " The type of scanning buffers. A scanning buffer is the source from which a\n    formatted input function gets characters. The scanning buffer holds the\n    current state of the scan, plus a function to get the next char from the\n    input, and a token buffer to store the string matched so far.\n\n    Note: a scanning action may often require to examine one character in\n    advance; when this 'lookahead' character does not belong to the token\n    read, it is stored back in the scanning buffer and becomes the next\n    character yet to be read.\n"]
  val stdin : in_channel[@@ocaml.doc
                          " The standard input notion for the {!Scanf} module.\n    [Scanning.stdin] is the {!Scanning.in_channel} formatted input channel\n    attached to {!Stdlib.stdin}.\n\n    Note: in the interactive system, when input is read from\n    {!Stdlib.stdin}, the newline character that triggers evaluation is\n    part of the input; thus, the scanning specifications must properly skip\n    this additional newline character (for instance, simply add a ['\\n'] as\n    the last character of the format string).\n    @since 3.12.0\n"]
  type file_name = string[@@ocaml.doc
                           " A convenient alias to designate a file name.\n    @since 4.00.0\n"]
  val open_in : file_name -> in_channel[@@ocaml.doc
                                         " [Scanning.open_in fname] returns a {!Scanning.in_channel} formatted input\n    channel for bufferized reading in text mode from file [fname].\n\n    Note:\n    [open_in] returns a formatted input channel that efficiently reads\n    characters in large chunks; in contrast, [from_channel] below returns\n    formatted input channels that must read one character at a time, leading\n    to a much slower scanning rate.\n    @since 3.12.0\n"]
  val open_in_bin : file_name -> in_channel[@@ocaml.doc
                                             " [Scanning.open_in_bin fname] returns a {!Scanning.in_channel} formatted\n    input channel for bufferized reading in binary mode from file [fname].\n    @since 3.12.0\n"]
  val close_in : in_channel -> unit[@@ocaml.doc
                                     " Closes the {!Stdlib.in_channel} associated with the given\n  {!Scanning.in_channel} formatted input channel.\n  @since 3.12.0\n"]
  val from_file : file_name -> in_channel[@@ocaml.doc
                                           " An alias for {!Scanning.open_in} above. "]
  val from_file_bin : string -> in_channel[@@ocaml.doc
                                            " An alias for {!Scanning.open_in_bin} above. "]
  val from_string : string -> in_channel[@@ocaml.doc
                                          " [Scanning.from_string s] returns a {!Scanning.in_channel} formatted\n    input channel which reads from the given string.\n    Reading starts from the first character in the string.\n    The end-of-input condition is set when the end of the string is reached.\n"]
  val from_function : (unit -> char) -> in_channel[@@ocaml.doc
                                                    " [Scanning.from_function f] returns a {!Scanning.in_channel} formatted\n    input channel with the given function as its reading method.\n\n    When scanning needs one more character, the given function is called.\n\n    When the function has no more character to provide, it {e must} signal an\n    end-of-input condition by raising the exception [End_of_file].\n"]
  val from_channel : Stdlib.in_channel -> in_channel[@@ocaml.doc
                                                      " [Scanning.from_channel ic] returns a {!Scanning.in_channel} formatted\n    input channel which reads from the regular {!Stdlib.in_channel} input\n    channel [ic] argument.\n    Reading starts at current reading position of [ic].\n"]
  val end_of_input : in_channel -> bool[@@ocaml.doc
                                         " [Scanning.end_of_input ic] tests the end-of-input condition of the given\n    {!Scanning.in_channel} formatted input channel.\n"]
  val beginning_of_input : in_channel -> bool[@@ocaml.doc
                                               " [Scanning.beginning_of_input ic] tests the beginning of input condition\n    of the given {!Scanning.in_channel} formatted input channel.\n"]
  val name_of_input : in_channel -> string[@@ocaml.doc
                                            " [Scanning.name_of_input ic] returns the name of the character source\n    for the given {!Scanning.in_channel} formatted input channel.\n    @since 3.09.0\n"]
  val stdib : in_channel[@@ocaml.deprecated
                          "Use Scanf.Scanning.stdin instead."][@@ocaml.doc
                                                                " A deprecated alias for {!Scanning.stdin}, the scanning buffer reading from\n    {!Stdlib.stdin}.\n"]
end
[@@@ocaml.text " {1 Type of formatted input functions} "]
type ('a, 'b, 'c, 'd) scanner =
  ('a, Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c[@@ocaml.doc
                                                                 " The type of formatted input scanners: [('a, 'b, 'c, 'd) scanner]\n    is the type of a formatted input function that reads from some\n    formatted input channel according to some format string; more\n    precisely, if [scan] is some formatted input function, then [scan\n    ic fmt f] applies [f] to all the arguments specified by format\n    string [fmt], when [scan] has read those arguments from the\n    {!Scanning.in_channel} formatted input channel [ic].\n\n    For instance, the {!Scanf.scanf} function below has type\n    [('a, 'b, 'c, 'd) scanner], since it is a formatted input function that\n    reads from {!Scanning.stdin}: [scanf fmt f] applies [f] to the arguments\n    specified by [fmt], reading those arguments from {!Stdlib.stdin} as\n    expected.\n\n    If the format [fmt] has some [%r] indications, the corresponding\n    formatted input functions must be provided {e before} receiver function\n    [f]. For instance, if [read_elem] is an input function for values of type\n    [t], then [bscanf ic \"%r;\" read_elem f] reads a value [v] of type [t]\n    followed by a [';'] character, and returns [f v].\n    @since 3.10.0\n"]
exception Scan_failure of string
  [@ocaml.doc
    " When the input can not be read according to the format string\n    specification, formatted input functions typically raise exception\n    [Scan_failure].\n"]
[@@@ocaml.text " {1 The general formatted input function} "]
val bscanf : Scanning.in_channel -> ('a, 'b, 'c, 'd) scanner
[@@@ocaml.text
  " [bscanf ic fmt r1 ... rN f] reads characters from the\n    {!Scanning.in_channel} formatted input channel [ic] and converts them to\n    values according to format string [fmt].\n    As a final step, receiver function [f] is applied to the values read and\n    gives the result of the [bscanf] call.\n\n    For instance, if [f] is the function [fun s i -> i + 1], then\n    [Scanf.sscanf \"x= 1\" \"%s = %i\" f] returns [2].\n\n    Arguments [r1] to [rN] are user-defined input functions that read the\n    argument corresponding to the [%r] conversions specified in the format\n    string.\n"]
[@@@ocaml.text " {1 Format string description} "]
[@@@ocaml.text
  " The format string is a character string which contains three types of\n    objects:\n    - plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see {!Scanf.space}),\n    - conversion specifications, each of which causes reading and conversion of\n      one argument for the function [f] (see {!Scanf.conversion}),\n    - scanning indications to specify boundaries of tokens\n      (see scanning {!Scanf.indication}).\n"]
[@@@ocaml.text " {2:space The space character in format strings} "]
[@@@ocaml.text
  " As mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character ([' '] or ASCII code\n    32) and the line feed character (['\\n'] or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    'whitespace' in the input. More precisely, a space inside the format\n    string matches {e any number} of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n\n    Matching {e any} amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call [bscanf ib\n    \"Price = %d $\" (fun p -> p)] succeeds and returns [1] when reading an\n    input with various whitespace in it, such as [Price = 1 $],\n    [Price  =  1    $], or even [Price=1$].\n"]
[@@@ocaml.text
  " {2:conversion Conversion specifications in format strings} "]
[@@@ocaml.text
  " Conversion specifications consist in the [%] character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters.\n\n    The conversion characters and their meanings are:\n\n    - [d]: reads an optionally signed decimal integer ([0-9]+).\n    - [i]: reads an optionally signed integer\n      (usual input conventions for decimal ([0-9]+), hexadecimal\n       ([0x[0-9a-f]+] and [0X[0-9A-F]+]), octal ([0o[0-7]+]), and binary\n       ([0b[0-1]+]) notations are understood).\n    - [u]: reads an unsigned decimal integer.\n    - [x] or [X]: reads an unsigned hexadecimal integer ([[0-9a-fA-F]+]).\n    - [o]: reads an unsigned octal integer ([[0-7]+]).\n    - [s]: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: {ul\n      {- a whitespace has been found (see {!Scanf.space}),}\n      {- a scanning indication (see scanning {!Scanf.indication}) has been\n         encountered,}\n      {- the end-of-input has been reached.}}\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.\n    - [S]: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).\n    - [c]: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification [%0c]. Raise [Invalid_argument], if the field width\n      specification is greater than 1.\n    - [C]: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).\n    - [f], [e], [E], [g], [G]: reads an optionally signed\n      floating-point number in decimal notation, in the style [dddd.ddd\n      e/E+-dd].\n    - [h], [H]: reads an optionally signed floating-point number\n      in hexadecimal notation.\n    - [F]: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).\n    - [B]: reads a boolean argument ([true] or [false]).\n    - [b]: reads a boolean argument (for backward compatibility; do not use\n      in new programs).\n    - [ld], [li], [lu], [lx], [lX], [lo]: reads an [int32] argument to\n      the format specified by the second letter for regular integers.\n    - [nd], [ni], [nu], [nx], [nX], [no]: reads a [nativeint] argument to\n      the format specified by the second letter for regular integers.\n    - [Ld], [Li], [Lu], [Lx], [LX], [Lo]: reads an [int64] argument to\n      the format specified by the second letter for regular integers.\n    - [[ range ]]: reads characters that matches one of the characters\n      mentioned in the range of characters [range] (or not mentioned in\n      it, if the range starts with [^]). Reads a [string] that can be\n      empty, if the next input character does not match the range. The set of\n      characters from [c1] to [c2] (inclusively) is denoted by [c1-c2].\n      Hence, [%[0-9]] returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      [%[0-9a-f]] returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the [^] in case of\n      range negation); hence [[\\]]] matches a [\\]] character and\n      [[^\\]]] matches any character that is not [\\]].\n      Use [%%] and [%@] to include a [%] or a [@] in a range.\n    - [r]: user-defined reader. Takes the next [ri] formatted input\n      function and applies it to the scanning buffer [ib] to read the\n      next argument. The input function [ri] must therefore have type\n      [Scanning.in_channel -> 'a] and the argument read has type ['a].\n    - [{ fmt %}]: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      [fmt]. For instance, [\"%{ %i %}\"] reads any format string that\n      can read a value of type [int]; hence, if [s] is the string\n      [\"fmt:\\\"number is %u\\\"\"], then [Scanf.sscanf s \"fmt: %{%i%}\"]\n      succeeds and returns the format string [\"number is %u\"].\n    - [( fmt %)]: scanning sub-format substitution.\n      Reads a format string [rf] in the input, then goes on scanning with\n      [rf] instead of scanning with [fmt].\n      The format string [rf] must have the same type as the format string\n      specification [fmt] that it replaces.\n      For instance, [\"%( %i %)\"] reads any format string that can read a value\n      of type [int].\n      The conversion returns the format string read [rf], and then a value\n      read using [rf].\n      Hence, if [s] is the string [\"\\\"%4d\\\"1234.00\"], then\n      [Scanf.sscanf s \"%(%i%)\" (fun fmt i -> fmt, i)] evaluates to\n      [(\"%4d\", 1234)].\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag [_] to discard the\n      extraneous argument: conversion [%_( fmt %)] reads a format string\n      [rf] and then behaves the same as format string [rf].  Hence, if [s] is\n      the string [\"\\\"%4d\\\"1234.00\"], then [Scanf.sscanf s \"%_(%i%)\"] is\n      simply equivalent to [Scanf.sscanf \"1234.00\" \"%4d\"].\n    - [l]: returns the number of lines read so far.\n    - [n]: returns the number of characters read so far.\n    - [N] or [L]: returns the number of tokens read so far.\n    - [!]: matches the end of input condition.\n    - [%]: matches one [%] character in the input.\n    - [@]: matches one [@] character in the input.\n    - [,]: does nothing.\n\n    Following the [%] character that introduces a conversion, there may be\n    the special flag [_]: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if [f] is the function [fun i -> i + 1], and [s] is the\n    string [\"x = 1\"], then [Scanf.sscanf s \"%_s = %i\" f] returns [2].\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, [%6d] reads an integer, having at most 6 decimal digits;\n    [%4f] reads a float with at most 4 characters; and [%8[\\000-\\255]]\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n\n    Notes:\n\n    - as mentioned above, a [%s] conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns [\"\"].\n\n    - in addition to the relevant digits, ['_'] characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.\n\n    - the [scanf] facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    {!Str}), stream parsers, [ocamllex]-generated lexers,\n    [ocamlyacc]-generated parsers.\n"]
[@@@ocaml.text " {2:indication Scanning indications in format strings} "]
[@@@ocaml.text
  " Scanning indications appear just after the string conversions [%s]\n    and [%[ range ]] to delimit the end of the token. A scanning\n    indication is introduced by a [@] character, followed by some\n    plain character [c]. It means that the string token should end\n    just before the next matching [c] (which is skipped). If no [c]\n    character is encountered, the string token spreads as much as\n    possible. For instance, [\"%s@\\t\"] reads a string up to the next\n    tab character or to the end of input. If a [@] character appears\n    anywhere else in the format string, it is treated as a plain character.\n\n    Note:\n\n    - As usual in format strings, [%] and [@] characters must be escaped\n    using [%%] and [%@]; this rule still holds within range specifications\n    and scanning indications.\n    For instance, format [\"%s@%%\"] reads a string up to the next [%]\n    character, and format [\"%s@%@\"] reads a string up to the next [@].\n    - The scanning indications introduce slight differences in the syntax of\n    {!Scanf} format strings, compared to those used for the {!Printf}\n    module. However, the scanning indications are similar to those used in\n    the {!Format} module; hence, when producing formatted text to be scanned\n    by {!Scanf.bscanf}, it is wise to use printing functions from the\n    {!Format} module (or, if you need to use functions from {!Printf}, banish\n    or carefully double check the format strings that contain ['@']\n    characters).\n"]
[@@@ocaml.text " {2 Exceptions during scanning} "]
[@@@ocaml.text
  " Scanners may raise the following exceptions when the input cannot be read\n    according to the format string:\n\n    - Raise {!Scanf.Scan_failure} if the input does not match the format.\n\n    - Raise [Failure] if a conversion to a number is not possible.\n\n    - Raise [End_of_file] if the end of input is encountered while some more\n      characters are needed to read the current conversion specification.\n\n    - Raise [Invalid_argument] if the format string is invalid.\n\n    Note:\n\n    - as a consequence, scanning a [%s] conversion never raises exception\n    [End_of_file]: if the end of input is reached the conversion succeeds and\n    simply returns the characters read so far, or [\"\"] if none were ever read.\n"]
[@@@ocaml.text " {1 Specialised formatted input functions} "]
val sscanf : string -> ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                                 " Same as {!Scanf.bscanf}, but reads from the given string. "]
val scanf : ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                      " Same as {!Scanf.bscanf}, but reads from the predefined formatted input\n    channel {!Scanf.Scanning.stdin} that is connected to {!Stdlib.stdin}.\n"]
val kscanf :
  Scanning.in_channel ->
    (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                                                    " Same as {!Scanf.bscanf}, but takes an additional function argument\n    [ef] that is called in case of error: if the scanning process or\n    some conversion fails, the scanning function aborts and calls the\n    error handling function [ef] with the formatted input channel and the\n    exception that aborted the scanning process as arguments.\n"]
val ksscanf :
  string -> (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner
[@@ocaml.doc
  " Same as {!Scanf.kscanf} but reads from the given string.\n    @since 4.02.0 "]
[@@@ocaml.text " {1 Reading format strings from input} "]
val bscanf_format :
  Scanning.in_channel ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g[@@ocaml.doc
                                                      " [bscanf_format ic fmt f] reads a format string token from the formatted\n    input channel [ic], according to the given format string [fmt], and\n    applies [f] to the resulting format string value.\n    Raise {!Scan_failure} if the format string value read does not have the\n    same type as [fmt].\n    @since 3.09.0\n"]
val sscanf_format :
  string ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g[@@ocaml.doc
                                                      " Same as {!Scanf.bscanf_format}, but reads from the given string.\n    @since 3.09.0\n"]
val format_from_string :
  string ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6
[@@ocaml.doc
  " [format_from_string s fmt] converts a string argument to a format string,\n    according to the given format string [fmt].\n    Raise {!Scan_failure} if [s], considered as a format string, does not\n    have the same type as [fmt].\n    @since 3.10.0\n"]
val unescaped : string -> string[@@ocaml.doc
                                  " [unescaped s] return a copy of [s] with escape sequences (according to\n    the lexical conventions of OCaml) replaced by their corresponding special\n    characters.\n    More precisely, [Scanf.unescaped] has the following property:\n    for all string [s], [Scanf.unescaped (String.escaped s) = s].\n\n    Always return a copy of the argument, even if there is no escape sequence\n    in the argument.\n    Raise {!Scan_failure} if [s] is not properly escaped (i.e. [s] has invalid\n    escape sequences or special characters that are not properly escaped).\n    For instance, [String.unescaped \"\\\"\"] will fail.\n    @since 4.00.0\n"]
[@@@ocaml.text " {1 Deprecated} "]
val fscanf : Stdlib.in_channel -> ('a, 'b, 'c, 'd) scanner[@@ocaml.deprecated
                                                            "Use Scanning.from_channel then Scanf.bscanf."]
[@@ocaml.doc
  " @deprecated [Scanf.fscanf] is error prone and deprecated since 4.03.0.\n\n    This function violates the following invariant of the {!Scanf} module:\n    To preserve scanning semantics, all scanning functions defined in {!Scanf}\n    must read from a user defined {!Scanning.in_channel} formatted input\n    channel.\n\n    If you need to read from a {!Stdlib.in_channel} input channel\n    [ic], simply define a {!Scanning.in_channel} formatted input channel as in\n    [let ib = Scanning.from_channel ic],\n    then use [Scanf.bscanf ib] as usual.\n"]
val kfscanf :
  Stdlib.in_channel ->
    (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner[@@ocaml.deprecated
                                                                    "Use Scanning.from_channel then Scanf.kscanf."]
[@@ocaml.doc
  " @deprecated [Scanf.kfscanf] is error prone and deprecated since 4.03.0. "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text " Formatted input functions. "]

[@@@ocaml.text " {1 Introduction} "]

[@@@ocaml.text " {2 Functional input with format strings} "]

[@@@ocaml.text
  " The module {!Scanf} provides formatted input functions or {e scanners}.\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a {e formatted input channel} (or {e\n    scanning buffer}) and has type {!Scanning.in_channel}. The more general\n    formatted input function reads from any scanning buffer and is named\n    [bscanf].\n\n    Generally speaking, the formatted input functions have 3 arguments:\n    - the first argument is a source of characters for the input,\n    - the second argument is a format string that specifies the values to\n      read,\n    - the third argument is a {e receiver function} that is applied to the\n      values read.\n\n    Hence, a typical call to the formatted input function {!Scanf.bscanf} is\n    [bscanf ic fmt f], where:\n\n    - [ic] is a source of characters (typically a {e\n    formatted input channel} with type {!Scanning.in_channel}),\n\n    - [fmt] is a format string (the same format strings as those used to print\n    material with module {!Printf} or {!Format}),\n\n    - [f] is a function that has as many arguments as the number of values to\n    read in the input according to [fmt].\n"]

[@@@ocaml.text " {2 A simple example} "]

[@@@ocaml.text
  " As suggested above, the expression [bscanf ic \"%d\" f] reads a decimal\n    integer [n] from the source of characters [ic] and returns [f n].\n\n    For instance,\n\n    - if we use [stdin] as the source of characters ({!Scanning.stdin} is\n    the predefined formatted input channel that reads from standard input),\n\n    - if we define the receiver [f] as [let f x = x + 1],\n\n    then [bscanf Scanning.stdin \"%d\" f] reads an integer [n] from the\n    standard input and returns [f n] (that is [n + 1]). Thus, if we\n    evaluate [bscanf stdin \"%d\" f], and then enter [41] at the\n    keyboard, the result we get is [42].\n"]

[@@@ocaml.text " {2 Formatted input as a functional feature} "]

[@@@ocaml.text
  " The OCaml scanning facility is reminiscent of the corresponding C feature.\n    However, it is also largely different, simpler, and yet more powerful:\n    the formatted input functions are higher-order functionals and the\n    parameter passing mechanism is just the regular function application not\n    the variable assignment based mechanism which is typical for formatted\n    input in imperative languages; the OCaml format strings also feature\n    useful additions to easily define complex tokens; as expected within a\n    functional programming language, the formatted input functions also\n    support polymorphism, in particular arbitrary interaction with\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\n    facility is fully type-checked at compile time.\n"]

[@@@ocaml.text " {1 Formatted input channel} "]

module Scanning :
sig
  type in_channel[@@ocaml.doc
                   " The notion of input channel for the {!Scanf} module:\n   those channels provide all the machinery necessary to read from any source\n   of characters, including a {!Stdlib.in_channel} value.\n   A Scanf.Scanning.in_channel value is also called a {i formatted input\n   channel} or equivalently a {i scanning buffer}.\n   The type {!Scanning.scanbuf} below is an alias for [Scanning.in_channel].\n   @since 3.12.0\n"]
    
  type scanbuf = in_channel[@@ocaml.doc
                             " The type of scanning buffers. A scanning buffer is the source from which a\n    formatted input function gets characters. The scanning buffer holds the\n    current state of the scan, plus a function to get the next char from the\n    input, and a token buffer to store the string matched so far.\n\n    Note: a scanning action may often require to examine one character in\n    advance; when this 'lookahead' character does not belong to the token\n    read, it is stored back in the scanning buffer and becomes the next\n    character yet to be read.\n"]
    
  val stdin : in_channel[@@ocaml.doc
                          " The standard input notion for the {!Scanf} module.\n    [Scanning.stdin] is the {!Scanning.in_channel} formatted input channel\n    attached to {!Stdlib.stdin}.\n\n    Note: in the interactive system, when input is read from\n    {!Stdlib.stdin}, the newline character that triggers evaluation is\n    part of the input; thus, the scanning specifications must properly skip\n    this additional newline character (for instance, simply add a ['\\n'] as\n    the last character of the format string).\n    @since 3.12.0\n"]
  
  type file_name = string[@@ocaml.doc
                           " A convenient alias to designate a file name.\n    @since 4.00.0\n"]
    
  val open_in : file_name -> in_channel[@@ocaml.doc
                                         " [Scanning.open_in fname] returns a {!Scanning.in_channel} formatted input\n    channel for bufferized reading in text mode from file [fname].\n\n    Note:\n    [open_in] returns a formatted input channel that efficiently reads\n    characters in large chunks; in contrast, [from_channel] below returns\n    formatted input channels that must read one character at a time, leading\n    to a much slower scanning rate.\n    @since 3.12.0\n"]
  
  val open_in_bin : file_name -> in_channel[@@ocaml.doc
                                             " [Scanning.open_in_bin fname] returns a {!Scanning.in_channel} formatted\n    input channel for bufferized reading in binary mode from file [fname].\n    @since 3.12.0\n"]
  
  val close_in : in_channel -> unit[@@ocaml.doc
                                     " Closes the {!Stdlib.in_channel} associated with the given\n  {!Scanning.in_channel} formatted input channel.\n  @since 3.12.0\n"]
  
  val from_file : file_name -> in_channel[@@ocaml.doc
                                           " An alias for {!Scanning.open_in} above. "]
  
  val from_file_bin : string -> in_channel[@@ocaml.doc
                                            " An alias for {!Scanning.open_in_bin} above. "]
  
  val from_string : string -> in_channel[@@ocaml.doc
                                          " [Scanning.from_string s] returns a {!Scanning.in_channel} formatted\n    input channel which reads from the given string.\n    Reading starts from the first character in the string.\n    The end-of-input condition is set when the end of the string is reached.\n"]
  
  val from_function : (unit -> char) -> in_channel[@@ocaml.doc
                                                    " [Scanning.from_function f] returns a {!Scanning.in_channel} formatted\n    input channel with the given function as its reading method.\n\n    When scanning needs one more character, the given function is called.\n\n    When the function has no more character to provide, it {e must} signal an\n    end-of-input condition by raising the exception [End_of_file].\n"]
  
  val from_channel : Stdlib.in_channel -> in_channel[@@ocaml.doc
                                                      " [Scanning.from_channel ic] returns a {!Scanning.in_channel} formatted\n    input channel which reads from the regular {!Stdlib.in_channel} input\n    channel [ic] argument.\n    Reading starts at current reading position of [ic].\n"]
  
  val end_of_input : in_channel -> bool[@@ocaml.doc
                                         " [Scanning.end_of_input ic] tests the end-of-input condition of the given\n    {!Scanning.in_channel} formatted input channel.\n"]
  
  val beginning_of_input : in_channel -> bool[@@ocaml.doc
                                               " [Scanning.beginning_of_input ic] tests the beginning of input condition\n    of the given {!Scanning.in_channel} formatted input channel.\n"]
  
  val name_of_input : in_channel -> string[@@ocaml.doc
                                            " [Scanning.name_of_input ic] returns the name of the character source\n    for the given {!Scanning.in_channel} formatted input channel.\n    @since 3.09.0\n"]
  
  val stdib : in_channel[@@ocaml.deprecated
                          "Use Scanf.Scanning.stdin instead."][@@ocaml.doc
                                                                " A deprecated alias for {!Scanning.stdin}, the scanning buffer reading from\n    {!Stdlib.stdin}.\n"]
  
end

[@@@ocaml.text " {1 Type of formatted input functions} "]

type ('a, 'b, 'c, 'd) scanner =
('a, Scanning.in_channel, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c[@@ocaml.doc
                                                               " The type of formatted input scanners: [('a, 'b, 'c, 'd) scanner]\n    is the type of a formatted input function that reads from some\n    formatted input channel according to some format string; more\n    precisely, if [scan] is some formatted input function, then [scan\n    ic fmt f] applies [f] to all the arguments specified by format\n    string [fmt], when [scan] has read those arguments from the\n    {!Scanning.in_channel} formatted input channel [ic].\n\n    For instance, the {!Scanf.scanf} function below has type\n    [('a, 'b, 'c, 'd) scanner], since it is a formatted input function that\n    reads from {!Scanning.stdin}: [scanf fmt f] applies [f] to the arguments\n    specified by [fmt], reading those arguments from {!Stdlib.stdin} as\n    expected.\n\n    If the format [fmt] has some [%r] indications, the corresponding\n    formatted input functions must be provided {e before} receiver function\n    [f]. For instance, if [read_elem] is an input function for values of type\n    [t], then [bscanf ic \"%r;\" read_elem f] reads a value [v] of type [t]\n    followed by a [';'] character, and returns [f v].\n    @since 3.10.0\n"]
  

exception Scan_failure of string
  [@ocaml.doc
    " When the input can not be read according to the format string\n    specification, formatted input functions typically raise exception\n    [Scan_failure].\n"]

[@@@ocaml.text " {1 The general formatted input function} "]

val bscanf : Scanning.in_channel -> ('a, 'b, 'c, 'd) scanner


[@@@ocaml.text
  " [bscanf ic fmt r1 ... rN f] reads characters from the\n    {!Scanning.in_channel} formatted input channel [ic] and converts them to\n    values according to format string [fmt].\n    As a final step, receiver function [f] is applied to the values read and\n    gives the result of the [bscanf] call.\n\n    For instance, if [f] is the function [fun s i -> i + 1], then\n    [Scanf.sscanf \"x= 1\" \"%s = %i\" f] returns [2].\n\n    Arguments [r1] to [rN] are user-defined input functions that read the\n    argument corresponding to the [%r] conversions specified in the format\n    string.\n"]

[@@@ocaml.text " {1 Format string description} "]

[@@@ocaml.text
  " The format string is a character string which contains three types of\n    objects:\n    - plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see {!Scanf.space}),\n    - conversion specifications, each of which causes reading and conversion of\n      one argument for the function [f] (see {!Scanf.conversion}),\n    - scanning indications to specify boundaries of tokens\n      (see scanning {!Scanf.indication}).\n"]

[@@@ocaml.text " {2:space The space character in format strings} "]

[@@@ocaml.text
  " As mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character ([' '] or ASCII code\n    32) and the line feed character (['\\n'] or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    'whitespace' in the input. More precisely, a space inside the format\n    string matches {e any number} of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n\n    Matching {e any} amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call [bscanf ib\n    \"Price = %d $\" (fun p -> p)] succeeds and returns [1] when reading an\n    input with various whitespace in it, such as [Price = 1 $],\n    [Price  =  1    $], or even [Price=1$].\n"]

[@@@ocaml.text
  " {2:conversion Conversion specifications in format strings} "]

[@@@ocaml.text
  " Conversion specifications consist in the [%] character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters.\n\n    The conversion characters and their meanings are:\n\n    - [d]: reads an optionally signed decimal integer ([0-9]+).\n    - [i]: reads an optionally signed integer\n      (usual input conventions for decimal ([0-9]+), hexadecimal\n       ([0x[0-9a-f]+] and [0X[0-9A-F]+]), octal ([0o[0-7]+]), and binary\n       ([0b[0-1]+]) notations are understood).\n    - [u]: reads an unsigned decimal integer.\n    - [x] or [X]: reads an unsigned hexadecimal integer ([[0-9a-fA-F]+]).\n    - [o]: reads an unsigned octal integer ([[0-7]+]).\n    - [s]: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: {ul\n      {- a whitespace has been found (see {!Scanf.space}),}\n      {- a scanning indication (see scanning {!Scanf.indication}) has been\n         encountered,}\n      {- the end-of-input has been reached.}}\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.\n    - [S]: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).\n    - [c]: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification [%0c]. Raise [Invalid_argument], if the field width\n      specification is greater than 1.\n    - [C]: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).\n    - [f], [e], [E], [g], [G]: reads an optionally signed\n      floating-point number in decimal notation, in the style [dddd.ddd\n      e/E+-dd].\n    - [h], [H]: reads an optionally signed floating-point number\n      in hexadecimal notation.\n    - [F]: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).\n    - [B]: reads a boolean argument ([true] or [false]).\n    - [b]: reads a boolean argument (for backward compatibility; do not use\n      in new programs).\n    - [ld], [li], [lu], [lx], [lX], [lo]: reads an [int32] argument to\n      the format specified by the second letter for regular integers.\n    - [nd], [ni], [nu], [nx], [nX], [no]: reads a [nativeint] argument to\n      the format specified by the second letter for regular integers.\n    - [Ld], [Li], [Lu], [Lx], [LX], [Lo]: reads an [int64] argument to\n      the format specified by the second letter for regular integers.\n    - [[ range ]]: reads characters that matches one of the characters\n      mentioned in the range of characters [range] (or not mentioned in\n      it, if the range starts with [^]). Reads a [string] that can be\n      empty, if the next input character does not match the range. The set of\n      characters from [c1] to [c2] (inclusively) is denoted by [c1-c2].\n      Hence, [%[0-9]] returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      [%[0-9a-f]] returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the [^] in case of\n      range negation); hence [[\\]]] matches a [\\]] character and\n      [[^\\]]] matches any character that is not [\\]].\n      Use [%%] and [%@] to include a [%] or a [@] in a range.\n    - [r]: user-defined reader. Takes the next [ri] formatted input\n      function and applies it to the scanning buffer [ib] to read the\n      next argument. The input function [ri] must therefore have type\n      [Scanning.in_channel -> 'a] and the argument read has type ['a].\n    - [{ fmt %}]: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      [fmt]. For instance, [\"%{ %i %}\"] reads any format string that\n      can read a value of type [int]; hence, if [s] is the string\n      [\"fmt:\\\"number is %u\\\"\"], then [Scanf.sscanf s \"fmt: %{%i%}\"]\n      succeeds and returns the format string [\"number is %u\"].\n    - [( fmt %)]: scanning sub-format substitution.\n      Reads a format string [rf] in the input, then goes on scanning with\n      [rf] instead of scanning with [fmt].\n      The format string [rf] must have the same type as the format string\n      specification [fmt] that it replaces.\n      For instance, [\"%( %i %)\"] reads any format string that can read a value\n      of type [int].\n      The conversion returns the format string read [rf], and then a value\n      read using [rf].\n      Hence, if [s] is the string [\"\\\"%4d\\\"1234.00\"], then\n      [Scanf.sscanf s \"%(%i%)\" (fun fmt i -> fmt, i)] evaluates to\n      [(\"%4d\", 1234)].\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag [_] to discard the\n      extraneous argument: conversion [%_( fmt %)] reads a format string\n      [rf] and then behaves the same as format string [rf].  Hence, if [s] is\n      the string [\"\\\"%4d\\\"1234.00\"], then [Scanf.sscanf s \"%_(%i%)\"] is\n      simply equivalent to [Scanf.sscanf \"1234.00\" \"%4d\"].\n    - [l]: returns the number of lines read so far.\n    - [n]: returns the number of characters read so far.\n    - [N] or [L]: returns the number of tokens read so far.\n    - [!]: matches the end of input condition.\n    - [%]: matches one [%] character in the input.\n    - [@]: matches one [@] character in the input.\n    - [,]: does nothing.\n\n    Following the [%] character that introduces a conversion, there may be\n    the special flag [_]: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if [f] is the function [fun i -> i + 1], and [s] is the\n    string [\"x = 1\"], then [Scanf.sscanf s \"%_s = %i\" f] returns [2].\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, [%6d] reads an integer, having at most 6 decimal digits;\n    [%4f] reads a float with at most 4 characters; and [%8[\\000-\\255]]\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n\n    Notes:\n\n    - as mentioned above, a [%s] conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns [\"\"].\n\n    - in addition to the relevant digits, ['_'] characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.\n\n    - the [scanf] facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    {!Str}), stream parsers, [ocamllex]-generated lexers,\n    [ocamlyacc]-generated parsers.\n"]

[@@@ocaml.text " {2:indication Scanning indications in format strings} "]

[@@@ocaml.text
  " Scanning indications appear just after the string conversions [%s]\n    and [%[ range ]] to delimit the end of the token. A scanning\n    indication is introduced by a [@] character, followed by some\n    plain character [c]. It means that the string token should end\n    just before the next matching [c] (which is skipped). If no [c]\n    character is encountered, the string token spreads as much as\n    possible. For instance, [\"%s@\\t\"] reads a string up to the next\n    tab character or to the end of input. If a [@] character appears\n    anywhere else in the format string, it is treated as a plain character.\n\n    Note:\n\n    - As usual in format strings, [%] and [@] characters must be escaped\n    using [%%] and [%@]; this rule still holds within range specifications\n    and scanning indications.\n    For instance, format [\"%s@%%\"] reads a string up to the next [%]\n    character, and format [\"%s@%@\"] reads a string up to the next [@].\n    - The scanning indications introduce slight differences in the syntax of\n    {!Scanf} format strings, compared to those used for the {!Printf}\n    module. However, the scanning indications are similar to those used in\n    the {!Format} module; hence, when producing formatted text to be scanned\n    by {!Scanf.bscanf}, it is wise to use printing functions from the\n    {!Format} module (or, if you need to use functions from {!Printf}, banish\n    or carefully double check the format strings that contain ['@']\n    characters).\n"]

[@@@ocaml.text " {2 Exceptions during scanning} "]

[@@@ocaml.text
  " Scanners may raise the following exceptions when the input cannot be read\n    according to the format string:\n\n    - Raise {!Scanf.Scan_failure} if the input does not match the format.\n\n    - Raise [Failure] if a conversion to a number is not possible.\n\n    - Raise [End_of_file] if the end of input is encountered while some more\n      characters are needed to read the current conversion specification.\n\n    - Raise [Invalid_argument] if the format string is invalid.\n\n    Note:\n\n    - as a consequence, scanning a [%s] conversion never raises exception\n    [End_of_file]: if the end of input is reached the conversion succeeds and\n    simply returns the characters read so far, or [\"\"] if none were ever read.\n"]

[@@@ocaml.text " {1 Specialised formatted input functions} "]

val sscanf : string -> ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                                 " Same as {!Scanf.bscanf}, but reads from the given string. "]


val scanf : ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                      " Same as {!Scanf.bscanf}, but reads from the predefined formatted input\n    channel {!Scanf.Scanning.stdin} that is connected to {!Stdlib.stdin}.\n"]


val kscanf :
  Scanning.in_channel ->
    (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner[@@ocaml.doc
                                                                    " Same as {!Scanf.bscanf}, but takes an additional function argument\n    [ef] that is called in case of error: if the scanning process or\n    some conversion fails, the scanning function aborts and calls the\n    error handling function [ef] with the formatted input channel and the\n    exception that aborted the scanning process as arguments.\n"]


val ksscanf :
  string -> (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner
[@@ocaml.doc
  " Same as {!Scanf.kscanf} but reads from the given string.\n    @since 4.02.0 "]


[@@@ocaml.text " {1 Reading format strings from input} "]

val bscanf_format :
  Scanning.in_channel ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g[@@ocaml.doc
                                                      " [bscanf_format ic fmt f] reads a format string token from the formatted\n    input channel [ic], according to the given format string [fmt], and\n    applies [f] to the resulting format string value.\n    Raise {!Scan_failure} if the format string value read does not have the\n    same type as [fmt].\n    @since 3.09.0\n"]


val sscanf_format :
  string ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
      (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g[@@ocaml.doc
                                                      " Same as {!Scanf.bscanf_format}, but reads from the given string.\n    @since 3.09.0\n"]


val format_from_string :
  string ->
    ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6
[@@ocaml.doc
  " [format_from_string s fmt] converts a string argument to a format string,\n    according to the given format string [fmt].\n    Raise {!Scan_failure} if [s], considered as a format string, does not\n    have the same type as [fmt].\n    @since 3.10.0\n"]


val unescaped : string -> string[@@ocaml.doc
                                  " [unescaped s] return a copy of [s] with escape sequences (according to\n    the lexical conventions of OCaml) replaced by their corresponding special\n    characters.\n    More precisely, [Scanf.unescaped] has the following property:\n    for all string [s], [Scanf.unescaped (String.escaped s) = s].\n\n    Always return a copy of the argument, even if there is no escape sequence\n    in the argument.\n    Raise {!Scan_failure} if [s] is not properly escaped (i.e. [s] has invalid\n    escape sequences or special characters that are not properly escaped).\n    For instance, [String.unescaped \"\\\"\"] will fail.\n    @since 4.00.0\n"]


[@@@ocaml.text " {1 Deprecated} "]

val fscanf : Stdlib.in_channel -> ('a, 'b, 'c, 'd) scanner[@@ocaml.deprecated
                                                            "Use Scanning.from_channel then Scanf.bscanf."]
[@@ocaml.doc
  " @deprecated [Scanf.fscanf] is error prone and deprecated since 4.03.0.\n\n    This function violates the following invariant of the {!Scanf} module:\n    To preserve scanning semantics, all scanning functions defined in {!Scanf}\n    must read from a user defined {!Scanning.in_channel} formatted input\n    channel.\n\n    If you need to read from a {!Stdlib.in_channel} input channel\n    [ic], simply define a {!Scanning.in_channel} formatted input channel as in\n    [let ib = Scanning.from_channel ic],\n    then use [Scanf.bscanf ib] as usual.\n"]


val kfscanf :
  Stdlib.in_channel ->
    (Scanning.in_channel -> exn -> 'd) -> ('a, 'b, 'c, 'd) scanner[@@ocaml.deprecated
                                                                    "Use Scanning.from_channel then Scanf.kscanf."]
[@@ocaml.doc
  " @deprecated [Scanf.kfscanf] is error prone and deprecated since 4.03.0. "]

gospel: internal error, uncaught exception:
        File "gospel/ocaml-lib/typing.ml", line 425, characters 7-13: Assertion failed
        
