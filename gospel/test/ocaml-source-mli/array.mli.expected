
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text " Array operations. "]
external length : 'a array -> int = "%array_length"[@@ocaml.doc
                                                     " Return the length (number of elements) of the given array. "]
external get : 'a array -> int -> 'a = "%array_safe_get"[@@ocaml.doc
                                                          " [Array.get a n] returns the element number [n] of array [a].\n   The first element has number 0.\n   The last element has number [Array.length a - 1].\n   You can also write [a.(n)] instead of [Array.get a n].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [(Array.length a - 1)]. "]
external set : 'a array -> int -> 'a -> unit = "%array_safe_set"[@@ocaml.doc
                                                                  " [Array.set a n x] modifies array [a] in place, replacing\n   element number [n] with [x].\n   You can also write [a.(n) <- x] instead of [Array.set a n x].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [Array.length a - 1]. "]
external make : int -> 'a -> 'a array = "caml_make_vect"[@@ocaml.doc
                                                          " [Array.make n x] returns a fresh array of length [n],\n   initialized with [x].\n   All the elements of this new array are initially\n   physically equal to [x] (in the sense of the [==] predicate).\n   Consequently, if [x] is mutable, it is shared among all elements\n   of the array, and modifying [x] through one of the array entries\n   will modify all other entries at the same time.\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the value of [x] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]."]
external create : int -> 'a -> 'a array = "caml_make_vect"[@@ocaml.deprecated
                                                            "Use Array.make instead."]
[@@ocaml.doc " @deprecated [Array.create] is an alias for {!Array.make}. "]
external create_float : int -> float array = "caml_make_float_vect"[@@ocaml.doc
                                                                    " [Array.create_float n] returns a fresh float array of length [n],\n    with uninitialized data.\n    @since 4.03 "]
val make_float : int -> float array[@@ocaml.deprecated
                                     "Use Array.create_float instead."]
[@@ocaml.doc
  " @deprecated [Array.make_float] is an alias for {!Array.create_float}. "]
val init : int -> (int -> 'a) -> 'a array[@@ocaml.doc
                                           " [Array.init n f] returns a fresh array of length [n],\n   with element number [i] initialized to the result of [f i].\n   In other terms, [Array.init n f] tabulates the results of [f]\n   applied to the integers [0] to [n-1].\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the return type of [f] is [float], then the maximum\n   size is only [Sys.max_array_length / 2]."]
val make_matrix : int -> int -> 'a -> 'a array array[@@ocaml.doc
                                                      " [Array.make_matrix dimx dimy e] returns a two-dimensional array\n   (an array of arrays) with first dimension [dimx] and\n   second dimension [dimy]. All the elements of this new matrix\n   are initially physically equal to [e].\n   The element ([x,y]) of a matrix [m] is accessed\n   with the notation [m.(x).(y)].\n\n   Raise [Invalid_argument] if [dimx] or [dimy] is negative or\n   greater than {!Sys.max_array_length}.\n   If the value of [e] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]. "]
val create_matrix : int -> int -> 'a -> 'a array array[@@ocaml.deprecated
                                                        "Use Array.make_matrix instead."]
[@@ocaml.doc
  " @deprecated [Array.create_matrix] is an alias for {!Array.make_matrix}. "]
val append : 'a array -> 'a array -> 'a array[@@ocaml.doc
                                               " [Array.append v1 v2] returns a fresh array containing the\n   concatenation of the arrays [v1] and [v2]. "]
val concat : 'a array list -> 'a array[@@ocaml.doc
                                        " Same as {!Array.append}, but concatenates a list of arrays. "]
val sub : 'a array -> int -> int -> 'a array[@@ocaml.doc
                                              " [Array.sub a start len] returns a fresh array of length [len],\n   containing the elements number [start] to [start + len - 1]\n   of array [a].\n\n   Raise [Invalid_argument \"Array.sub\"] if [start] and [len] do not\n   designate a valid subarray of [a]; that is, if\n   [start < 0], or [len < 0], or [start + len > Array.length a]. "]
val copy : 'a array -> 'a array[@@ocaml.doc
                                 " [Array.copy a] returns a copy of [a], that is, a fresh array\n   containing the same elements as [a]. "]
val fill : 'a array -> int -> int -> 'a -> unit[@@ocaml.doc
                                                 " [Array.fill a ofs len x] modifies the array [a] in place,\n   storing [x] in elements number [ofs] to [ofs + len - 1].\n\n   Raise [Invalid_argument \"Array.fill\"] if [ofs] and [len] do not\n   designate a valid subarray of [a]. "]
val blit : 'a array -> int -> 'a array -> int -> int -> unit[@@ocaml.doc
                                                              " [Array.blit v1 o1 v2 o2 len] copies [len] elements\n   from array [v1], starting at element number [o1], to array [v2],\n   starting at element number [o2]. It works correctly even if\n   [v1] and [v2] are the same array, and the source and\n   destination chunks overlap.\n\n   Raise [Invalid_argument \"Array.blit\"] if [o1] and [len] do not\n   designate a valid subarray of [v1], or if [o2] and [len] do not\n   designate a valid subarray of [v2]. "]
val to_list : 'a array -> 'a list[@@ocaml.doc
                                   " [Array.to_list a] returns the list of all the elements of [a]. "]
val of_list : 'a list -> 'a array[@@ocaml.doc
                                   " [Array.of_list l] returns a fresh array containing the elements\n   of [l]. "]
[@@@ocaml.text " {1 Iterators} "]
val iter : ('a -> unit) -> 'a array -> unit[@@ocaml.doc
                                             " [Array.iter f a] applies function [f] in turn to all\n   the elements of [a].  It is equivalent to\n   [f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()]. "]
val iteri : (int -> 'a -> unit) -> 'a array -> unit[@@ocaml.doc
                                                     " Same as {!Array.iter}, but the\n   function is applied with the index of the element as first argument,\n   and the element itself as second argument. "]
val map : ('a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                              " [Array.map f a] applies function [f] to all the elements of [a],\n   and builds an array with the results returned by [f]:\n   [[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]]. "]
val mapi : (int -> 'a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                                      " Same as {!Array.map}, but the\n   function is applied to the index of the element as first argument,\n   and the element itself as second argument. "]
val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b array -> 'a[@@ocaml.doc
                                                          " [Array.fold_left f x a] computes\n   [f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)],\n   where [n] is the length of the array [a]. "]
val fold_right : ('b -> 'a -> 'a) -> 'b array -> 'a -> 'a[@@ocaml.doc
                                                           " [Array.fold_right f a x] computes\n   [f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))],\n   where [n] is the length of the array [a]. "]
[@@@ocaml.text " {1 Iterators on two arrays} "]
val iter2 : ('a -> 'b -> unit) -> 'a array -> 'b array -> unit[@@ocaml.doc
                                                                " [Array.iter2 f a b] applies function [f] to all the elements of [a]\n   and [b].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]
val map2 : ('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array[@@ocaml.doc
                                                                 " [Array.map2 f a b] applies function [f] to all the elements of [a]\n   and [b], and builds an array with the results returned by [f]:\n   [[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]
[@@@ocaml.text " {1 Array scanning} "]
val for_all : ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                                " [Array.for_all p [|a1; ...; an|]] checks if all elements of the array\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)].\n   @since 4.03.0 "]
val exists : ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                               " [Array.exists p [|a1; ...; an|]] checks if at least one element of\n    the array satisfies the predicate [p]. That is, it returns\n    [(p a1) || (p a2) || ... || (p an)].\n    @since 4.03.0 "]
val mem : 'a -> 'a array -> bool[@@ocaml.doc
                                  " [mem a l] is true if and only if [a] is equal\n   to an element of [l].\n   @since 4.03.0 "]
val memq : 'a -> 'a array -> bool[@@ocaml.doc
                                   " Same as {!Array.mem}, but uses physical equality instead of structural\n   equality to compare array elements.\n   @since 4.03.0 "]
[@@@ocaml.text " {1 Sorting} "]
val sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                  " Sort an array in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see below for a\n   complete specification).  For example, {!Stdlib.compare} is\n   a suitable comparison function, provided there are no floating-point\n   NaN values in the data.  After calling [Array.sort], the\n   array is sorted in place in increasing order.\n   [Array.sort] is guaranteed to run in constant heap space\n   and (at most) logarithmic stack space.\n\n   The current implementation uses Heap Sort.  It runs in constant\n   stack space.\n\n   Specification of the comparison function:\n   Let [a] be the array and [cmp] the comparison function.  The following\n   must be true for all x, y, z in a :\n-   [cmp x y] > 0 if and only if [cmp y x] < 0\n-   if [cmp x y] >= 0 and [cmp y z] >= 0 then [cmp x z] >= 0\n\n   When [Array.sort] returns, [a] contains the same elements as before,\n   reordered in such a way that for all i and j valid indices of [a] :\n-   [cmp a.(i) a.(j)] >= 0 if and only if i >= j\n"]
val stable_sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                         " Same as {!Array.sort}, but the sorting algorithm is stable (i.e.\n   elements that compare equal are kept in their original order) and\n   not guaranteed to run in constant heap space.\n\n   The current implementation uses Merge Sort. It uses [n/2]\n   words of heap space, where [n] is the length of the array.\n   It is usually faster than the current implementation of {!Array.sort}.\n"]
val fast_sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                       " Same as {!Array.sort} or {!Array.stable_sort}, whichever is faster\n    on typical input.\n"]
[@@@ocaml.text " {6 Iterators} "]
val to_seq : 'a array -> 'a Seq.t[@@ocaml.doc
                                   " Iterate on the array, in increasing order. Modifications of the\n    array during iteration will be reflected in the iterator.\n    @since 4.07 "]
val to_seqi : 'a array -> (int * 'a) Seq.t[@@ocaml.doc
                                            " Iterate on the array, in increasing order, yielding indices along elements.\n    Modifications of the array during iteration will be reflected in the\n    iterator.\n    @since 4.07 "]
val of_seq : 'a Seq.t -> 'a array[@@ocaml.doc
                                   " Create an array from the generator\n    @since 4.07 "]
[@@@ocaml.text "/*"]
[@@@ocaml.text " {1 Undocumented functions} "]
external unsafe_get : 'a array -> int -> 'a = "%array_unsafe_get"
external unsafe_set : 'a array -> int -> 'a -> unit = "%array_unsafe_set"
module Floatarray :
sig
  external create : int -> floatarray = "caml_floatarray_create"
  external length : floatarray -> int = "%floatarray_length"
  external get : floatarray -> int -> float = "%floatarray_safe_get"
  external set : floatarray -> int -> float -> unit = "%floatarray_safe_set"
  external unsafe_get : floatarray -> int -> float = "%floatarray_unsafe_get"
  external unsafe_set :
    floatarray -> int -> float -> unit = "%floatarray_unsafe_set"
end

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text " Array operations. "]

external length : 'a array -> int = "%array_length"[@@ocaml.doc
                                                     " Return the length (number of elements) of the given array. "]


external get : 'a array -> int -> 'a = "%array_safe_get"[@@ocaml.doc
                                                          " [Array.get a n] returns the element number [n] of array [a].\n   The first element has number 0.\n   The last element has number [Array.length a - 1].\n   You can also write [a.(n)] instead of [Array.get a n].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [(Array.length a - 1)]. "]


external set : 'a array -> int -> 'a -> unit = "%array_safe_set"[@@ocaml.doc
                                                                  " [Array.set a n x] modifies array [a] in place, replacing\n   element number [n] with [x].\n   You can also write [a.(n) <- x] instead of [Array.set a n x].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [Array.length a - 1]. "]


external make : int -> 'a -> 'a array = "caml_make_vect"[@@ocaml.doc
                                                          " [Array.make n x] returns a fresh array of length [n],\n   initialized with [x].\n   All the elements of this new array are initially\n   physically equal to [x] (in the sense of the [==] predicate).\n   Consequently, if [x] is mutable, it is shared among all elements\n   of the array, and modifying [x] through one of the array entries\n   will modify all other entries at the same time.\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the value of [x] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]."]


external create : int -> 'a -> 'a array = "caml_make_vect"[@@ocaml.deprecated
                                                            "Use Array.make instead."]
[@@ocaml.doc " @deprecated [Array.create] is an alias for {!Array.make}. "]


external create_float : int -> float array = "caml_make_float_vect"[@@ocaml.doc
                                                                    " [Array.create_float n] returns a fresh float array of length [n],\n    with uninitialized data.\n    @since 4.03 "]


val make_float : int -> float array[@@ocaml.deprecated
                                     "Use Array.create_float instead."]
[@@ocaml.doc
  " @deprecated [Array.make_float] is an alias for {!Array.create_float}. "]


val init : int -> (int -> 'a) -> 'a array[@@ocaml.doc
                                           " [Array.init n f] returns a fresh array of length [n],\n   with element number [i] initialized to the result of [f i].\n   In other terms, [Array.init n f] tabulates the results of [f]\n   applied to the integers [0] to [n-1].\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the return type of [f] is [float], then the maximum\n   size is only [Sys.max_array_length / 2]."]


val make_matrix : int -> int -> 'a -> 'a array array[@@ocaml.doc
                                                      " [Array.make_matrix dimx dimy e] returns a two-dimensional array\n   (an array of arrays) with first dimension [dimx] and\n   second dimension [dimy]. All the elements of this new matrix\n   are initially physically equal to [e].\n   The element ([x,y]) of a matrix [m] is accessed\n   with the notation [m.(x).(y)].\n\n   Raise [Invalid_argument] if [dimx] or [dimy] is negative or\n   greater than {!Sys.max_array_length}.\n   If the value of [e] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]. "]


val create_matrix : int -> int -> 'a -> 'a array array[@@ocaml.deprecated
                                                        "Use Array.make_matrix instead."]
[@@ocaml.doc
  " @deprecated [Array.create_matrix] is an alias for {!Array.make_matrix}. "]


val append : 'a array -> 'a array -> 'a array[@@ocaml.doc
                                               " [Array.append v1 v2] returns a fresh array containing the\n   concatenation of the arrays [v1] and [v2]. "]


val concat : 'a array list -> 'a array[@@ocaml.doc
                                        " Same as {!Array.append}, but concatenates a list of arrays. "]


val sub : 'a array -> int -> int -> 'a array[@@ocaml.doc
                                              " [Array.sub a start len] returns a fresh array of length [len],\n   containing the elements number [start] to [start + len - 1]\n   of array [a].\n\n   Raise [Invalid_argument \"Array.sub\"] if [start] and [len] do not\n   designate a valid subarray of [a]; that is, if\n   [start < 0], or [len < 0], or [start + len > Array.length a]. "]


val copy : 'a array -> 'a array[@@ocaml.doc
                                 " [Array.copy a] returns a copy of [a], that is, a fresh array\n   containing the same elements as [a]. "]


val fill : 'a array -> int -> int -> 'a -> unit[@@ocaml.doc
                                                 " [Array.fill a ofs len x] modifies the array [a] in place,\n   storing [x] in elements number [ofs] to [ofs + len - 1].\n\n   Raise [Invalid_argument \"Array.fill\"] if [ofs] and [len] do not\n   designate a valid subarray of [a]. "]


val blit : 'a array -> int -> 'a array -> int -> int -> unit[@@ocaml.doc
                                                              " [Array.blit v1 o1 v2 o2 len] copies [len] elements\n   from array [v1], starting at element number [o1], to array [v2],\n   starting at element number [o2]. It works correctly even if\n   [v1] and [v2] are the same array, and the source and\n   destination chunks overlap.\n\n   Raise [Invalid_argument \"Array.blit\"] if [o1] and [len] do not\n   designate a valid subarray of [v1], or if [o2] and [len] do not\n   designate a valid subarray of [v2]. "]


val to_list : 'a array -> 'a list[@@ocaml.doc
                                   " [Array.to_list a] returns the list of all the elements of [a]. "]


val of_list : 'a list -> 'a array[@@ocaml.doc
                                   " [Array.of_list l] returns a fresh array containing the elements\n   of [l]. "]


[@@@ocaml.text " {1 Iterators} "]

val iter : ('a -> unit) -> 'a array -> unit[@@ocaml.doc
                                             " [Array.iter f a] applies function [f] in turn to all\n   the elements of [a].  It is equivalent to\n   [f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()]. "]


val iteri : (int -> 'a -> unit) -> 'a array -> unit[@@ocaml.doc
                                                     " Same as {!Array.iter}, but the\n   function is applied with the index of the element as first argument,\n   and the element itself as second argument. "]


val map : ('a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                              " [Array.map f a] applies function [f] to all the elements of [a],\n   and builds an array with the results returned by [f]:\n   [[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]]. "]


val mapi : (int -> 'a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                                      " Same as {!Array.map}, but the\n   function is applied to the index of the element as first argument,\n   and the element itself as second argument. "]


val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b array -> 'a[@@ocaml.doc
                                                          " [Array.fold_left f x a] computes\n   [f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)],\n   where [n] is the length of the array [a]. "]


val fold_right : ('b -> 'a -> 'a) -> 'b array -> 'a -> 'a[@@ocaml.doc
                                                           " [Array.fold_right f a x] computes\n   [f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))],\n   where [n] is the length of the array [a]. "]


[@@@ocaml.text " {1 Iterators on two arrays} "]

val iter2 : ('a -> 'b -> unit) -> 'a array -> 'b array -> unit[@@ocaml.doc
                                                                " [Array.iter2 f a b] applies function [f] to all the elements of [a]\n   and [b].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]


val map2 : ('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array[@@ocaml.doc
                                                                 " [Array.map2 f a b] applies function [f] to all the elements of [a]\n   and [b], and builds an array with the results returned by [f]:\n   [[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]


[@@@ocaml.text " {1 Array scanning} "]

val for_all : ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                                " [Array.for_all p [|a1; ...; an|]] checks if all elements of the array\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)].\n   @since 4.03.0 "]


val exists : ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                               " [Array.exists p [|a1; ...; an|]] checks if at least one element of\n    the array satisfies the predicate [p]. That is, it returns\n    [(p a1) || (p a2) || ... || (p an)].\n    @since 4.03.0 "]


val mem : 'a -> 'a array -> bool[@@ocaml.doc
                                  " [mem a l] is true if and only if [a] is equal\n   to an element of [l].\n   @since 4.03.0 "]


val memq : 'a -> 'a array -> bool[@@ocaml.doc
                                   " Same as {!Array.mem}, but uses physical equality instead of structural\n   equality to compare array elements.\n   @since 4.03.0 "]


[@@@ocaml.text " {1 Sorting} "]

val sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                  " Sort an array in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see below for a\n   complete specification).  For example, {!Stdlib.compare} is\n   a suitable comparison function, provided there are no floating-point\n   NaN values in the data.  After calling [Array.sort], the\n   array is sorted in place in increasing order.\n   [Array.sort] is guaranteed to run in constant heap space\n   and (at most) logarithmic stack space.\n\n   The current implementation uses Heap Sort.  It runs in constant\n   stack space.\n\n   Specification of the comparison function:\n   Let [a] be the array and [cmp] the comparison function.  The following\n   must be true for all x, y, z in a :\n-   [cmp x y] > 0 if and only if [cmp y x] < 0\n-   if [cmp x y] >= 0 and [cmp y z] >= 0 then [cmp x z] >= 0\n\n   When [Array.sort] returns, [a] contains the same elements as before,\n   reordered in such a way that for all i and j valid indices of [a] :\n-   [cmp a.(i) a.(j)] >= 0 if and only if i >= j\n"]


val stable_sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                         " Same as {!Array.sort}, but the sorting algorithm is stable (i.e.\n   elements that compare equal are kept in their original order) and\n   not guaranteed to run in constant heap space.\n\n   The current implementation uses Merge Sort. It uses [n/2]\n   words of heap space, where [n] is the length of the array.\n   It is usually faster than the current implementation of {!Array.sort}.\n"]


val fast_sort : ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                                       " Same as {!Array.sort} or {!Array.stable_sort}, whichever is faster\n    on typical input.\n"]


[@@@ocaml.text " {6 Iterators} "]

val to_seq : 'a array -> 'a Seq.t[@@ocaml.doc
                                   " Iterate on the array, in increasing order. Modifications of the\n    array during iteration will be reflected in the iterator.\n    @since 4.07 "]


val to_seqi : 'a array -> (int * 'a) Seq.t[@@ocaml.doc
                                            " Iterate on the array, in increasing order, yielding indices along elements.\n    Modifications of the array during iteration will be reflected in the\n    iterator.\n    @since 4.07 "]


val of_seq : 'a Seq.t -> 'a array[@@ocaml.doc
                                   " Create an array from the generator\n    @since 4.07 "]


[@@@ocaml.text "/*"]

[@@@ocaml.text " {1 Undocumented functions} "]

external unsafe_get : 'a array -> int -> 'a = "%array_unsafe_get"


external unsafe_set : 'a array -> int -> 'a -> unit = "%array_unsafe_set"


module Floatarray :
sig
  external create : int -> floatarray = "caml_floatarray_create"
  
  external length : floatarray -> int = "%floatarray_length"
  
  external get : floatarray -> int -> float = "%floatarray_safe_get"
  
  external set : floatarray -> int -> float -> unit = "%floatarray_safe_set"
  
  external unsafe_get : floatarray -> int -> float = "%floatarray_unsafe_get"
  
  external unsafe_set :
    floatarray -> int -> float -> unit = "%floatarray_unsafe_set"
  
end

*******************************
********* Typed GOSPEL ********
*******************************
module array.mli

  Namespace: array.mli
    Type symbols
      
    Logic Symbols
      
    Exception Symbols
      
    Namespaces
      Namespace: Floatarray
        Type symbols
          
        Logic Symbols
          
        Exception Symbols
          
        Namespaces
          
        Type Namespaces
          
      
    Type Namespaces
      
  Signatures
    (*@ open Gospelstdlib *)
    
    [@@@ocaml.text " Array operations. "]
    
    external length : 'a array -> int =
    "%array_length"[@@ocaml.doc
                     " Return the length (number of elements) of the given array. "]
    
    
    external get : 'a array -> int -> 'a =
    "%array_safe_get"[@@ocaml.doc
                       " [Array.get a n] returns the element number [n] of array [a].\n   The first element has number 0.\n   The last element has number [Array.length a - 1].\n   You can also write [a.(n)] instead of [Array.get a n].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [(Array.length a - 1)]. "]
    
    
    external set : 'a array -> int -> 'a -> unit =
    "%array_safe_set"[@@ocaml.doc
                       " [Array.set a n x] modifies array [a] in place, replacing\n   element number [n] with [x].\n   You can also write [a.(n) <- x] instead of [Array.set a n x].\n\n   Raise [Invalid_argument \"index out of bounds\"]\n   if [n] is outside the range 0 to [Array.length a - 1]. "]
    
    
    external make : int -> 'a -> 'a array =
    "caml_make_vect"[@@ocaml.doc
                      " [Array.make n x] returns a fresh array of length [n],\n   initialized with [x].\n   All the elements of this new array are initially\n   physically equal to [x] (in the sense of the [==] predicate).\n   Consequently, if [x] is mutable, it is shared among all elements\n   of the array, and modifying [x] through one of the array entries\n   will modify all other entries at the same time.\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the value of [x] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]."]
    
    
    external create : int -> 'a -> 'a array =
    "caml_make_vect"[@@ocaml.deprecated "Use Array.make instead."][@@ocaml.doc
                                                                    " @deprecated [Array.create] is an alias for {!Array.make}. "]
    
    
    external create_float : int -> float array =
    "caml_make_float_vect"[@@ocaml.doc
                            " [Array.create_float n] returns a fresh float array of length [n],\n    with uninitialized data.\n    @since 4.03 "]
    
    
    val make_float :
    int -> float array[@@ocaml.deprecated "Use Array.create_float instead."]
    [@@ocaml.doc
      " @deprecated [Array.make_float] is an alias for {!Array.create_float}. "]
    
    
    val init :
    int -> (int -> 'a) -> 'a array[@@ocaml.doc
                                    " [Array.init n f] returns a fresh array of length [n],\n   with element number [i] initialized to the result of [f i].\n   In other terms, [Array.init n f] tabulates the results of [f]\n   applied to the integers [0] to [n-1].\n\n   Raise [Invalid_argument] if [n < 0] or [n > Sys.max_array_length].\n   If the return type of [f] is [float], then the maximum\n   size is only [Sys.max_array_length / 2]."]
    
    
    val make_matrix :
    int -> int -> 'a -> 'a array array[@@ocaml.doc
                                        " [Array.make_matrix dimx dimy e] returns a two-dimensional array\n   (an array of arrays) with first dimension [dimx] and\n   second dimension [dimy]. All the elements of this new matrix\n   are initially physically equal to [e].\n   The element ([x,y]) of a matrix [m] is accessed\n   with the notation [m.(x).(y)].\n\n   Raise [Invalid_argument] if [dimx] or [dimy] is negative or\n   greater than {!Sys.max_array_length}.\n   If the value of [e] is a floating-point number, then the maximum\n   size is only [Sys.max_array_length / 2]. "]
    
    
    val create_matrix :
    int -> int -> 'a -> 'a array array[@@ocaml.deprecated
                                        "Use Array.make_matrix instead."]
    [@@ocaml.doc
      " @deprecated [Array.create_matrix] is an alias for {!Array.make_matrix}. "]
    
    
    val append :
    'a array -> 'a array -> 'a array[@@ocaml.doc
                                      " [Array.append v1 v2] returns a fresh array containing the\n   concatenation of the arrays [v1] and [v2]. "]
    
    
    val concat :
    'a array list -> 'a array[@@ocaml.doc
                               " Same as {!Array.append}, but concatenates a list of arrays. "]
    
    
    val sub :
    'a array -> int -> int -> 'a array[@@ocaml.doc
                                        " [Array.sub a start len] returns a fresh array of length [len],\n   containing the elements number [start] to [start + len - 1]\n   of array [a].\n\n   Raise [Invalid_argument \"Array.sub\"] if [start] and [len] do not\n   designate a valid subarray of [a]; that is, if\n   [start < 0], or [len < 0], or [start + len > Array.length a]. "]
    
    
    val copy :
    'a array -> 'a array[@@ocaml.doc
                          " [Array.copy a] returns a copy of [a], that is, a fresh array\n   containing the same elements as [a]. "]
    
    
    val fill :
    'a array -> int -> int -> 'a -> unit[@@ocaml.doc
                                          " [Array.fill a ofs len x] modifies the array [a] in place,\n   storing [x] in elements number [ofs] to [ofs + len - 1].\n\n   Raise [Invalid_argument \"Array.fill\"] if [ofs] and [len] do not\n   designate a valid subarray of [a]. "]
    
    
    val blit :
    'a array -> int -> 'a array -> int -> int -> unit[@@ocaml.doc
                                                       " [Array.blit v1 o1 v2 o2 len] copies [len] elements\n   from array [v1], starting at element number [o1], to array [v2],\n   starting at element number [o2]. It works correctly even if\n   [v1] and [v2] are the same array, and the source and\n   destination chunks overlap.\n\n   Raise [Invalid_argument \"Array.blit\"] if [o1] and [len] do not\n   designate a valid subarray of [v1], or if [o2] and [len] do not\n   designate a valid subarray of [v2]. "]
    
    
    val to_list :
    'a array -> 'a list[@@ocaml.doc
                         " [Array.to_list a] returns the list of all the elements of [a]. "]
    
    
    val of_list :
    'a list -> 'a array[@@ocaml.doc
                         " [Array.of_list l] returns a fresh array containing the elements\n   of [l]. "]
    
    
    [@@@ocaml.text " {1 Iterators} "]
    
    val iter :
    ('a -> unit) -> 'a array -> unit[@@ocaml.doc
                                      " [Array.iter f a] applies function [f] in turn to all\n   the elements of [a].  It is equivalent to\n   [f a.(0); f a.(1); ...; f a.(Array.length a - 1); ()]. "]
    
    
    val iteri :
    (int -> 'a -> unit) -> 'a array -> unit[@@ocaml.doc
                                             " Same as {!Array.iter}, but the\n   function is applied with the index of the element as first argument,\n   and the element itself as second argument. "]
    
    
    val map :
    ('a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                        " [Array.map f a] applies function [f] to all the elements of [a],\n   and builds an array with the results returned by [f]:\n   [[| f a.(0); f a.(1); ...; f a.(Array.length a - 1) |]]. "]
    
    
    val mapi :
    (int -> 'a -> 'b) -> 'a array -> 'b array[@@ocaml.doc
                                               " Same as {!Array.map}, but the\n   function is applied to the index of the element as first argument,\n   and the element itself as second argument. "]
    
    
    val fold_left :
    ('a -> 'b -> 'a) -> 'a -> 'b array -> 'a[@@ocaml.doc
                                              " [Array.fold_left f x a] computes\n   [f (... (f (f x a.(0)) a.(1)) ...) a.(n-1)],\n   where [n] is the length of the array [a]. "]
    
    
    val fold_right :
    ('b -> 'a -> 'a) -> 'b array -> 'a -> 'a[@@ocaml.doc
                                              " [Array.fold_right f a x] computes\n   [f a.(0) (f a.(1) ( ... (f a.(n-1) x) ...))],\n   where [n] is the length of the array [a]. "]
    
    
    [@@@ocaml.text " {1 Iterators on two arrays} "]
    
    val iter2 :
    ('a -> 'b -> unit) -> 'a array -> 'b array -> unit[@@ocaml.doc
                                                        " [Array.iter2 f a b] applies function [f] to all the elements of [a]\n   and [b].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]
    
    
    val map2 :
    ('a -> 'b -> 'c) -> 'a array -> 'b array -> 'c array[@@ocaml.doc
                                                          " [Array.map2 f a b] applies function [f] to all the elements of [a]\n   and [b], and builds an array with the results returned by [f]:\n   [[| f a.(0) b.(0); ...; f a.(Array.length a - 1) b.(Array.length b - 1)|]].\n   Raise [Invalid_argument] if the arrays are not the same size.\n   @since 4.03.0 "]
    
    
    [@@@ocaml.text " {1 Array scanning} "]
    
    val for_all :
    ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                      " [Array.for_all p [|a1; ...; an|]] checks if all elements of the array\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)].\n   @since 4.03.0 "]
    
    
    val exists :
    ('a -> bool) -> 'a array -> bool[@@ocaml.doc
                                      " [Array.exists p [|a1; ...; an|]] checks if at least one element of\n    the array satisfies the predicate [p]. That is, it returns\n    [(p a1) || (p a2) || ... || (p an)].\n    @since 4.03.0 "]
    
    
    val mem :
    'a -> 'a array -> bool[@@ocaml.doc
                            " [mem a l] is true if and only if [a] is equal\n   to an element of [l].\n   @since 4.03.0 "]
    
    
    val memq :
    'a -> 'a array -> bool[@@ocaml.doc
                            " Same as {!Array.mem}, but uses physical equality instead of structural\n   equality to compare array elements.\n   @since 4.03.0 "]
    
    
    [@@@ocaml.text " {1 Sorting} "]
    
    val sort :
    ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                           " Sort an array in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see below for a\n   complete specification).  For example, {!Stdlib.compare} is\n   a suitable comparison function, provided there are no floating-point\n   NaN values in the data.  After calling [Array.sort], the\n   array is sorted in place in increasing order.\n   [Array.sort] is guaranteed to run in constant heap space\n   and (at most) logarithmic stack space.\n\n   The current implementation uses Heap Sort.  It runs in constant\n   stack space.\n\n   Specification of the comparison function:\n   Let [a] be the array and [cmp] the comparison function.  The following\n   must be true for all x, y, z in a :\n-   [cmp x y] > 0 if and only if [cmp y x] < 0\n-   if [cmp x y] >= 0 and [cmp y z] >= 0 then [cmp x z] >= 0\n\n   When [Array.sort] returns, [a] contains the same elements as before,\n   reordered in such a way that for all i and j valid indices of [a] :\n-   [cmp a.(i) a.(j)] >= 0 if and only if i >= j\n"]
    
    
    val stable_sort :
    ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                           " Same as {!Array.sort}, but the sorting algorithm is stable (i.e.\n   elements that compare equal are kept in their original order) and\n   not guaranteed to run in constant heap space.\n\n   The current implementation uses Merge Sort. It uses [n/2]\n   words of heap space, where [n] is the length of the array.\n   It is usually faster than the current implementation of {!Array.sort}.\n"]
    
    
    val fast_sort :
    ('a -> 'a -> int) -> 'a array -> unit[@@ocaml.doc
                                           " Same as {!Array.sort} or {!Array.stable_sort}, whichever is faster\n    on typical input.\n"]
    
    
    [@@@ocaml.text " {6 Iterators} "]
    
    val to_seq :
    'a array -> 'a Seq.t[@@ocaml.doc
                          " Iterate on the array, in increasing order. Modifications of the\n    array during iteration will be reflected in the iterator.\n    @since 4.07 "]
    
    
    val to_seqi :
    'a array -> (int * 'a) Seq.t[@@ocaml.doc
                                  " Iterate on the array, in increasing order, yielding indices along elements.\n    Modifications of the array during iteration will be reflected in the\n    iterator.\n    @since 4.07 "]
    
    
    val of_seq :
    'a Seq.t -> 'a array[@@ocaml.doc
                          " Create an array from the generator\n    @since 4.07 "]
    
    
    [@@@ocaml.text "/*"]
    
    [@@@ocaml.text " {1 Undocumented functions} "]
    
    external unsafe_get : 'a array -> int -> 'a = "%array_unsafe_get"
    
    
    external unsafe_set : 'a array -> int -> 'a -> unit = "%array_unsafe_set"
    
    
    module Floatarray :
    sig
      external create#1 : int -> floatarray = "caml_floatarray_create"
      
      external length#1 : floatarray -> int = "%floatarray_length"
      
      external get#1 : floatarray -> int -> float = "%floatarray_safe_get"
      
      external set#1 : floatarray -> int -> float -> unit =
      "%floatarray_safe_set"
      
      external unsafe_get#1 : floatarray -> int -> float =
      "%floatarray_unsafe_get"
      
      external unsafe_set#1 : floatarray -> int -> float -> unit =
      "%floatarray_unsafe_set"
      
    end


*** OK ***

