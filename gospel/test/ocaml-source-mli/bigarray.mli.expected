
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text
  " Large, multi-dimensional, numerical arrays.\n\n   This module implements multi-dimensional arrays of integers and\n   floating-point numbers, thereafter referred to as 'big arrays',\n   to distinguish them from the standard OCaml arrays described in\n   {!module:Array}.\n\n   The implementation allows efficient sharing of large numerical\n   arrays between OCaml code and C or Fortran numerical libraries.\n\n   The main differences between 'big arrays' and standard OCaml\n   arrays are as follows:\n   - Big arrays are not limited in size, unlike OCaml arrays.\n     (Normal float arrays are limited to 2,097,151 elements on a 32-bit\n     platform, and normal arrays of other types to 4,194,303 elements.)\n   - Big arrays are multi-dimensional.  Any number of dimensions\n     between 0 and 16 is supported.  In contrast, OCaml arrays\n     are mono-dimensional and require encoding multi-dimensional\n     arrays as arrays of arrays.\n   - Big arrays can only contain integers and floating-point numbers,\n     while OCaml arrays can contain arbitrary OCaml data types.\n   - Big arrays provide more space-efficient storage of\n     integer and floating-point elements than normal OCaml arrays, in\n     particular because they support 'small' types such as\n     single-precision floats and 8 and 16-bit integers, in addition to\n     the standard OCaml types of double-precision floats and 32 and\n     64-bit integers.\n   - The memory layout of big arrays is entirely compatible with that\n     of arrays in C and Fortran, allowing large arrays to be passed\n     back and forth between OCaml code and C / Fortran code with no\n     data copying at all.\n   - Big arrays support interesting high-level operations that normal\n     arrays do not provide efficiently, such as extracting sub-arrays\n     and 'slicing' a multi-dimensional array along certain dimensions,\n     all without any copying.\n\n   Users of this module are encouraged to do [open Bigarray] in their\n   source, then refer to array types and operations via short dot\n   notation, e.g. [Array1.t] or [Array2.sub].\n\n   Big arrays support all the OCaml ad-hoc polymorphic operations:\n   - comparisons ([=], [<>], [<=], etc, as well as {!Stdlib.compare});\n   - hashing (module [Hash]);\n   - and structured input-output (the functions from the\n     {!Marshal} module, as well as {!Stdlib.output_value}\n     and {!Stdlib.input_value}).\n"]
[@@@ocaml.text " {1 Element kinds} "]
[@@@ocaml.text
  " Big arrays can contain elements of the following kinds:\n- IEEE single precision (32 bits) floating-point numbers\n   ({!Bigarray.float32_elt}),\n- IEEE double precision (64 bits) floating-point numbers\n   ({!Bigarray.float64_elt}),\n- IEEE single precision (2 * 32 bits) floating-point complex numbers\n   ({!Bigarray.complex32_elt}),\n- IEEE double precision (2 * 64 bits) floating-point complex numbers\n   ({!Bigarray.complex64_elt}),\n- 8-bit integers (signed or unsigned)\n   ({!Bigarray.int8_signed_elt} or {!Bigarray.int8_unsigned_elt}),\n- 16-bit integers (signed or unsigned)\n   ({!Bigarray.int16_signed_elt} or {!Bigarray.int16_unsigned_elt}),\n- OCaml integers (signed, 31 bits on 32-bit architectures,\n   63 bits on 64-bit architectures) ({!Bigarray.int_elt}),\n- 32-bit signed integers ({!Bigarray.int32_elt}),\n- 64-bit signed integers ({!Bigarray.int64_elt}),\n- platform-native signed integers (32 bits on 32-bit architectures,\n   64 bits on 64-bit architectures) ({!Bigarray.nativeint_elt}).\n\n   Each element kind is represented at the type level by one of the\n   [*_elt] types defined below (defined with a single constructor instead\n   of abstract types for technical injectivity reasons).\n\n   @since 4.07.0 Moved from otherlibs to stdlib.\n"]
type float32_elt =
  | Float32_elt 
type float64_elt =
  | Float64_elt 
type int8_signed_elt =
  | Int8_signed_elt 
type int8_unsigned_elt =
  | Int8_unsigned_elt 
type int16_signed_elt =
  | Int16_signed_elt 
type int16_unsigned_elt =
  | Int16_unsigned_elt 
type int32_elt =
  | Int32_elt 
type int64_elt =
  | Int64_elt 
type int_elt =
  | Int_elt 
type nativeint_elt =
  | Nativeint_elt 
type complex32_elt =
  | Complex32_elt 
type complex64_elt =
  | Complex64_elt 
type ('a, 'b) kind =
  | Float32: (float, float32_elt) kind 
  | Float64: (float, float64_elt) kind 
  | Int8_signed: (int, int8_signed_elt) kind 
  | Int8_unsigned: (int, int8_unsigned_elt) kind 
  | Int16_signed: (int, int16_signed_elt) kind 
  | Int16_unsigned: (int, int16_unsigned_elt) kind 
  | Int32: (int32, int32_elt) kind 
  | Int64: (int64, int64_elt) kind 
  | Int: (int, int_elt) kind 
  | Nativeint: (nativeint, nativeint_elt) kind 
  | Complex32: (Complex.t, complex32_elt) kind 
  | Complex64: (Complex.t, complex64_elt) kind 
  | Char: (char, int8_unsigned_elt) kind [@@ocaml.doc
                                           " To each element kind is associated an OCaml type, which is\n   the type of OCaml values that can be stored in the big array\n   or read back from it.  This type is not necessarily the same\n   as the type of the array elements proper: for instance,\n   a big array whose elements are of kind [float32_elt] contains\n   32-bit single precision floats, but reading or writing one of\n   its elements from OCaml uses the OCaml type [float], which is\n   64-bit double precision floats.\n\n   The GADT type [('a, 'b) kind] captures this association\n   of an OCaml type ['a] for values read or written in the big array,\n   and of an element kind ['b] which represents the actual contents\n   of the big array. Its constructors list all possible associations\n   of OCaml types with element kinds, and are re-exported below for\n   backward-compatibility reasons.\n\n   Using a generalized algebraic datatype (GADT) here allows to write\n   well-typed polymorphic functions whose return type depend on the\n   argument type, such as:\n\n{[\n  let zero : type a b. (a, b) kind -> a = function\n    | Float32 -> 0.0 | Complex32 -> Complex.zero\n    | Float64 -> 0.0 | Complex64 -> Complex.zero\n    | Int8_signed -> 0 | Int8_unsigned -> 0\n    | Int16_signed -> 0 | Int16_unsigned -> 0\n    | Int32 -> 0l | Int64 -> 0L\n    | Int -> 0 | Nativeint -> 0n\n    | Char -> '\\000'\n]}\n"]
val float32 : (float, float32_elt) kind[@@ocaml.doc
                                         " See {!Bigarray.char}. "]
val float64 : (float, float64_elt) kind[@@ocaml.doc
                                         " See {!Bigarray.char}. "]
val complex32 : (Complex.t, complex32_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]
val complex64 : (Complex.t, complex64_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]
val int8_signed : (int, int8_signed_elt) kind[@@ocaml.doc
                                               " See {!Bigarray.char}. "]
val int8_unsigned : (int, int8_unsigned_elt) kind[@@ocaml.doc
                                                   " See {!Bigarray.char}. "]
val int16_signed : (int, int16_signed_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]
val int16_unsigned : (int, int16_unsigned_elt) kind[@@ocaml.doc
                                                     " See {!Bigarray.char}. "]
val int : (int, int_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]
val int32 : (int32, int32_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]
val int64 : (int64, int64_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]
val nativeint : (nativeint, nativeint_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]
val char : (char, int8_unsigned_elt) kind[@@ocaml.doc
                                           " As shown by the types of the values above,\n   big arrays of kind [float32_elt] and [float64_elt] are\n   accessed using the OCaml type [float].  Big arrays of complex kinds\n   [complex32_elt], [complex64_elt] are accessed with the OCaml type\n   {!Complex.t}. Big arrays of\n   integer kinds are accessed using the smallest OCaml integer\n   type large enough to represent the array elements:\n   [int] for 8- and 16-bit integer bigarrays, as well as OCaml-integer\n   bigarrays; [int32] for 32-bit integer bigarrays; [int64]\n   for 64-bit integer bigarrays; and [nativeint] for\n   platform-native integer bigarrays.  Finally, big arrays of\n   kind [int8_unsigned_elt] can also be accessed as arrays of\n   characters instead of arrays of small integers, by using\n   the kind value [char] instead of [int8_unsigned]. "]
val kind_size_in_bytes : ('a, 'b) kind -> int[@@ocaml.doc
                                               " [kind_size_in_bytes k] is the number of bytes used to store\n   an element of type [k].\n\n   @since 4.03.0 "]
[@@@ocaml.text " {1 Array layouts} "]
type c_layout =
  | C_layout_typ [@@ocaml.doc " See {!Bigarray.fortran_layout}."]
type fortran_layout =
  | Fortran_layout_typ [@@ocaml.doc
                         " To facilitate interoperability with existing C and Fortran code,\n   this library supports two different memory layouts for big arrays,\n   one compatible with the C conventions,\n   the other compatible with the Fortran conventions.\n\n   In the C-style layout, array indices start at 0, and\n   multi-dimensional arrays are laid out in row-major format.\n   That is, for a two-dimensional array, all elements of\n   row 0 are contiguous in memory, followed by all elements of\n   row 1, etc.  In other terms, the array elements at [(x,y)]\n   and [(x, y+1)] are adjacent in memory.\n\n   In the Fortran-style layout, array indices start at 1, and\n   multi-dimensional arrays are laid out in column-major format.\n   That is, for a two-dimensional array, all elements of\n   column 0 are contiguous in memory, followed by all elements of\n   column 1, etc.  In other terms, the array elements at [(x,y)]\n   and [(x+1, y)] are adjacent in memory.\n\n   Each layout style is identified at the type level by the\n   phantom types {!Bigarray.c_layout} and {!Bigarray.fortran_layout}\n   respectively. "]
[@@@ocaml.text
  " {7 Supported layouts}\n\n   The GADT type ['a layout] represents one of the two supported\n   memory layouts: C-style or Fortran-style. Its constructors are\n   re-exported as values below for backward-compatibility reasons.\n"]
type 'a layout =
  | C_layout: c_layout layout 
  | Fortran_layout: fortran_layout layout 
val c_layout : c_layout layout
val fortran_layout : fortran_layout layout
[@@@ocaml.text " {1 Generic arrays (of arbitrarily many dimensions)} "]
module Genarray :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type [Genarray.t] is the type of big arrays with variable\n     numbers of dimensions.  Any number of dimensions between 0 and 16\n     is supported.\n\n     The three type parameters to [Genarray.t] identify the array element\n     kind and layout, as follows:\n     - the first parameter, ['a], is the OCaml type for accessing array\n       elements ([float], [int], [int32], [int64], [nativeint]);\n     - the second parameter, ['b], is the actual kind of array elements\n       ([float32_elt], [float64_elt], [int8_signed_elt], [int8_unsigned_elt],\n       etc);\n     - the third parameter, ['c], identifies the array layout\n       ([c_layout] or [fortran_layout]).\n\n     For instance, [(float, float32_elt, fortran_layout) Genarray.t]\n     is the type of generic big arrays containing 32-bit floats\n     in Fortran layout; reads and writes in this array use the\n     OCaml type [float]. "]
  external create :
    ('a, 'b) kind -> 'c layout -> int array -> ('a, 'b, 'c) t =
      "caml_ba_create"[@@ocaml.doc
                        " [Genarray.create kind layout dimensions] returns a new big array\n     whose element kind is determined by the parameter [kind] (one of\n     [float32], [float64], [int8_signed], etc) and whose layout is\n     determined by the parameter [layout] (one of [c_layout] or\n     [fortran_layout]).  The [dimensions] parameter is an array of\n     integers that indicate the size of the big array in each dimension.\n     The length of [dimensions] determines the number of dimensions\n     of the bigarray.\n\n     For instance, [Genarray.create int32 c_layout [|4;6;8|]]\n     returns a fresh big array of 32-bit integers, in C layout,\n     having three dimensions, the three dimensions being 4, 6 and 8\n     respectively.\n\n     Big arrays returned by [Genarray.create] are not initialized:\n     the initial values of array elements is unspecified.\n\n     [Genarray.create] raises [Invalid_argument] if the number of dimensions\n     is not in the range 0 to 16 inclusive, or if one of the dimensions\n     is negative. "]
  external num_dims : ('a, 'b, 'c) t -> int = "caml_ba_num_dims"[@@ocaml.doc
                                                                  " Return the number of dimensions of the given big array. "]
  val dims : ('a, 'b, 'c) t -> int array[@@ocaml.doc
                                          " [Genarray.dims a] returns all dimensions of the big array [a],\n     as an array of integers of length [Genarray.num_dims a]. "]
  external nth_dim : ('a, 'b, 'c) t -> int -> int = "caml_ba_dim"[@@ocaml.doc
                                                                   " [Genarray.nth_dim a n] returns the [n]-th dimension of the\n     big array [a].  The first dimension corresponds to [n = 0];\n     the second dimension corresponds to [n = 1]; the last dimension,\n     to [n = Genarray.num_dims a - 1].\n     Raise [Invalid_argument] if [n] is less than 0 or greater or equal than\n     [Genarray.num_dims a]. "]
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  external change_layout :
    ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t = "caml_ba_change_layout"
  [@@ocaml.doc
    " [Genarray.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b |]] in\n      C layout becomes [get v [| b+1; a+1 |]] in Fortran layout.\n\n      @since 4.04.0\n  "]
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a] multiplied\n    by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  external get : ('a, 'b, 'c) t -> int array -> 'a = "caml_ba_get_generic"
  [@@ocaml.doc
    " Read an element of a generic big array.\n     [Genarray.get a [|i1; ...; iN|]] returns the element of [a]\n     whose coordinates are [i1] in the first dimension, [i2] in\n     the second dimension, ..., [iN] in the [N]-th dimension.\n\n     If [a] has C layout, the coordinates must be greater or equal than 0\n     and strictly less than the corresponding dimensions of [a].\n     If [a] has Fortran layout, the coordinates must be greater or equal\n     than 1 and less or equal than the corresponding dimensions of [a].\n     Raise [Invalid_argument] if the array [a] does not have exactly [N]\n     dimensions, or if the coordinates are outside the array bounds.\n\n     If [N > 3], alternate syntax is provided: you can write\n     [a.{i1, i2, ..., iN}] instead of [Genarray.get a [|i1; ...; iN|]].\n     (The syntax [a.{...}] with one, two or three coordinates is\n     reserved for accessing one-, two- and three-dimensional arrays\n     as described below.) "]
  external set :
    ('a, 'b, 'c) t -> int array -> 'a -> unit = "caml_ba_set_generic"
  [@@ocaml.doc
    " Assign an element of a generic big array.\n     [Genarray.set a [|i1; ...; iN|] v] stores the value [v] in the\n     element of [a] whose coordinates are [i1] in the first dimension,\n     [i2] in the second dimension, ..., [iN] in the [N]-th dimension.\n\n     The array [a] must have exactly [N] dimensions, and all coordinates\n     must lie inside the array bounds, as described for [Genarray.get];\n     otherwise, [Invalid_argument] is raised.\n\n     If [N > 3], alternate syntax is provided: you can write\n     [a.{i1, i2, ..., iN} <- v] instead of\n     [Genarray.set a [|i1; ...; iN|] v].\n     (The syntax [a.{...} <- v] with one, two or three coordinates is\n     reserved for updating one-, two- and three-dimensional arrays\n     as described below.) "]
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a sub-array of the given big array by restricting the\n     first (left-most) dimension.  [Genarray.sub_left a ofs len]\n     returns a big array with the same number of dimensions as [a],\n     and the same dimensions as [a], except the first dimension,\n     which corresponds to the interval [[ofs ... ofs + len - 1]]\n     of the first dimension of [a].  No copying of elements is\n     involved: the sub-array and the original array share the same\n     storage space.  In other terms, the element at coordinates\n     [[|i1; ...; iN|]] of the sub-array is identical to the\n     element at coordinates [[|i1+ofs; ...; iN|]] of the original\n     array [a].\n\n     [Genarray.sub_left] applies only to big arrays in C layout.\n     Raise [Invalid_argument] if [ofs] and [len] do not designate\n     a valid sub-array of [a], that is, if [ofs < 0], or [len < 0],\n     or [ofs + len > Genarray.nth_dim a 0]. "]
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a sub-array of the given big array by restricting the\n     last (right-most) dimension.  [Genarray.sub_right a ofs len]\n     returns a big array with the same number of dimensions as [a],\n     and the same dimensions as [a], except the last dimension,\n     which corresponds to the interval [[ofs ... ofs + len - 1]]\n     of the last dimension of [a].  No copying of elements is\n     involved: the sub-array and the original array share the same\n     storage space.  In other terms, the element at coordinates\n     [[|i1; ...; iN|]] of the sub-array is identical to the\n     element at coordinates [[|i1; ...; iN+ofs|]] of the original\n     array [a].\n\n     [Genarray.sub_right] applies only to big arrays in Fortran layout.\n     Raise [Invalid_argument] if [ofs] and [len] do not designate\n     a valid sub-array of [a], that is, if [ofs < 1], or [len < 0],\n     or [ofs + len > Genarray.nth_dim a (Genarray.num_dims a - 1)]. "]
  external slice_left :
    ('a, 'b, c_layout) t -> int array -> ('a, 'b, c_layout) t =
      "caml_ba_slice"[@@ocaml.doc
                       " Extract a sub-array of lower dimension from the given big array\n     by fixing one or several of the first (left-most) coordinates.\n     [Genarray.slice_left a [|i1; ... ; iM|]] returns the 'slice'\n     of [a] obtained by setting the first [M] coordinates to\n     [i1], ..., [iM].  If [a] has [N] dimensions, the slice has\n     dimension [N - M], and the element at coordinates\n     [[|j1; ...; j(N-M)|]] in the slice is identical to the element\n     at coordinates [[|i1; ...; iM; j1; ...; j(N-M)|]] in the original\n     array [a].  No copying of elements is involved: the slice and\n     the original array share the same storage space.\n\n     [Genarray.slice_left] applies only to big arrays in C layout.\n     Raise [Invalid_argument] if [M >= N], or if [[|i1; ... ; iM|]]\n     is outside the bounds of [a]. "]
  external slice_right :
    ('a, 'b, fortran_layout) t -> int array -> ('a, 'b, fortran_layout) t =
      "caml_ba_slice"[@@ocaml.doc
                       " Extract a sub-array of lower dimension from the given big array\n     by fixing one or several of the last (right-most) coordinates.\n     [Genarray.slice_right a [|i1; ... ; iM|]] returns the 'slice'\n     of [a] obtained by setting the last [M] coordinates to\n     [i1], ..., [iM].  If [a] has [N] dimensions, the slice has\n     dimension [N - M], and the element at coordinates\n     [[|j1; ...; j(N-M)|]] in the slice is identical to the element\n     at coordinates [[|j1; ...; j(N-M); i1; ...; iM|]] in the original\n     array [a].  No copying of elements is involved: the slice and\n     the original array share the same storage space.\n\n     [Genarray.slice_right] applies only to big arrays in Fortran layout.\n     Raise [Invalid_argument] if [M >= N], or if [[|i1; ... ; iM|]]\n     is outside the bounds of [a]. "]
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy all elements of a big array in another big array.\n     [Genarray.blit src dst] copies all elements of [src] into\n     [dst].  Both arrays [src] and [dst] must have the same number of\n     dimensions and equal dimensions.  Copying a sub-array of [src]\n     to a sub-array of [dst] can be achieved by applying [Genarray.blit]\n     to sub-array or slices of [src] and [dst]. "]
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Set all elements of a big array to a given value.\n     [Genarray.fill a v] stores the value [v] in all elements of\n     the big array [a].  Setting only some elements of [a] to [v]\n     can be achieved by applying [Genarray.fill] to a sub-array\n     or a slice of [a]. "]
end
[@@@ocaml.text " {1 Zero-dimensional arrays} "]
module Array0 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of zero-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
  val create : ('a, 'b) kind -> 'c layout -> ('a, 'b, 'c) t[@@ocaml.doc
                                                             " [Array0.create kind layout] returns a new bigarray of zero dimension.\n     [kind] and [layout] determine the array element kind and the array\n     layout as described for {!Genarray.create}. "]
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array0.change_layout a layout] returns a big array with the\n      specified [layout], sharing the data with [a]. No copying of elements\n      is involved: the new array and the original array share the same\n      storage space.\n\n      @since 4.06.0\n  "]
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is [a]'s {!kind_size_in_bytes}. "]
  val get : ('a, 'b, 'c) t -> 'a[@@ocaml.doc
                                  " [Array0.get a] returns the only element in [a]. "]
  val set : ('a, 'b, 'c) t -> 'a -> unit[@@ocaml.doc
                                          " [Array0.set a x v] stores the value [v] in [a]. "]
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Genarray.blit} for more details. "]
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Genarray.fill} for more details. "]
  val of_value : ('a, 'b) kind -> 'c layout -> 'a -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " Build a zero-dimensional big array initialized from the\n     given value.  "]
end[@@ocaml.doc
     " Zero-dimensional arrays. The [Array0] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the case\n   of zero-dimensional arrays that only contain a single scalar value.\n   Statically knowing the number of dimensions of the array allows\n   faster operations, and more precise static type-checking.\n   @since 4.05.0 "]
[@@@ocaml.text " {1 One-dimensional arrays} "]
module Array1 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of one-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
  val create : ('a, 'b) kind -> 'c layout -> int -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " [Array1.create kind layout dim] returns a new bigarray of\n     one dimension, whose size is [dim].  [kind] and [layout]\n     determine the array element kind and the array layout\n     as described for {!Genarray.create}. "]
  external dim : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                           " Return the size (dimension) of the given one-dimensional\n     big array. "]
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array1.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimension as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n\n      @since 4.06.0\n  "]
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  external get : ('a, 'b, 'c) t -> int -> 'a = "%caml_ba_ref_1"[@@ocaml.doc
                                                                 " [Array1.get a x], or alternatively [a.{x}],\n     returns the element of [a] at index [x].\n     [x] must be greater or equal than [0] and strictly less than\n     [Array1.dim a] if [a] has C layout.  If [a] has Fortran layout,\n     [x] must be greater or equal than [1] and less or equal than\n     [Array1.dim a].  Otherwise, [Invalid_argument] is raised. "]
  external set : ('a, 'b, 'c) t -> int -> 'a -> unit = "%caml_ba_set_1"
  [@@ocaml.doc
    " [Array1.set a x v], also written [a.{x} <- v],\n     stores the value [v] at index [x] in [a].\n     [x] must be inside the bounds of [a] as described in\n     {!Bigarray.Array1.get};\n     otherwise, [Invalid_argument] is raised. "]
  external sub :
    ('a, 'b, 'c) t -> int -> int -> ('a, 'b, 'c) t = "caml_ba_sub"[@@ocaml.doc
                                                                    " Extract a sub-array of the given one-dimensional big array.\n     See {!Genarray.sub_left} for more details. "]
  val slice : ('a, 'b, 'c) t -> int -> ('a, 'b, 'c) Array0.t[@@ocaml.doc
                                                              " Extract a scalar (zero-dimensional slice) of the given one-dimensional\n     big array.  The integer parameter is the index of the scalar to\n     extract.  See {!Bigarray.Genarray.slice_left} and\n     {!Bigarray.Genarray.slice_right} for more details.\n     @since 4.05.0 "]
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Genarray.blit} for more details. "]
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Genarray.fill} for more details. "]
  val of_array : ('a, 'b) kind -> 'c layout -> 'a array -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " Build a one-dimensional big array initialized from the\n     given array.  "]
  external unsafe_get : ('a, 'b, 'c) t -> int -> 'a = "%caml_ba_unsafe_ref_1"
  [@@ocaml.doc
    " Like {!Bigarray.Array1.get}, but bounds checking is not always performed.\n      Use with caution and only when the program logic guarantees that\n      the access is within bounds. "]
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> 'a -> unit = "%caml_ba_unsafe_set_1"[@@ocaml.doc
                                                                   " Like {!Bigarray.Array1.set}, but bounds checking is not always performed.\n      Use with caution and only when the program logic guarantees that\n      the access is within bounds. "]
end[@@ocaml.doc
     " One-dimensional arrays. The [Array1] structure provides operations\n   similar to those of\n   {!Bigarray.Genarray}, but specialized to the case of one-dimensional arrays.\n   (The {!Array2} and {!Array3} structures below provide operations\n   specialized for two- and three-dimensional arrays.)\n   Statically knowing the number of dimensions of the array allows\n   faster operations, and more precise static type-checking. "]
[@@@ocaml.text " {1 Two-dimensional arrays} "]
module Array2 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of two-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
  val create : ('a, 'b) kind -> 'c layout -> int -> int -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " [Array2.create kind layout dim1 dim2] returns a new bigarray of\n     two dimension, whose size is [dim1] in the first dimension\n     and [dim2] in the second dimension.  [kind] and [layout]\n     determine the array element kind and the array layout\n     as described for {!Bigarray.Genarray.create}. "]
  external dim1 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                            " Return the first dimension of the given two-dimensional big array. "]
  external dim2 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_2"[@@ocaml.doc
                                                            " Return the second dimension of the given two-dimensional big array. "]
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array2.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b |]] in\n      C layout becomes [get v [| b+1; a+1 |]] in Fortran layout.\n\n      @since 4.06.0\n  "]
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  external get : ('a, 'b, 'c) t -> int -> int -> 'a = "%caml_ba_ref_2"
  [@@ocaml.doc
    " [Array2.get a x y], also written [a.{x,y}],\n     returns the element of [a] at coordinates ([x], [y]).\n     [x] and [y] must be within the bounds\n     of [a], as described for {!Bigarray.Genarray.get};\n     otherwise, [Invalid_argument] is raised. "]
  external set :
    ('a, 'b, 'c) t -> int -> int -> 'a -> unit = "%caml_ba_set_2"[@@ocaml.doc
                                                                   " [Array2.set a x y v], or alternatively [a.{x,y} <- v],\n     stores the value [v] at coordinates ([x], [y]) in [a].\n     [x] and [y] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.set};\n     otherwise, [Invalid_argument] is raised. "]
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a two-dimensional sub-array of the given two-dimensional\n     big array by restricting the first dimension.\n     See {!Bigarray.Genarray.sub_left} for more details.\n     [Array2.sub_left] applies only to arrays with C layout. "]
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a two-dimensional sub-array of the given two-dimensional\n     big array by restricting the second dimension.\n     See {!Bigarray.Genarray.sub_right} for more details.\n     [Array2.sub_right] applies only to arrays with Fortran layout. "]
  val slice_left : ('a, 'b, c_layout) t -> int -> ('a, 'b, c_layout) Array1.t
  [@@ocaml.doc
    " Extract a row (one-dimensional slice) of the given two-dimensional\n     big array.  The integer parameter is the index of the row to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array2.slice_left] applies only to arrays with C layout. "]
  val slice_right :
    ('a, 'b, fortran_layout) t -> int -> ('a, 'b, fortran_layout) Array1.t
  [@@ocaml.doc
    " Extract a column (one-dimensional slice) of the given\n     two-dimensional big array.  The integer parameter is the\n     index of the column to extract.  See {!Bigarray.Genarray.slice_right}\n     for more details.  [Array2.slice_right] applies only to arrays\n     with Fortran layout. "]
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Bigarray.Genarray.blit} for more details. "]
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Bigarray.Genarray.fill} for more details. "]
  val of_array :
    ('a, 'b) kind -> 'c layout -> 'a array array -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " Build a two-dimensional big array initialized from the\n     given array of arrays.  "]
  external unsafe_get :
    ('a, 'b, 'c) t -> int -> int -> 'a = "%caml_ba_unsafe_ref_2"[@@ocaml.doc
                                                                  " Like {!Bigarray.Array2.get}, but bounds checking is not always\n      performed. "]
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> int -> 'a -> unit = "%caml_ba_unsafe_set_2"
  [@@ocaml.doc
    " Like {!Bigarray.Array2.set}, but bounds checking is not always\n      performed. "]
end[@@ocaml.doc
     " Two-dimensional arrays. The [Array2] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the\n   case of two-dimensional arrays. "]
[@@@ocaml.text " {1 Three-dimensional arrays} "]
module Array3 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of three-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
  val create :
    ('a, 'b) kind -> 'c layout -> int -> int -> int -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " [Array3.create kind layout dim1 dim2 dim3] returns a new bigarray of\n     three dimension, whose size is [dim1] in the first dimension,\n     [dim2] in the second dimension, and [dim3] in the third.\n     [kind] and [layout] determine the array element kind and\n     the array layout as described for {!Bigarray.Genarray.create}. "]
  external dim1 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                            " Return the first dimension of the given three-dimensional big array. "]
  external dim2 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_2"[@@ocaml.doc
                                                            " Return the second dimension of the given three-dimensional big array. "]
  external dim3 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_3"[@@ocaml.doc
                                                            " Return the third dimension of the given three-dimensional big array. "]
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array3.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b; c |]] in\n      C layout becomes [get v [| c+1; b+1; a+1 |]] in Fortran layout.\n\n      @since 4.06.0\n  "]
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  external get : ('a, 'b, 'c) t -> int -> int -> int -> 'a = "%caml_ba_ref_3"
  [@@ocaml.doc
    " [Array3.get a x y z], also written [a.{x,y,z}],\n     returns the element of [a] at coordinates ([x], [y], [z]).\n     [x], [y] and [z] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.get};\n     otherwise, [Invalid_argument] is raised. "]
  external set :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a -> unit = "%caml_ba_set_3"
  [@@ocaml.doc
    " [Array3.set a x y v], or alternatively [a.{x,y,z} <- v],\n     stores the value [v] at coordinates ([x], [y], [z]) in [a].\n     [x], [y] and [z] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.set};\n     otherwise, [Invalid_argument] is raised. "]
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a three-dimensional sub-array of the given\n     three-dimensional big array by restricting the first dimension.\n     See {!Bigarray.Genarray.sub_left} for more details.  [Array3.sub_left]\n     applies only to arrays with C layout. "]
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
      "caml_ba_sub"[@@ocaml.doc
                     " Extract a three-dimensional sub-array of the given\n     three-dimensional big array by restricting the second dimension.\n     See {!Bigarray.Genarray.sub_right} for more details.  [Array3.sub_right]\n     applies only to arrays with Fortran layout. "]
  val slice_left_1 :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) Array1.t
  [@@ocaml.doc
    " Extract a one-dimensional slice of the given three-dimensional\n     big array by fixing the first two coordinates.\n     The integer parameters are the coordinates of the slice to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array3.slice_left_1] applies only to arrays with C layout. "]
  val slice_right_1 :
    ('a, 'b, fortran_layout) t ->
      int -> int -> ('a, 'b, fortran_layout) Array1.t[@@ocaml.doc
                                                       " Extract a one-dimensional slice of the given three-dimensional\n     big array by fixing the last two coordinates.\n     The integer parameters are the coordinates of the slice to\n     extract.  See {!Bigarray.Genarray.slice_right} for more details.\n     [Array3.slice_right_1] applies only to arrays with Fortran\n     layout. "]
  val slice_left_2 :
    ('a, 'b, c_layout) t -> int -> ('a, 'b, c_layout) Array2.t[@@ocaml.doc
                                                                " Extract a  two-dimensional slice of the given three-dimensional\n     big array by fixing the first coordinate.\n     The integer parameter is the first coordinate of the slice to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array3.slice_left_2] applies only to arrays with C layout. "]
  val slice_right_2 :
    ('a, 'b, fortran_layout) t -> int -> ('a, 'b, fortran_layout) Array2.t
  [@@ocaml.doc
    " Extract a two-dimensional slice of the given\n     three-dimensional big array by fixing the last coordinate.\n     The integer parameter is the coordinate of the slice\n     to extract.  See {!Bigarray.Genarray.slice_right} for more details.\n     [Array3.slice_right_2] applies only to arrays with Fortran\n     layout. "]
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Bigarray.Genarray.blit} for more details. "]
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Bigarray.Genarray.fill} for more details. "]
  val of_array :
    ('a, 'b) kind -> 'c layout -> 'a array array array -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " Build a three-dimensional big array initialized from the\n     given array of arrays of arrays.  "]
  external unsafe_get :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a = "%caml_ba_unsafe_ref_3"
  [@@ocaml.doc
    " Like {!Bigarray.Array3.get}, but bounds checking is not always\n      performed. "]
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a -> unit =
      "%caml_ba_unsafe_set_3"[@@ocaml.doc
                               " Like {!Bigarray.Array3.set}, but bounds checking is not always\n      performed. "]
end[@@ocaml.doc
     " Three-dimensional arrays. The [Array3] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the case\n   of three-dimensional arrays. "]
[@@@ocaml.text
  " {1 Coercions between generic big arrays and fixed-dimension big arrays} "]
external genarray_of_array0 :
  ('a, 'b, 'c) Array0.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given zero-dimensional\n   big array. @since 4.05.0 "]
external genarray_of_array1 :
  ('a, 'b, 'c) Array1.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given one-dimensional\n   big array. "]
external genarray_of_array2 :
  ('a, 'b, 'c) Array2.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given two-dimensional\n   big array. "]
external genarray_of_array3 :
  ('a, 'b, 'c) Array3.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given three-dimensional\n   big array. "]
val array0_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array0.t
[@@ocaml.doc
  " Return the zero-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly zero dimension.\n   @since 4.05.0 "]
val array1_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array1.t
[@@ocaml.doc
  " Return the one-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly one dimension. "]
val array2_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array2.t
[@@ocaml.doc
  " Return the two-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly two dimensions. "]
val array3_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array3.t
[@@ocaml.doc
  " Return the three-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly three dimensions. "]
[@@@ocaml.text " {1 Re-shaping big arrays} "]
val reshape : ('a, 'b, 'c) Genarray.t -> int array -> ('a, 'b, 'c) Genarray.t
[@@ocaml.doc
  " [reshape b [|d1;...;dN|]] converts the big array [b] to a\n   [N]-dimensional array of dimensions [d1]...[dN].  The returned\n   array and the original array [b] share their data\n   and have the same layout.  For instance, assuming that [b]\n   is a one-dimensional array of dimension 12, [reshape b [|3;4|]]\n   returns a two-dimensional array [b'] of dimensions 3 and 4.\n   If [b] has C layout, the element [(x,y)] of [b'] corresponds\n   to the element [x * 3 + y] of [b].  If [b] has Fortran layout,\n   the element [(x,y)] of [b'] corresponds to the element\n   [x + (y - 1) * 4] of [b].\n   The returned big array must have exactly the same number of\n   elements as the original big array [b].  That is, the product\n   of the dimensions of [b] must be equal to [i1 * ... * iN].\n   Otherwise, [Invalid_argument] is raised. "]
val reshape_0 : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array0.t[@@ocaml.doc
                                                                  " Specialized version of {!Bigarray.reshape} for reshaping to\n   zero-dimensional arrays.\n   @since 4.05.0 "]
val reshape_1 : ('a, 'b, 'c) Genarray.t -> int -> ('a, 'b, 'c) Array1.t
[@@ocaml.doc
  " Specialized version of {!Bigarray.reshape} for reshaping to\n   one-dimensional arrays. "]
val reshape_2 :
  ('a, 'b, 'c) Genarray.t -> int -> int -> ('a, 'b, 'c) Array2.t[@@ocaml.doc
                                                                  " Specialized version of {!Bigarray.reshape} for reshaping to\n   two-dimensional arrays. "]
val reshape_3 :
  ('a, 'b, 'c) Genarray.t -> int -> int -> int -> ('a, 'b, 'c) Array3.t
[@@ocaml.doc
  " Specialized version of {!Bigarray.reshape} for reshaping to\n   three-dimensional arrays. "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text
  " Large, multi-dimensional, numerical arrays.\n\n   This module implements multi-dimensional arrays of integers and\n   floating-point numbers, thereafter referred to as 'big arrays',\n   to distinguish them from the standard OCaml arrays described in\n   {!module:Array}.\n\n   The implementation allows efficient sharing of large numerical\n   arrays between OCaml code and C or Fortran numerical libraries.\n\n   The main differences between 'big arrays' and standard OCaml\n   arrays are as follows:\n   - Big arrays are not limited in size, unlike OCaml arrays.\n     (Normal float arrays are limited to 2,097,151 elements on a 32-bit\n     platform, and normal arrays of other types to 4,194,303 elements.)\n   - Big arrays are multi-dimensional.  Any number of dimensions\n     between 0 and 16 is supported.  In contrast, OCaml arrays\n     are mono-dimensional and require encoding multi-dimensional\n     arrays as arrays of arrays.\n   - Big arrays can only contain integers and floating-point numbers,\n     while OCaml arrays can contain arbitrary OCaml data types.\n   - Big arrays provide more space-efficient storage of\n     integer and floating-point elements than normal OCaml arrays, in\n     particular because they support 'small' types such as\n     single-precision floats and 8 and 16-bit integers, in addition to\n     the standard OCaml types of double-precision floats and 32 and\n     64-bit integers.\n   - The memory layout of big arrays is entirely compatible with that\n     of arrays in C and Fortran, allowing large arrays to be passed\n     back and forth between OCaml code and C / Fortran code with no\n     data copying at all.\n   - Big arrays support interesting high-level operations that normal\n     arrays do not provide efficiently, such as extracting sub-arrays\n     and 'slicing' a multi-dimensional array along certain dimensions,\n     all without any copying.\n\n   Users of this module are encouraged to do [open Bigarray] in their\n   source, then refer to array types and operations via short dot\n   notation, e.g. [Array1.t] or [Array2.sub].\n\n   Big arrays support all the OCaml ad-hoc polymorphic operations:\n   - comparisons ([=], [<>], [<=], etc, as well as {!Stdlib.compare});\n   - hashing (module [Hash]);\n   - and structured input-output (the functions from the\n     {!Marshal} module, as well as {!Stdlib.output_value}\n     and {!Stdlib.input_value}).\n"]

[@@@ocaml.text " {1 Element kinds} "]

[@@@ocaml.text
  " Big arrays can contain elements of the following kinds:\n- IEEE single precision (32 bits) floating-point numbers\n   ({!Bigarray.float32_elt}),\n- IEEE double precision (64 bits) floating-point numbers\n   ({!Bigarray.float64_elt}),\n- IEEE single precision (2 * 32 bits) floating-point complex numbers\n   ({!Bigarray.complex32_elt}),\n- IEEE double precision (2 * 64 bits) floating-point complex numbers\n   ({!Bigarray.complex64_elt}),\n- 8-bit integers (signed or unsigned)\n   ({!Bigarray.int8_signed_elt} or {!Bigarray.int8_unsigned_elt}),\n- 16-bit integers (signed or unsigned)\n   ({!Bigarray.int16_signed_elt} or {!Bigarray.int16_unsigned_elt}),\n- OCaml integers (signed, 31 bits on 32-bit architectures,\n   63 bits on 64-bit architectures) ({!Bigarray.int_elt}),\n- 32-bit signed integers ({!Bigarray.int32_elt}),\n- 64-bit signed integers ({!Bigarray.int64_elt}),\n- platform-native signed integers (32 bits on 32-bit architectures,\n   64 bits on 64-bit architectures) ({!Bigarray.nativeint_elt}).\n\n   Each element kind is represented at the type level by one of the\n   [*_elt] types defined below (defined with a single constructor instead\n   of abstract types for technical injectivity reasons).\n\n   @since 4.07.0 Moved from otherlibs to stdlib.\n"]

type float32_elt =
| Float32_elt 
  

type float64_elt =
| Float64_elt 
  

type int8_signed_elt =
| Int8_signed_elt 
  

type int8_unsigned_elt =
| Int8_unsigned_elt 
  

type int16_signed_elt =
| Int16_signed_elt 
  

type int16_unsigned_elt =
| Int16_unsigned_elt 
  

type int32_elt =
| Int32_elt 
  

type int64_elt =
| Int64_elt 
  

type int_elt =
| Int_elt 
  

type nativeint_elt =
| Nativeint_elt 
  

type complex32_elt =
| Complex32_elt 
  

type complex64_elt =
| Complex64_elt 
  

type ('a, 'b) kind =
| Float32: (float, float32_elt) kind 
| Float64: (float, float64_elt) kind 
| Int8_signed: (int, int8_signed_elt) kind 
| Int8_unsigned: (int, int8_unsigned_elt) kind 
| Int16_signed: (int, int16_signed_elt) kind 
| Int16_unsigned: (int, int16_unsigned_elt) kind 
| Int32: (int32, int32_elt) kind 
| Int64: (int64, int64_elt) kind 
| Int: (int, int_elt) kind 
| Nativeint: (nativeint, nativeint_elt) kind 
| Complex32: (Complex.t, complex32_elt) kind 
| Complex64: (Complex.t, complex64_elt) kind 
| Char: (char, int8_unsigned_elt) kind [@@ocaml.doc
                                         " To each element kind is associated an OCaml type, which is\n   the type of OCaml values that can be stored in the big array\n   or read back from it.  This type is not necessarily the same\n   as the type of the array elements proper: for instance,\n   a big array whose elements are of kind [float32_elt] contains\n   32-bit single precision floats, but reading or writing one of\n   its elements from OCaml uses the OCaml type [float], which is\n   64-bit double precision floats.\n\n   The GADT type [('a, 'b) kind] captures this association\n   of an OCaml type ['a] for values read or written in the big array,\n   and of an element kind ['b] which represents the actual contents\n   of the big array. Its constructors list all possible associations\n   of OCaml types with element kinds, and are re-exported below for\n   backward-compatibility reasons.\n\n   Using a generalized algebraic datatype (GADT) here allows to write\n   well-typed polymorphic functions whose return type depend on the\n   argument type, such as:\n\n{[\n  let zero : type a b. (a, b) kind -> a = function\n    | Float32 -> 0.0 | Complex32 -> Complex.zero\n    | Float64 -> 0.0 | Complex64 -> Complex.zero\n    | Int8_signed -> 0 | Int8_unsigned -> 0\n    | Int16_signed -> 0 | Int16_unsigned -> 0\n    | Int32 -> 0l | Int64 -> 0L\n    | Int -> 0 | Nativeint -> 0n\n    | Char -> '\\000'\n]}\n"]
  

val float32 : (float, float32_elt) kind[@@ocaml.doc
                                         " See {!Bigarray.char}. "]


val float64 : (float, float64_elt) kind[@@ocaml.doc
                                         " See {!Bigarray.char}. "]


val complex32 : (Complex.t, complex32_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]


val complex64 : (Complex.t, complex64_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]


val int8_signed : (int, int8_signed_elt) kind[@@ocaml.doc
                                               " See {!Bigarray.char}. "]


val int8_unsigned : (int, int8_unsigned_elt) kind[@@ocaml.doc
                                                   " See {!Bigarray.char}. "]


val int16_signed : (int, int16_signed_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]


val int16_unsigned : (int, int16_unsigned_elt) kind[@@ocaml.doc
                                                     " See {!Bigarray.char}. "]


val int : (int, int_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]


val int32 : (int32, int32_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]


val int64 : (int64, int64_elt) kind[@@ocaml.doc " See {!Bigarray.char}. "]


val nativeint : (nativeint, nativeint_elt) kind[@@ocaml.doc
                                                 " See {!Bigarray.char}. "]


val char : (char, int8_unsigned_elt) kind[@@ocaml.doc
                                           " As shown by the types of the values above,\n   big arrays of kind [float32_elt] and [float64_elt] are\n   accessed using the OCaml type [float].  Big arrays of complex kinds\n   [complex32_elt], [complex64_elt] are accessed with the OCaml type\n   {!Complex.t}. Big arrays of\n   integer kinds are accessed using the smallest OCaml integer\n   type large enough to represent the array elements:\n   [int] for 8- and 16-bit integer bigarrays, as well as OCaml-integer\n   bigarrays; [int32] for 32-bit integer bigarrays; [int64]\n   for 64-bit integer bigarrays; and [nativeint] for\n   platform-native integer bigarrays.  Finally, big arrays of\n   kind [int8_unsigned_elt] can also be accessed as arrays of\n   characters instead of arrays of small integers, by using\n   the kind value [char] instead of [int8_unsigned]. "]


val kind_size_in_bytes : ('a, 'b) kind -> int[@@ocaml.doc
                                               " [kind_size_in_bytes k] is the number of bytes used to store\n   an element of type [k].\n\n   @since 4.03.0 "]


[@@@ocaml.text " {1 Array layouts} "]

type c_layout =
| C_layout_typ [@@ocaml.doc " See {!Bigarray.fortran_layout}."]
  

type fortran_layout =
| Fortran_layout_typ [@@ocaml.doc
                       " To facilitate interoperability with existing C and Fortran code,\n   this library supports two different memory layouts for big arrays,\n   one compatible with the C conventions,\n   the other compatible with the Fortran conventions.\n\n   In the C-style layout, array indices start at 0, and\n   multi-dimensional arrays are laid out in row-major format.\n   That is, for a two-dimensional array, all elements of\n   row 0 are contiguous in memory, followed by all elements of\n   row 1, etc.  In other terms, the array elements at [(x,y)]\n   and [(x, y+1)] are adjacent in memory.\n\n   In the Fortran-style layout, array indices start at 1, and\n   multi-dimensional arrays are laid out in column-major format.\n   That is, for a two-dimensional array, all elements of\n   column 0 are contiguous in memory, followed by all elements of\n   column 1, etc.  In other terms, the array elements at [(x,y)]\n   and [(x+1, y)] are adjacent in memory.\n\n   Each layout style is identified at the type level by the\n   phantom types {!Bigarray.c_layout} and {!Bigarray.fortran_layout}\n   respectively. "]
  

[@@@ocaml.text
  " {7 Supported layouts}\n\n   The GADT type ['a layout] represents one of the two supported\n   memory layouts: C-style or Fortran-style. Its constructors are\n   re-exported as values below for backward-compatibility reasons.\n"]

type 'a layout =
| C_layout: c_layout layout 
| Fortran_layout: fortran_layout layout 
  

val c_layout : c_layout layout


val fortran_layout : fortran_layout layout


[@@@ocaml.text " {1 Generic arrays (of arbitrarily many dimensions)} "]

module Genarray :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type [Genarray.t] is the type of big arrays with variable\n     numbers of dimensions.  Any number of dimensions between 0 and 16\n     is supported.\n\n     The three type parameters to [Genarray.t] identify the array element\n     kind and layout, as follows:\n     - the first parameter, ['a], is the OCaml type for accessing array\n       elements ([float], [int], [int32], [int64], [nativeint]);\n     - the second parameter, ['b], is the actual kind of array elements\n       ([float32_elt], [float64_elt], [int8_signed_elt], [int8_unsigned_elt],\n       etc);\n     - the third parameter, ['c], identifies the array layout\n       ([c_layout] or [fortran_layout]).\n\n     For instance, [(float, float32_elt, fortran_layout) Genarray.t]\n     is the type of generic big arrays containing 32-bit floats\n     in Fortran layout; reads and writes in this array use the\n     OCaml type [float]. "]
    
  external create :
    ('a, 'b) kind -> 'c layout -> int array -> ('a, 'b, 'c) t =
    "caml_ba_create"[@@ocaml.doc
                      " [Genarray.create kind layout dimensions] returns a new big array\n     whose element kind is determined by the parameter [kind] (one of\n     [float32], [float64], [int8_signed], etc) and whose layout is\n     determined by the parameter [layout] (one of [c_layout] or\n     [fortran_layout]).  The [dimensions] parameter is an array of\n     integers that indicate the size of the big array in each dimension.\n     The length of [dimensions] determines the number of dimensions\n     of the bigarray.\n\n     For instance, [Genarray.create int32 c_layout [|4;6;8|]]\n     returns a fresh big array of 32-bit integers, in C layout,\n     having three dimensions, the three dimensions being 4, 6 and 8\n     respectively.\n\n     Big arrays returned by [Genarray.create] are not initialized:\n     the initial values of array elements is unspecified.\n\n     [Genarray.create] raises [Invalid_argument] if the number of dimensions\n     is not in the range 0 to 16 inclusive, or if one of the dimensions\n     is negative. "]
  
  external num_dims : ('a, 'b, 'c) t -> int = "caml_ba_num_dims"[@@ocaml.doc
                                                                  " Return the number of dimensions of the given big array. "]
  
  val dims : ('a, 'b, 'c) t -> int array[@@ocaml.doc
                                          " [Genarray.dims a] returns all dimensions of the big array [a],\n     as an array of integers of length [Genarray.num_dims a]. "]
  
  external nth_dim : ('a, 'b, 'c) t -> int -> int = "caml_ba_dim"[@@ocaml.doc
                                                                   " [Genarray.nth_dim a n] returns the [n]-th dimension of the\n     big array [a].  The first dimension corresponds to [n = 0];\n     the second dimension corresponds to [n = 1]; the last dimension,\n     to [n = Genarray.num_dims a - 1].\n     Raise [Invalid_argument] if [n] is less than 0 or greater or equal than\n     [Genarray.num_dims a]. "]
  
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  
  external change_layout :
    ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t = "caml_ba_change_layout"
  [@@ocaml.doc
    " [Genarray.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b |]] in\n      C layout becomes [get v [| b+1; a+1 |]] in Fortran layout.\n\n      @since 4.04.0\n  "]
  
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a] multiplied\n    by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  
  external get : ('a, 'b, 'c) t -> int array -> 'a = "caml_ba_get_generic"
  [@@ocaml.doc
    " Read an element of a generic big array.\n     [Genarray.get a [|i1; ...; iN|]] returns the element of [a]\n     whose coordinates are [i1] in the first dimension, [i2] in\n     the second dimension, ..., [iN] in the [N]-th dimension.\n\n     If [a] has C layout, the coordinates must be greater or equal than 0\n     and strictly less than the corresponding dimensions of [a].\n     If [a] has Fortran layout, the coordinates must be greater or equal\n     than 1 and less or equal than the corresponding dimensions of [a].\n     Raise [Invalid_argument] if the array [a] does not have exactly [N]\n     dimensions, or if the coordinates are outside the array bounds.\n\n     If [N > 3], alternate syntax is provided: you can write\n     [a.{i1, i2, ..., iN}] instead of [Genarray.get a [|i1; ...; iN|]].\n     (The syntax [a.{...}] with one, two or three coordinates is\n     reserved for accessing one-, two- and three-dimensional arrays\n     as described below.) "]
  
  external set :
    ('a, 'b, 'c) t -> int array -> 'a -> unit = "caml_ba_set_generic"
  [@@ocaml.doc
    " Assign an element of a generic big array.\n     [Genarray.set a [|i1; ...; iN|] v] stores the value [v] in the\n     element of [a] whose coordinates are [i1] in the first dimension,\n     [i2] in the second dimension, ..., [iN] in the [N]-th dimension.\n\n     The array [a] must have exactly [N] dimensions, and all coordinates\n     must lie inside the array bounds, as described for [Genarray.get];\n     otherwise, [Invalid_argument] is raised.\n\n     If [N > 3], alternate syntax is provided: you can write\n     [a.{i1, i2, ..., iN} <- v] instead of\n     [Genarray.set a [|i1; ...; iN|] v].\n     (The syntax [a.{...} <- v] with one, two or three coordinates is\n     reserved for updating one-, two- and three-dimensional arrays\n     as described below.) "]
  
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a sub-array of the given big array by restricting the\n     first (left-most) dimension.  [Genarray.sub_left a ofs len]\n     returns a big array with the same number of dimensions as [a],\n     and the same dimensions as [a], except the first dimension,\n     which corresponds to the interval [[ofs ... ofs + len - 1]]\n     of the first dimension of [a].  No copying of elements is\n     involved: the sub-array and the original array share the same\n     storage space.  In other terms, the element at coordinates\n     [[|i1; ...; iN|]] of the sub-array is identical to the\n     element at coordinates [[|i1+ofs; ...; iN|]] of the original\n     array [a].\n\n     [Genarray.sub_left] applies only to big arrays in C layout.\n     Raise [Invalid_argument] if [ofs] and [len] do not designate\n     a valid sub-array of [a], that is, if [ofs < 0], or [len < 0],\n     or [ofs + len > Genarray.nth_dim a 0]. "]
  
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a sub-array of the given big array by restricting the\n     last (right-most) dimension.  [Genarray.sub_right a ofs len]\n     returns a big array with the same number of dimensions as [a],\n     and the same dimensions as [a], except the last dimension,\n     which corresponds to the interval [[ofs ... ofs + len - 1]]\n     of the last dimension of [a].  No copying of elements is\n     involved: the sub-array and the original array share the same\n     storage space.  In other terms, the element at coordinates\n     [[|i1; ...; iN|]] of the sub-array is identical to the\n     element at coordinates [[|i1; ...; iN+ofs|]] of the original\n     array [a].\n\n     [Genarray.sub_right] applies only to big arrays in Fortran layout.\n     Raise [Invalid_argument] if [ofs] and [len] do not designate\n     a valid sub-array of [a], that is, if [ofs < 1], or [len < 0],\n     or [ofs + len > Genarray.nth_dim a (Genarray.num_dims a - 1)]. "]
  
  external slice_left :
    ('a, 'b, c_layout) t -> int array -> ('a, 'b, c_layout) t =
    "caml_ba_slice"[@@ocaml.doc
                     " Extract a sub-array of lower dimension from the given big array\n     by fixing one or several of the first (left-most) coordinates.\n     [Genarray.slice_left a [|i1; ... ; iM|]] returns the 'slice'\n     of [a] obtained by setting the first [M] coordinates to\n     [i1], ..., [iM].  If [a] has [N] dimensions, the slice has\n     dimension [N - M], and the element at coordinates\n     [[|j1; ...; j(N-M)|]] in the slice is identical to the element\n     at coordinates [[|i1; ...; iM; j1; ...; j(N-M)|]] in the original\n     array [a].  No copying of elements is involved: the slice and\n     the original array share the same storage space.\n\n     [Genarray.slice_left] applies only to big arrays in C layout.\n     Raise [Invalid_argument] if [M >= N], or if [[|i1; ... ; iM|]]\n     is outside the bounds of [a]. "]
  
  external slice_right :
    ('a, 'b, fortran_layout) t -> int array -> ('a, 'b, fortran_layout) t =
    "caml_ba_slice"[@@ocaml.doc
                     " Extract a sub-array of lower dimension from the given big array\n     by fixing one or several of the last (right-most) coordinates.\n     [Genarray.slice_right a [|i1; ... ; iM|]] returns the 'slice'\n     of [a] obtained by setting the last [M] coordinates to\n     [i1], ..., [iM].  If [a] has [N] dimensions, the slice has\n     dimension [N - M], and the element at coordinates\n     [[|j1; ...; j(N-M)|]] in the slice is identical to the element\n     at coordinates [[|j1; ...; j(N-M); i1; ...; iM|]] in the original\n     array [a].  No copying of elements is involved: the slice and\n     the original array share the same storage space.\n\n     [Genarray.slice_right] applies only to big arrays in Fortran layout.\n     Raise [Invalid_argument] if [M >= N], or if [[|i1; ... ; iM|]]\n     is outside the bounds of [a]. "]
  
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy all elements of a big array in another big array.\n     [Genarray.blit src dst] copies all elements of [src] into\n     [dst].  Both arrays [src] and [dst] must have the same number of\n     dimensions and equal dimensions.  Copying a sub-array of [src]\n     to a sub-array of [dst] can be achieved by applying [Genarray.blit]\n     to sub-array or slices of [src] and [dst]. "]
  
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Set all elements of a big array to a given value.\n     [Genarray.fill a v] stores the value [v] in all elements of\n     the big array [a].  Setting only some elements of [a] to [v]\n     can be achieved by applying [Genarray.fill] to a sub-array\n     or a slice of [a]. "]
  
end

[@@@ocaml.text " {1 Zero-dimensional arrays} "]

module Array0 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of zero-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
    
  val create : ('a, 'b) kind -> 'c layout -> ('a, 'b, 'c) t[@@ocaml.doc
                                                             " [Array0.create kind layout] returns a new bigarray of zero dimension.\n     [kind] and [layout] determine the array element kind and the array\n     layout as described for {!Genarray.create}. "]
  
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array0.change_layout a layout] returns a big array with the\n      specified [layout], sharing the data with [a]. No copying of elements\n      is involved: the new array and the original array share the same\n      storage space.\n\n      @since 4.06.0\n  "]
  
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is [a]'s {!kind_size_in_bytes}. "]
  
  val get : ('a, 'b, 'c) t -> 'a[@@ocaml.doc
                                  " [Array0.get a] returns the only element in [a]. "]
  
  val set : ('a, 'b, 'c) t -> 'a -> unit[@@ocaml.doc
                                          " [Array0.set a x v] stores the value [v] in [a]. "]
  
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Genarray.blit} for more details. "]
  
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Genarray.fill} for more details. "]
  
  val of_value : ('a, 'b) kind -> 'c layout -> 'a -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " Build a zero-dimensional big array initialized from the\n     given value.  "]
  
end[@@ocaml.doc
     " Zero-dimensional arrays. The [Array0] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the case\n   of zero-dimensional arrays that only contain a single scalar value.\n   Statically knowing the number of dimensions of the array allows\n   faster operations, and more precise static type-checking.\n   @since 4.05.0 "]

[@@@ocaml.text " {1 One-dimensional arrays} "]

module Array1 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of one-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
    
  val create : ('a, 'b) kind -> 'c layout -> int -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " [Array1.create kind layout dim] returns a new bigarray of\n     one dimension, whose size is [dim].  [kind] and [layout]\n     determine the array element kind and the array layout\n     as described for {!Genarray.create}. "]
  
  external dim : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                           " Return the size (dimension) of the given one-dimensional\n     big array. "]
  
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array1.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimension as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n\n      @since 4.06.0\n  "]
  
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  
  external get : ('a, 'b, 'c) t -> int -> 'a = "%caml_ba_ref_1"[@@ocaml.doc
                                                                 " [Array1.get a x], or alternatively [a.{x}],\n     returns the element of [a] at index [x].\n     [x] must be greater or equal than [0] and strictly less than\n     [Array1.dim a] if [a] has C layout.  If [a] has Fortran layout,\n     [x] must be greater or equal than [1] and less or equal than\n     [Array1.dim a].  Otherwise, [Invalid_argument] is raised. "]
  
  external set : ('a, 'b, 'c) t -> int -> 'a -> unit = "%caml_ba_set_1"
  [@@ocaml.doc
    " [Array1.set a x v], also written [a.{x} <- v],\n     stores the value [v] at index [x] in [a].\n     [x] must be inside the bounds of [a] as described in\n     {!Bigarray.Array1.get};\n     otherwise, [Invalid_argument] is raised. "]
  
  external sub :
    ('a, 'b, 'c) t -> int -> int -> ('a, 'b, 'c) t = "caml_ba_sub"[@@ocaml.doc
                                                                    " Extract a sub-array of the given one-dimensional big array.\n     See {!Genarray.sub_left} for more details. "]
  
  val slice : ('a, 'b, 'c) t -> int -> ('a, 'b, 'c) Array0.t[@@ocaml.doc
                                                              " Extract a scalar (zero-dimensional slice) of the given one-dimensional\n     big array.  The integer parameter is the index of the scalar to\n     extract.  See {!Bigarray.Genarray.slice_left} and\n     {!Bigarray.Genarray.slice_right} for more details.\n     @since 4.05.0 "]
  
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Genarray.blit} for more details. "]
  
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Genarray.fill} for more details. "]
  
  val of_array : ('a, 'b) kind -> 'c layout -> 'a array -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " Build a one-dimensional big array initialized from the\n     given array.  "]
  
  external unsafe_get : ('a, 'b, 'c) t -> int -> 'a = "%caml_ba_unsafe_ref_1"
  [@@ocaml.doc
    " Like {!Bigarray.Array1.get}, but bounds checking is not always performed.\n      Use with caution and only when the program logic guarantees that\n      the access is within bounds. "]
  
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> 'a -> unit = "%caml_ba_unsafe_set_1"[@@ocaml.doc
                                                                   " Like {!Bigarray.Array1.set}, but bounds checking is not always performed.\n      Use with caution and only when the program logic guarantees that\n      the access is within bounds. "]
  
end[@@ocaml.doc
     " One-dimensional arrays. The [Array1] structure provides operations\n   similar to those of\n   {!Bigarray.Genarray}, but specialized to the case of one-dimensional arrays.\n   (The {!Array2} and {!Array3} structures below provide operations\n   specialized for two- and three-dimensional arrays.)\n   Statically knowing the number of dimensions of the array allows\n   faster operations, and more precise static type-checking. "]

[@@@ocaml.text " {1 Two-dimensional arrays} "]

module Array2 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of two-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
    
  val create : ('a, 'b) kind -> 'c layout -> int -> int -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " [Array2.create kind layout dim1 dim2] returns a new bigarray of\n     two dimension, whose size is [dim1] in the first dimension\n     and [dim2] in the second dimension.  [kind] and [layout]\n     determine the array element kind and the array layout\n     as described for {!Bigarray.Genarray.create}. "]
  
  external dim1 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                            " Return the first dimension of the given two-dimensional big array. "]
  
  external dim2 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_2"[@@ocaml.doc
                                                            " Return the second dimension of the given two-dimensional big array. "]
  
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array2.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b |]] in\n      C layout becomes [get v [| b+1; a+1 |]] in Fortran layout.\n\n      @since 4.06.0\n  "]
  
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  
  external get : ('a, 'b, 'c) t -> int -> int -> 'a = "%caml_ba_ref_2"
  [@@ocaml.doc
    " [Array2.get a x y], also written [a.{x,y}],\n     returns the element of [a] at coordinates ([x], [y]).\n     [x] and [y] must be within the bounds\n     of [a], as described for {!Bigarray.Genarray.get};\n     otherwise, [Invalid_argument] is raised. "]
  
  external set :
    ('a, 'b, 'c) t -> int -> int -> 'a -> unit = "%caml_ba_set_2"[@@ocaml.doc
                                                                   " [Array2.set a x y v], or alternatively [a.{x,y} <- v],\n     stores the value [v] at coordinates ([x], [y]) in [a].\n     [x] and [y] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.set};\n     otherwise, [Invalid_argument] is raised. "]
  
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a two-dimensional sub-array of the given two-dimensional\n     big array by restricting the first dimension.\n     See {!Bigarray.Genarray.sub_left} for more details.\n     [Array2.sub_left] applies only to arrays with C layout. "]
  
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a two-dimensional sub-array of the given two-dimensional\n     big array by restricting the second dimension.\n     See {!Bigarray.Genarray.sub_right} for more details.\n     [Array2.sub_right] applies only to arrays with Fortran layout. "]
  
  val slice_left : ('a, 'b, c_layout) t -> int -> ('a, 'b, c_layout) Array1.t
  [@@ocaml.doc
    " Extract a row (one-dimensional slice) of the given two-dimensional\n     big array.  The integer parameter is the index of the row to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array2.slice_left] applies only to arrays with C layout. "]
  
  val slice_right :
    ('a, 'b, fortran_layout) t -> int -> ('a, 'b, fortran_layout) Array1.t
  [@@ocaml.doc
    " Extract a column (one-dimensional slice) of the given\n     two-dimensional big array.  The integer parameter is the\n     index of the column to extract.  See {!Bigarray.Genarray.slice_right}\n     for more details.  [Array2.slice_right] applies only to arrays\n     with Fortran layout. "]
  
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Bigarray.Genarray.blit} for more details. "]
  
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Bigarray.Genarray.fill} for more details. "]
  
  val of_array :
    ('a, 'b) kind -> 'c layout -> 'a array array -> ('a, 'b, 'c) t[@@ocaml.doc
                                                                    " Build a two-dimensional big array initialized from the\n     given array of arrays.  "]
  
  external unsafe_get :
    ('a, 'b, 'c) t -> int -> int -> 'a = "%caml_ba_unsafe_ref_2"[@@ocaml.doc
                                                                  " Like {!Bigarray.Array2.get}, but bounds checking is not always\n      performed. "]
  
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> int -> 'a -> unit = "%caml_ba_unsafe_set_2"
  [@@ocaml.doc
    " Like {!Bigarray.Array2.set}, but bounds checking is not always\n      performed. "]
  
end[@@ocaml.doc
     " Two-dimensional arrays. The [Array2] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the\n   case of two-dimensional arrays. "]

[@@@ocaml.text " {1 Three-dimensional arrays} "]

module Array3 :
sig
  type ('a, 'b, 'c) t[@@ocaml.doc
                       " The type of three-dimensional big arrays whose elements have\n     OCaml type ['a], representation kind ['b], and memory layout ['c]. "]
    
  val create :
    ('a, 'b) kind -> 'c layout -> int -> int -> int -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " [Array3.create kind layout dim1 dim2 dim3] returns a new bigarray of\n     three dimension, whose size is [dim1] in the first dimension,\n     [dim2] in the second dimension, and [dim3] in the third.\n     [kind] and [layout] determine the array element kind and\n     the array layout as described for {!Bigarray.Genarray.create}. "]
  
  external dim1 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_1"[@@ocaml.doc
                                                            " Return the first dimension of the given three-dimensional big array. "]
  
  external dim2 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_2"[@@ocaml.doc
                                                            " Return the second dimension of the given three-dimensional big array. "]
  
  external dim3 : ('a, 'b, 'c) t -> int = "%caml_ba_dim_3"[@@ocaml.doc
                                                            " Return the third dimension of the given three-dimensional big array. "]
  
  external kind : ('a, 'b, 'c) t -> ('a, 'b) kind = "caml_ba_kind"[@@ocaml.doc
                                                                    " Return the kind of the given big array. "]
  
  external layout : ('a, 'b, 'c) t -> 'c layout = "caml_ba_layout"[@@ocaml.doc
                                                                    " Return the layout of the given big array. "]
  
  val change_layout : ('a, 'b, 'c) t -> 'd layout -> ('a, 'b, 'd) t[@@ocaml.doc
                                                                    " [Array3.change_layout a layout] returns a bigarray with the\n      specified [layout], sharing the data with [a] (and hence having\n      the same dimensions as [a]). No copying of elements is involved: the\n      new array and the original array share the same storage space.\n      The dimensions are reversed, such that [get v [| a; b; c |]] in\n      C layout becomes [get v [| c+1; b+1; a+1 |]] in Fortran layout.\n\n      @since 4.06.0\n  "]
  
  val size_in_bytes : ('a, 'b, 'c) t -> int[@@ocaml.doc
                                             " [size_in_bytes a] is the number of elements in [a]\n    multiplied by [a]'s {!kind_size_in_bytes}.\n\n    @since 4.03.0 "]
  
  external get : ('a, 'b, 'c) t -> int -> int -> int -> 'a = "%caml_ba_ref_3"
  [@@ocaml.doc
    " [Array3.get a x y z], also written [a.{x,y,z}],\n     returns the element of [a] at coordinates ([x], [y], [z]).\n     [x], [y] and [z] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.get};\n     otherwise, [Invalid_argument] is raised. "]
  
  external set :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a -> unit = "%caml_ba_set_3"
  [@@ocaml.doc
    " [Array3.set a x y v], or alternatively [a.{x,y,z} <- v],\n     stores the value [v] at coordinates ([x], [y], [z]) in [a].\n     [x], [y] and [z] must be within the bounds of [a],\n     as described for {!Bigarray.Genarray.set};\n     otherwise, [Invalid_argument] is raised. "]
  
  external sub_left :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a three-dimensional sub-array of the given\n     three-dimensional big array by restricting the first dimension.\n     See {!Bigarray.Genarray.sub_left} for more details.  [Array3.sub_left]\n     applies only to arrays with C layout. "]
  
  external sub_right :
    ('a, 'b, fortran_layout) t -> int -> int -> ('a, 'b, fortran_layout) t =
    "caml_ba_sub"[@@ocaml.doc
                   " Extract a three-dimensional sub-array of the given\n     three-dimensional big array by restricting the second dimension.\n     See {!Bigarray.Genarray.sub_right} for more details.  [Array3.sub_right]\n     applies only to arrays with Fortran layout. "]
  
  val slice_left_1 :
    ('a, 'b, c_layout) t -> int -> int -> ('a, 'b, c_layout) Array1.t
  [@@ocaml.doc
    " Extract a one-dimensional slice of the given three-dimensional\n     big array by fixing the first two coordinates.\n     The integer parameters are the coordinates of the slice to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array3.slice_left_1] applies only to arrays with C layout. "]
  
  val slice_right_1 :
    ('a, 'b, fortran_layout) t ->
      int -> int -> ('a, 'b, fortran_layout) Array1.t[@@ocaml.doc
                                                       " Extract a one-dimensional slice of the given three-dimensional\n     big array by fixing the last two coordinates.\n     The integer parameters are the coordinates of the slice to\n     extract.  See {!Bigarray.Genarray.slice_right} for more details.\n     [Array3.slice_right_1] applies only to arrays with Fortran\n     layout. "]
  
  val slice_left_2 :
    ('a, 'b, c_layout) t -> int -> ('a, 'b, c_layout) Array2.t[@@ocaml.doc
                                                                " Extract a  two-dimensional slice of the given three-dimensional\n     big array by fixing the first coordinate.\n     The integer parameter is the first coordinate of the slice to\n     extract.  See {!Bigarray.Genarray.slice_left} for more details.\n     [Array3.slice_left_2] applies only to arrays with C layout. "]
  
  val slice_right_2 :
    ('a, 'b, fortran_layout) t -> int -> ('a, 'b, fortran_layout) Array2.t
  [@@ocaml.doc
    " Extract a two-dimensional slice of the given\n     three-dimensional big array by fixing the last coordinate.\n     The integer parameter is the coordinate of the slice\n     to extract.  See {!Bigarray.Genarray.slice_right} for more details.\n     [Array3.slice_right_2] applies only to arrays with Fortran\n     layout. "]
  
  external blit : ('a, 'b, 'c) t -> ('a, 'b, 'c) t -> unit = "caml_ba_blit"
  [@@ocaml.doc
    " Copy the first big array to the second big array.\n     See {!Bigarray.Genarray.blit} for more details. "]
  
  external fill : ('a, 'b, 'c) t -> 'a -> unit = "caml_ba_fill"[@@ocaml.doc
                                                                 " Fill the given big array with the given value.\n     See {!Bigarray.Genarray.fill} for more details. "]
  
  val of_array :
    ('a, 'b) kind -> 'c layout -> 'a array array array -> ('a, 'b, 'c) t
  [@@ocaml.doc
    " Build a three-dimensional big array initialized from the\n     given array of arrays of arrays.  "]
  
  external unsafe_get :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a = "%caml_ba_unsafe_ref_3"
  [@@ocaml.doc
    " Like {!Bigarray.Array3.get}, but bounds checking is not always\n      performed. "]
  
  external unsafe_set :
    ('a, 'b, 'c) t -> int -> int -> int -> 'a -> unit =
    "%caml_ba_unsafe_set_3"[@@ocaml.doc
                             " Like {!Bigarray.Array3.set}, but bounds checking is not always\n      performed. "]
  
end[@@ocaml.doc
     " Three-dimensional arrays. The [Array3] structure provides operations\n   similar to those of {!Bigarray.Genarray}, but specialized to the case\n   of three-dimensional arrays. "]

[@@@ocaml.text
  " {1 Coercions between generic big arrays and fixed-dimension big arrays} "]

external genarray_of_array0 :
  ('a, 'b, 'c) Array0.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given zero-dimensional\n   big array. @since 4.05.0 "]


external genarray_of_array1 :
  ('a, 'b, 'c) Array1.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given one-dimensional\n   big array. "]


external genarray_of_array2 :
  ('a, 'b, 'c) Array2.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given two-dimensional\n   big array. "]


external genarray_of_array3 :
  ('a, 'b, 'c) Array3.t -> ('a, 'b, 'c) Genarray.t = "%identity"[@@ocaml.doc
                                                                  " Return the generic big array corresponding to the given three-dimensional\n   big array. "]


val array0_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array0.t
[@@ocaml.doc
  " Return the zero-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly zero dimension.\n   @since 4.05.0 "]


val array1_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array1.t
[@@ocaml.doc
  " Return the one-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly one dimension. "]


val array2_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array2.t
[@@ocaml.doc
  " Return the two-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly two dimensions. "]


val array3_of_genarray : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array3.t
[@@ocaml.doc
  " Return the three-dimensional big array corresponding to the given\n   generic big array.  Raise [Invalid_argument] if the generic big array\n   does not have exactly three dimensions. "]


[@@@ocaml.text " {1 Re-shaping big arrays} "]

val reshape : ('a, 'b, 'c) Genarray.t -> int array -> ('a, 'b, 'c) Genarray.t
[@@ocaml.doc
  " [reshape b [|d1;...;dN|]] converts the big array [b] to a\n   [N]-dimensional array of dimensions [d1]...[dN].  The returned\n   array and the original array [b] share their data\n   and have the same layout.  For instance, assuming that [b]\n   is a one-dimensional array of dimension 12, [reshape b [|3;4|]]\n   returns a two-dimensional array [b'] of dimensions 3 and 4.\n   If [b] has C layout, the element [(x,y)] of [b'] corresponds\n   to the element [x * 3 + y] of [b].  If [b] has Fortran layout,\n   the element [(x,y)] of [b'] corresponds to the element\n   [x + (y - 1) * 4] of [b].\n   The returned big array must have exactly the same number of\n   elements as the original big array [b].  That is, the product\n   of the dimensions of [b] must be equal to [i1 * ... * iN].\n   Otherwise, [Invalid_argument] is raised. "]


val reshape_0 : ('a, 'b, 'c) Genarray.t -> ('a, 'b, 'c) Array0.t[@@ocaml.doc
                                                                  " Specialized version of {!Bigarray.reshape} for reshaping to\n   zero-dimensional arrays.\n   @since 4.05.0 "]


val reshape_1 : ('a, 'b, 'c) Genarray.t -> int -> ('a, 'b, 'c) Array1.t
[@@ocaml.doc
  " Specialized version of {!Bigarray.reshape} for reshaping to\n   one-dimensional arrays. "]


val reshape_2 :
  ('a, 'b, 'c) Genarray.t -> int -> int -> ('a, 'b, 'c) Array2.t[@@ocaml.doc
                                                                  " Specialized version of {!Bigarray.reshape} for reshaping to\n   two-dimensional arrays. "]


val reshape_3 :
  ('a, 'b, 'c) Genarray.t -> int -> int -> int -> ('a, 'b, 'c) Array3.t
[@@ocaml.doc
  " Specialized version of {!Bigarray.reshape} for reshaping to\n   three-dimensional arrays. "]

File "bigarray.mli", line 107, characters 4-39:
Error: Not supported: type in constructors not supported
