
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text " Interface to the information collected in source files. "]
type ref_kind = Odoc_types.ref_kind =
  | RK_module 
  | RK_module_type 
  | RK_class 
  | RK_class_type 
  | RK_value 
  | RK_type 
  | RK_extension 
  | RK_exception 
  | RK_attribute 
  | RK_method 
  | RK_section of text 
  | RK_recfield 
  | RK_const [@@ocaml.doc " The different kinds of element references. "]
and text_element = Odoc_types.text_element =
  | Raw of string [@ocaml.doc " Raw text. "]
  | Code of string [@ocaml.doc " The string is source code. "]
  | CodePre of string
  [@ocaml.doc " The string is pre-formatted source code. "]
  | Verbatim of string [@ocaml.doc " String 'as is'. "]
  | Bold of text [@ocaml.doc " Text in bold style. "]
  | Italic of text [@ocaml.doc " Text in italic. "]
  | Emphasize of text [@ocaml.doc " Emphasized text. "]
  | Center of text [@ocaml.doc " Centered text. "]
  | Left of text [@ocaml.doc " Left alignment. "]
  | Right of text [@ocaml.doc " Right alignment. "]
  | List of text list [@ocaml.doc " A list. "]
  | Enum of text list [@ocaml.doc " An enumerated list. "]
  | Newline [@ocaml.doc " To force a line break. "]
  | Block of text [@ocaml.doc " Like html's block quote. "]
  | Title of int * string option * text
  [@ocaml.doc " Style number, optional label, and text. "]
  | Latex of string [@ocaml.doc " A string for latex. "]
  | Link of string * text
  [@ocaml.doc " A reference string and the link text. "]
  | Ref of string * ref_kind option * text option
  [@ocaml.doc
    " A reference to an element. Complete name and kind.\n        An optional text can be given to display this text instead\n        of the element name."]
  | Superscript of text [@ocaml.doc " Superscripts. "]
  | Subscript of text [@ocaml.doc " Subscripts. "]
  | Module_list of string list
  [@ocaml.doc " The table of the given modules with their abstract. "]
  | Index_list
  [@ocaml.doc " The links to the various indexes (values, types, ...) "]
  | Custom of string * text [@ocaml.doc " to extend \\{foo syntax "]
  | Target of string * string
  [@ocaml.doc
    " (target, code) : to specify code specific to a target format "]
and text = text_element list[@@ocaml.doc
                              " A text is a list of [text_element]. The order matters. "]
type see_ref = Odoc_types.see_ref =
  | See_url of string 
  | See_file of string 
  | See_doc of string [@@ocaml.doc
                        " The different forms of references in \\@see tags. "]
exception Text_syntax of int * int * string
  [@ocaml.doc
    " Raised when parsing string to build a {!Odoc_info.text}\n   structure. [(line, char, string)] "]
type see = (see_ref * text)[@@ocaml.doc " The information in a \\@see tag. "]
type param = (string * text)[@@ocaml.doc " Parameter name and description. "]
type raised_exception = (string * text)[@@ocaml.doc
                                         " Raised exception name and description. "]
type info = Odoc_types.info =
  {
  i_desc: text option [@ocaml.doc " The description text. "];
  i_authors: string list
    [@ocaml.doc " The list of authors in \\@author tags. "];
  i_version: string option [@ocaml.doc " The string in the \\@version tag. "];
  i_sees: see list [@ocaml.doc " The list of \\@see tags. "];
  i_since: string option [@ocaml.doc " The string in the \\@since tag. "];
  i_before: (string * text) list
    [@ocaml.doc " the version number and text in \\@before tag "];
  i_deprecated: text option
    [@ocaml.doc " The description text of the \\@deprecated tag. "];
  i_params: param list [@ocaml.doc " The list of parameter descriptions. "];
  i_raised_exceptions: raised_exception list
    [@ocaml.doc " The list of raised exceptions. "];
  i_return_value: text option
    [@ocaml.doc " The description text of the return value. "];
  i_custom: (string * text) list
    [@ocaml.doc " A text associated to a custom @-tag. "]}[@@ocaml.doc
                                                            " Information in a special comment\n@before 3.12.0 \\@before information was not present.\n"]
type location = Odoc_types.location =
  {
  loc_impl: Location.t option [@ocaml.doc " implementation location "];
  loc_inter: Location.t option [@ocaml.doc " interface location "]}[@@ocaml.doc
                                                                    " Location of elements in implementation and interface files. "]
val dummy_loc : location[@@ocaml.doc " A dummy location. "]
module Name :
sig
  type t = string
  val simple : t -> t[@@ocaml.doc " Access to the simple name. "]
  val concat : t -> t -> t[@@ocaml.doc
                            " [concat t1 t2] returns the concatenation of [t1] and [t2]."]
  val depth : t -> int[@@ocaml.doc
                        " Return the depth of the name, i.e. the number of levels to the root.\n         Example : [depth \"Toto.Tutu.name\"] = [3]. "]
  val get_relative : t -> t -> t[@@ocaml.doc
                                  " Take two names n1 and n2 = n3.n4 and return n4 if n3=n1 or else n2. "]
  val get_relative_opt : t -> t -> t[@@ocaml.doc
                                      " Take two names n1 and n2 = n3.n4 and return n4 if n3=n1 and n1<>\"\" or else n2. "]
  val father : t -> t[@@ocaml.doc
                       " Return the name of the 'father' (like [dirname] for a file name)."]
end[@@ocaml.doc " Representation of element names. "]
module Parameter :
sig
  [@@@ocaml.text " {1 Types} "]
  type simple_name = Odoc_parameter.simple_name =
    {
    sn_name: string ;
    sn_type: Types.type_expr ;
    mutable sn_text: text option }[@@ocaml.doc
                                    " Representation of a simple parameter name "]
  type param_info = Odoc_parameter.param_info =
    | Simple_name of simple_name 
    | Tuple of param_info list * Types.type_expr [@@ocaml.doc
                                                   " Representation of parameter names. We need it to represent parameter names in tuples.\n       The value [Tuple ([], t)] stands for an anonymous parameter."]
  type parameter = param_info[@@ocaml.doc
                               " A parameter is just a param_info."]
  [@@@ocaml.text " {1 Functions} "]
  val complete_name : parameter -> string[@@ocaml.doc
                                           " Access to the name as a string. For tuples, parentheses and commas are added. "]
  val typ : parameter -> Types.type_expr[@@ocaml.doc
                                          " Access to the complete type. "]
  val names : parameter -> string list[@@ocaml.doc
                                        " Access to the list of names ; only one for a simple parameter, or\n       a list for a tuple. "]
  val desc_by_name : parameter -> string -> text option[@@ocaml.doc
                                                         " Access to the description of a specific name.\n       @raise Not_found if no description is associated to the given name. "]
  val type_by_name : parameter -> string -> Types.type_expr[@@ocaml.doc
                                                             " Access to the type of a specific name.\n       @raise Not_found if no type is associated to the given name. "]
end[@@ocaml.doc
     " Representation and manipulation of method / function / class / module parameters."]
module Extension :
sig
  type private_flag = Odoc_extension.private_flag =
    | Private 
    | Public 
  type extension_alias = Odoc_extension.extension_alias =
    {
    xa_name: Name.t
      [@ocaml.doc " The complete name of the target extension. "];
    mutable xa_xt: t_extension_constructor option
      [@ocaml.doc " The target extension, if we found it."]}[@@ocaml.doc
                                                              " Used when the extension is a rebind of another extension,\n       when we have [extension Xt = Target_xt]."]
  and t_extension_constructor = Odoc_extension.t_extension_constructor =
    {
    xt_name: Name.t ;
    xt_args: Odoc_type.constructor_args ;
    xt_ret: Types.type_expr option
      [@ocaml.doc " the optional return type of the extension "];
    xt_type_extension: t_type_extension
      [@ocaml.doc " the type extension containing this constructor "];
    xt_alias: extension_alias option
      [@ocaml.doc " [None] when the extension is not a rebind. "];
    mutable xt_loc: Odoc_types.location ;
    mutable xt_text: Odoc_types.info option
      [@ocaml.doc " optional user description "]}
  and t_type_extension = Odoc_extension.t_type_extension =
    {
    mutable te_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    te_type_name: Name.t [@ocaml.doc " The type of the extension "];
    te_type_parameters: Types.type_expr list ;
    te_private: private_flag ;
    mutable te_constructors: t_extension_constructor list ;
    mutable te_loc: location ;
    mutable te_code: string option }
  val extension_constructors :
    t_type_extension -> t_extension_constructor list[@@ocaml.doc
                                                      " Access to the extensions in a group. "]
end[@@ocaml.doc " Representation and manipulation of extensions. "]
module Exception :
sig
  type exception_alias = Odoc_exception.exception_alias =
    {
    ea_name: Name.t
      [@ocaml.doc " The complete name of the target exception. "];
    mutable ea_ex: t_exception option
      [@ocaml.doc " The target exception, if we found it."]}[@@ocaml.doc
                                                              " Used when the exception is a rebind of another exception,\n       when we have [exception Ex = Target_ex]."]
  and t_exception = Odoc_exception.t_exception =
    {
    ex_name: Name.t ;
    mutable ex_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    ex_args: Odoc_type.constructor_args ;
    ex_ret: Types.type_expr option
      [@ocaml.doc " The optional return type of the exception. "];
    ex_alias: exception_alias option
      [@ocaml.doc " [None] when the exception is not a rebind. "];
    mutable ex_loc: location ;
    mutable ex_code: string option }
end[@@ocaml.doc " Representation and manipulation of exceptions. "]
module Type :
sig
  type private_flag = Odoc_type.private_flag =
    | Private 
    | Public 
  type record_field = Odoc_type.record_field =
    {
    rf_name: string [@ocaml.doc " Name of the field. "];
    rf_mutable: bool [@ocaml.doc " [true] if mutable. "];
    rf_type: Types.type_expr [@ocaml.doc " Type of the field. "];
    mutable rf_text: info option
      [@ocaml.doc " Optional description in the associated comment."]}
  [@@ocaml.doc " Description of a record type field. "]
  type constructor_args = Odoc_type.constructor_args =
    | Cstr_record of record_field list 
    | Cstr_tuple of Types.type_expr list [@@ocaml.doc
                                           " Description of a variant type constructor. "]
  type variant_constructor = Odoc_type.variant_constructor =
    {
    vc_name: string [@ocaml.doc " Name of the constructor. "];
    vc_args: constructor_args ;
    vc_ret: Types.type_expr option ;
    mutable vc_text: info option
      [@ocaml.doc " Optional description in the associated comment. "]}
  type type_kind = Odoc_type.type_kind =
    | Type_abstract [@ocaml.doc " Type is abstract, for example [type t]. "]
    | Type_variant of variant_constructor list [@ocaml.doc " constructors "]
    | Type_record of record_field list [@ocaml.doc " fields "]
    | Type_open [@ocaml.doc " Type is open "][@@ocaml.doc
                                               " The various kinds of a type. "]
  type object_field = Odoc_type.object_field =
    {
    of_name: string ;
    of_type: Types.type_expr ;
    mutable of_text: Odoc_types.info option
      [@ocaml.doc " optional user description "]}
  type type_manifest = Odoc_type.type_manifest =
    | Other of Types.type_expr
    [@ocaml.doc " Type manifest directly taken from Typedtree. "]
    | Object_type of object_field list 
  type t_type = Odoc_type.t_type =
    {
    ty_name: Name.t [@ocaml.doc " Complete name of the type. "];
    mutable ty_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    ty_parameters: (Types.type_expr * bool * bool) list
      [@ocaml.doc " type parameters: (type, covariant, contravariant) "];
    ty_kind: type_kind [@ocaml.doc " Type kind. "];
    ty_private: private_flag [@ocaml.doc " Private or public type. "];
    ty_manifest: type_manifest option ;
    mutable ty_loc: location ;
    mutable ty_code: string option }[@@ocaml.doc
                                      " Representation of a type. "]
end[@@ocaml.doc " Representation and manipulation of types."]
module Value :
sig
  type t_value = Odoc_value.t_value =
    {
    val_name: Name.t [@ocaml.doc " Complete name of the value. "];
    mutable val_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    val_type: Types.type_expr [@ocaml.doc " Type of the value. "];
    val_recursive: bool [@ocaml.doc " [true] if the value is recursive. "];
    mutable val_parameters: Odoc_parameter.parameter list
      [@ocaml.doc " The parameters, if any. "];
    mutable val_code: string option
      [@ocaml.doc
        " The code of the value, if we had the only the implementation file. "];
    mutable val_loc: location }[@@ocaml.doc " Representation of a value. "]
  type t_attribute = Odoc_value.t_attribute =
    {
    att_value: t_value
      [@ocaml.doc
        " an attribute has almost all the same information as a value "];
    att_mutable: bool [@ocaml.doc " [true] if the attribute is mutable. "];
    att_virtual: bool [@ocaml.doc " [true] if the attribute is virtual. "]}
  [@@ocaml.doc " Representation of a class attribute. "]
  type t_method = Odoc_value.t_method =
    {
    met_value: t_value
      [@ocaml.doc
        " a method has almost all the same information as a value "];
    met_private: bool [@ocaml.doc " [true] if the method is private."];
    met_virtual: bool [@ocaml.doc " [true] if the method is virtual. "]}
  [@@ocaml.doc " Representation of a class method. "]
  val is_function : t_value -> bool[@@ocaml.doc
                                     " Return [true] if the value is a function, i.e. it has a functional type. "]
  val value_parameter_text_by_name : t_value -> string -> text option
  [@@ocaml.doc
    " Access to the description associated to the given parameter name."]
end[@@ocaml.doc
     " Representation and manipulation of values, class attributes and class methods. "]
module Class :
sig
  [@@@ocaml.text " {1 Types} "]
  type class_element = Odoc_class.class_element =
    | Class_attribute of Value.t_attribute 
    | Class_method of Value.t_method 
    | Class_comment of text [@@ocaml.doc
                              " To keep the order of elements in a class. "]
  type cct = Odoc_class.cct =
    | Cl of t_class 
    | Cltype of t_class_type * Types.type_expr list
    [@ocaml.doc " Class type and type parameters. "][@@ocaml.doc
                                                      " Used when we can reference a t_class or a t_class_type. "]
  and inherited_class = Odoc_class.inherited_class =
    {
    ic_name: Name.t [@ocaml.doc " Complete name of the inherited class. "];
    mutable ic_class: cct option
      [@ocaml.doc " The associated t_class or t_class_type. "];
    ic_text: text option
      [@ocaml.doc " The inheritance description, if any. "]}
  and class_apply = Odoc_class.class_apply =
    {
    capp_name: Name.t
      [@ocaml.doc " The complete name of the applied class. "];
    mutable capp_class: t_class option
      [@ocaml.doc " The associated t_class if we found it. "];
    capp_params: Types.type_expr list
      [@ocaml.doc " The type of expressions the class is applied to. "];
    capp_params_code: string list
      [@ocaml.doc " The code of these expressions. "]}
  and class_constr = Odoc_class.class_constr =
    {
    cco_name: Name.t [@ocaml.doc " The complete name of the applied class. "];
    mutable cco_class: cct option
      [@ocaml.doc " The associated class or class type if we found it. "];
    cco_type_parameters: Types.type_expr list
      [@ocaml.doc " The type parameters of the class, if needed. "]}
  and class_kind = Odoc_class.class_kind =
    | Class_structure of inherited_class list * class_element list
    [@ocaml.doc
      " An explicit class structure, used in implementation and interface. "]
    | Class_apply of class_apply
    [@ocaml.doc
      " Application/alias of a class, used in implementation only. "]
    | Class_constr of class_constr
    [@ocaml.doc
      " A class used to give the type of the defined class,\n           instead of a structure, used in interface only.\n           For example, it will be used with the name [M1.M2....bar]\n           when the class foo is defined like this :\n           [class foo : int -> bar] "]
    | Class_constraint of class_kind * class_type_kind
    [@ocaml.doc " A class definition with a constraint. "]
  and t_class = Odoc_class.t_class =
    {
    cl_name: Name.t [@ocaml.doc " Complete name of the class. "];
    mutable cl_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    cl_type: Types.class_type [@ocaml.doc " Type of the class. "];
    cl_type_parameters: Types.type_expr list
      [@ocaml.doc " Type parameters. "];
    cl_virtual: bool [@ocaml.doc " [true] when the class is virtual. "];
    mutable cl_kind: class_kind
      [@ocaml.doc " The way the class is defined. "];
    mutable cl_parameters: Parameter.parameter list
      [@ocaml.doc " The parameters of the class. "];
    mutable cl_loc: location }[@@ocaml.doc " Representation of a class. "]
  and class_type_alias = Odoc_class.class_type_alias =
    {
    cta_name: Name.t [@ocaml.doc " Complete name of the target class type. "];
    mutable cta_class: cct option
      [@ocaml.doc " The target t_class or t_class_type, if we found it."];
    cta_type_parameters: Types.type_expr list
      [@ocaml.doc " The type parameters. FIXME : use strings? "]}
  and class_type_kind = Odoc_class.class_type_kind =
    | Class_signature of inherited_class list * class_element list 
    | Class_type of class_type_alias
    [@ocaml.doc " A class type eventually applied to type args. "]
  and t_class_type = Odoc_class.t_class_type =
    {
    clt_name: Name.t [@ocaml.doc " Complete name of the type. "];
    mutable clt_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    clt_type: Types.class_type ;
    clt_type_parameters: Types.type_expr list
      [@ocaml.doc " Type parameters. "];
    clt_virtual: bool [@ocaml.doc " [true] if the class type is virtual "];
    mutable clt_kind: class_type_kind
      [@ocaml.doc " The way the class type is defined. "];
    mutable clt_loc: location }[@@ocaml.doc
                                 " Representation of a class type. "]
  [@@@ocaml.text " {1 Functions} "]
  val class_elements : ?trans:bool -> t_class -> class_element list[@@ocaml.doc
                                                                    " Access to the elements of a class. "]
  val class_attributes : ?trans:bool -> t_class -> Value.t_attribute list
  [@@ocaml.doc " Access to the list of class attributes. "]
  val class_parameter_text_by_name : t_class -> string -> text option
  [@@ocaml.doc
    " Access to the description associated to the given class parameter name. "]
  val class_methods : ?trans:bool -> t_class -> Value.t_method list[@@ocaml.doc
                                                                    " Access to the methods of a class. "]
  val class_comments : ?trans:bool -> t_class -> text list[@@ocaml.doc
                                                            " Access to the comments of a class. "]
  val class_type_elements : ?trans:bool -> t_class_type -> class_element list
  [@@ocaml.doc " Access to the elements of a class type. "]
  val class_type_attributes :
    ?trans:bool -> t_class_type -> Value.t_attribute list[@@ocaml.doc
                                                           " Access to the list of class type attributes. "]
  val class_type_parameter_text_by_name :
    t_class_type -> string -> text option[@@ocaml.doc
                                           " Access to the description associated to the given class type parameter name. "]
  val class_type_methods : ?trans:bool -> t_class_type -> Value.t_method list
  [@@ocaml.doc " Access to the methods of a class type. "]
  val class_type_comments : ?trans:bool -> t_class_type -> text list[@@ocaml.doc
                                                                    " Access to the comments of a class type. "]
end[@@ocaml.doc
     " Representation and manipulation of classes and class types."]
module Module :
sig
  [@@@ocaml.text " {1 Types} "]
  type module_element = Odoc_module.module_element =
    | Element_module of t_module 
    | Element_module_type of t_module_type 
    | Element_included_module of included_module 
    | Element_class of Class.t_class 
    | Element_class_type of Class.t_class_type 
    | Element_value of Value.t_value 
    | Element_type_extension of Extension.t_type_extension 
    | Element_exception of Exception.t_exception 
    | Element_type of Type.t_type 
    | Element_module_comment of text [@@ocaml.doc
                                       " To keep the order of elements in a module. "]
  and mmt = Odoc_module.mmt =
    | Mod of t_module 
    | Modtype of t_module_type [@@ocaml.doc
                                 " Used where we can reference t_module or t_module_type. "]
  and included_module = Odoc_module.included_module =
    {
    im_name: Name.t [@ocaml.doc " Complete name of the included module. "];
    mutable im_module: mmt option
      [@ocaml.doc " The included module or module type, if we found it. "];
    mutable im_info: Odoc_types.info option
      [@ocaml.doc " comment associated with the include directive "]}
  and module_alias = Odoc_module.module_alias =
    {
    ma_name: Name.t [@ocaml.doc " Complete name of the target module. "];
    mutable ma_module: mmt option
      [@ocaml.doc
        " The real module or module type if we could associate it. "]}
  and module_parameter = Odoc_module.module_parameter =
    {
    mp_name: string [@ocaml.doc " the name "];
    mp_type: Types.module_type option [@ocaml.doc " the type "];
    mp_type_code: string [@ocaml.doc " the original code "];
    mp_kind: module_type_kind
      [@ocaml.doc " the way the parameter was built "]}
  and module_kind = Odoc_module.module_kind =
    | Module_struct of module_element list
    [@ocaml.doc " A complete module structure. "]
    | Module_alias of module_alias
    [@ocaml.doc " Complete name and corresponding module if we found it "]
    | Module_functor of module_parameter * module_kind
    [@ocaml.doc
      " A functor, with its parameter and the rest of its definition "]
    | Module_apply of module_kind * module_kind
    [@ocaml.doc " A module defined by application of a functor. "]
    | Module_with of module_type_kind * string
    [@ocaml.doc
      " A module whose type is a with ... constraint.\n                        Should appear in interface files only. "]
    | Module_constraint of module_kind * module_type_kind
    [@ocaml.doc " A module constraint by a module type. "]
    | Module_typeof of string
    [@ocaml.doc " by now only the code of the module expression "]
    | Module_unpack of string * module_type_alias
    [@ocaml.doc " code of the expression and module type alias "][@@ocaml.doc
                                                                   " Different kinds of a module. "]
  and t_module = Odoc_module.t_module =
    {
    m_name: Name.t [@ocaml.doc " Complete name of the module. "];
    mutable m_type: Types.module_type
      [@ocaml.doc " The type of the module. "];
    mutable m_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    m_is_interface: bool
      [@ocaml.doc " [true] for modules read from interface files "];
    m_file: string [@ocaml.doc " The file the module is defined in. "];
    mutable m_kind: module_kind
      [@ocaml.doc " The way the module is defined. "];
    mutable m_loc: location ;
    mutable m_top_deps: Name.t list
      [@ocaml.doc " The toplevels module names this module depends on. "];
    mutable m_code: string option
      [@ocaml.doc " The whole code of the module "];
    mutable m_code_intf: string option
      [@ocaml.doc " The whole code of the interface of the module "];
    m_text_only: bool
      [@ocaml.doc " [true] if the module comes from a text file "]}[@@ocaml.doc
                                                                    " Representation of a module. "]
  and module_type_alias = Odoc_module.module_type_alias =
    {
    mta_name: Name.t
      [@ocaml.doc " Complete name of the target module type. "];
    mutable mta_module: t_module_type option
      [@ocaml.doc " The real module type if we could associate it. "]}
  and module_type_kind = Odoc_module.module_type_kind =
    | Module_type_struct of module_element list
    [@ocaml.doc " A complete module signature. "]
    | Module_type_functor of module_parameter * module_type_kind
    [@ocaml.doc
      " A functor, with its parameter and the rest of its definition "]
    | Module_type_alias of module_type_alias
    [@ocaml.doc
      " Complete alias name and corresponding module type if we found it. "]
    | Module_type_with of module_type_kind * string
    [@ocaml.doc
      " The module type kind and the code of the with constraint. "]
    | Module_type_typeof of string
    [@ocaml.doc " by now only the code of the module expression "][@@ocaml.doc
                                                                    " Different kinds of module type. "]
  and t_module_type = Odoc_module.t_module_type =
    {
    mt_name: Name.t [@ocaml.doc " Complete name of the module type. "];
    mutable mt_info: info option
      [@ocaml.doc " Information found in the optional associated comment. "];
    mutable mt_type: Types.module_type option
      [@ocaml.doc " [None] means that the module type is abstract. "];
    mt_is_interface: bool
      [@ocaml.doc " [true] for modules read from interface files. "];
    mt_file: string [@ocaml.doc " The file the module type is defined in. "];
    mutable mt_kind: module_type_kind option
      [@ocaml.doc
        " The way the module is defined. [None] means that module type is abstract.\n                 It is always [None] when the module type was extracted from the implementation file.\n                 That means module types are only analysed in interface files. "];
    mutable mt_loc: location }[@@ocaml.doc
                                " Representation of a module type. "]
  [@@@ocaml.text " {1 Functions for modules} "]
  val module_elements : ?trans:bool -> t_module -> module_element list
  [@@ocaml.doc " Access to the elements of a module. "]
  val module_modules : ?trans:bool -> t_module -> t_module list[@@ocaml.doc
                                                                 " Access to the submodules of a module. "]
  val module_module_types : ?trans:bool -> t_module -> t_module_type list
  [@@ocaml.doc " Access to the module types of a module. "]
  val module_included_modules :
    ?trans:bool -> t_module -> included_module list[@@ocaml.doc
                                                     " Access to the included modules of a module. "]
  val module_type_extensions :
    ?trans:bool -> t_module -> Extension.t_type_extension list[@@ocaml.doc
                                                                " Access to the type extensions of a module. "]
  val module_exceptions :
    ?trans:bool -> t_module -> Exception.t_exception list[@@ocaml.doc
                                                           " Access to the exceptions of a module. "]
  val module_types : ?trans:bool -> t_module -> Type.t_type list[@@ocaml.doc
                                                                  " Access to the types of a module. "]
  val module_values : ?trans:bool -> t_module -> Value.t_value list[@@ocaml.doc
                                                                    " Access to the values of a module. "]
  val module_functions : ?trans:bool -> t_module -> Value.t_value list
  [@@ocaml.doc " Access to functional values of a module. "]
  val module_simple_values : ?trans:bool -> t_module -> Value.t_value list
  [@@ocaml.doc " Access to non-functional values of a module. "]
  val module_classes : ?trans:bool -> t_module -> Class.t_class list[@@ocaml.doc
                                                                    " Access to the classes of a module. "]
  val module_class_types : ?trans:bool -> t_module -> Class.t_class_type list
  [@@ocaml.doc " Access to the class types of a module. "]
  val module_all_classes : ?trans:bool -> t_module -> Class.t_class list
  [@@ocaml.doc
    " The list of classes defined in this module and all its submodules and functors. "]
  val module_is_functor : t_module -> bool[@@ocaml.doc
                                            " [true] if the module is functor. "]
  val module_parameters :
    ?trans:bool -> t_module -> (module_parameter * text option) list[@@ocaml.doc
                                                                    " The list of couples (module parameter, optional description). "]
  val module_comments : ?trans:bool -> t_module -> text list[@@ocaml.doc
                                                              " The list of module comments. "]
  [@@@ocaml.text " {1 Functions for module types} "]
  val module_type_elements :
    ?trans:bool -> t_module_type -> module_element list[@@ocaml.doc
                                                         " Access to the elements of a module type. "]
  val module_type_modules : ?trans:bool -> t_module_type -> t_module list
  [@@ocaml.doc " Access to the submodules of a module type. "]
  val module_type_module_types :
    ?trans:bool -> t_module_type -> t_module_type list[@@ocaml.doc
                                                        " Access to the module types of a module type. "]
  val module_type_included_modules :
    ?trans:bool -> t_module_type -> included_module list[@@ocaml.doc
                                                          " Access to the included modules of a module type. "]
  val module_type_exceptions :
    ?trans:bool -> t_module_type -> Exception.t_exception list[@@ocaml.doc
                                                                " Access to the exceptions of a module type. "]
  val module_type_types : ?trans:bool -> t_module_type -> Type.t_type list
  [@@ocaml.doc " Access to the types of a module type. "]
  val module_type_values : ?trans:bool -> t_module_type -> Value.t_value list
  [@@ocaml.doc " Access to the values of a module type. "]
  val module_type_functions :
    ?trans:bool -> t_module_type -> Value.t_value list[@@ocaml.doc
                                                        " Access to functional values of a module type. "]
  val module_type_simple_values :
    ?trans:bool -> t_module_type -> Value.t_value list[@@ocaml.doc
                                                        " Access to non-functional values of a module type. "]
  val module_type_classes :
    ?trans:bool -> t_module_type -> Class.t_class list[@@ocaml.doc
                                                        " Access to the classes of a module type. "]
  val module_type_class_types :
    ?trans:bool -> t_module_type -> Class.t_class_type list[@@ocaml.doc
                                                             " Access to the class types of a module type. "]
  val module_type_all_classes :
    ?trans:bool -> t_module_type -> Class.t_class list[@@ocaml.doc
                                                        " The list of classes defined in this module type and all its submodules and functors. "]
  val module_type_is_functor : t_module_type -> bool[@@ocaml.doc
                                                      " [true] if the module type is functor. "]
  val module_type_parameters :
    ?trans:bool -> t_module_type -> (module_parameter * text option) list
  [@@ocaml.doc
    " The list of couples (module parameter, optional description). "]
  val module_type_comments : ?trans:bool -> t_module_type -> text list
  [@@ocaml.doc " The list of module comments. "]
end[@@ocaml.doc
     " Representation and manipulation of modules and module types. "]
[@@@ocaml.text " {2 Getting strings from values} "]
val reset_type_names : unit -> unit[@@ocaml.doc
                                     " This function is used to reset the names of type variables.\n   It must be called when printing the whole type of a function,\n   but not when printing the type of its parameters. Same for\n   classes (call it) and methods and attributes (don't call it)."]
val string_of_variance : Type.t_type -> (bool * bool) -> string[@@ocaml.doc
                                                                 " [string_of_variance t (covariant, invariant)] returns [\"+\"] if\n   the given information means \"covariant\", [\"-\"] if it means\n   \"contravariant\", orelse [\"\"], and always [\"\"] if the given\n   type is not an abstract type with no manifest (i.e. no need\n   for the variance to be printed)."]
val string_of_type_expr : Types.type_expr -> string[@@ocaml.doc
                                                     " This function returns a string representing a Types.type_expr. "]
val string_of_class_params : Class.t_class -> string[@@ocaml.doc
                                                      " @return a string to display the parameters of the given class,\n   in the same form as the compiler. "]
val string_of_type_list :
  ?par:bool -> string -> Types.type_expr list -> string[@@ocaml.doc
                                                         " This function returns a string to represent the given list of types,\n   with a given separator. "]
val string_of_type_param_list : Type.t_type -> string[@@ocaml.doc
                                                       " This function returns a string to represent the list of type parameters\n   for the given type. "]
val string_of_type_extension_param_list :
  Extension.t_type_extension -> string[@@ocaml.doc
                                        " This function returns a string to represent the list of type parameters\n   for the given type extension. "]
val string_of_class_type_param_list : Types.type_expr list -> string[@@ocaml.doc
                                                                    " This function returns a string to represent the given list of\n   type parameters of a class or class type,\n   with a given separator. "]
val string_of_module_type :
  ?code:string -> ?complete:bool -> Types.module_type -> string[@@ocaml.doc
                                                                 " This function returns a string representing a [Types.module_type].\n   @param complete indicates if we must print complete signatures\n   or just [sig end]. Default is [false].\n   @param code if [complete = false] and the type contains something else\n   than identificators and functors, then the given code is used.\n"]
val string_of_class_type : ?complete:bool -> Types.class_type -> string
[@@ocaml.doc
  " This function returns a string representing a [Types.class_type].\n   @param complete indicates if we must print complete signatures\n   or just [object end]. Default is [false].\n"]
val string_of_text : text -> string[@@ocaml.doc
                                     " Get a string from a text. "]
val string_of_info : info -> string[@@ocaml.doc
                                     " Get a string from an info structure. "]
val string_of_type : Type.t_type -> string[@@ocaml.doc
                                            " @return a string to describe the given type. "]
val string_of_record : Type.record_field list -> string
val string_of_type_extension : Extension.t_type_extension -> string[@@ocaml.doc
                                                                    " @return a string to describe the given type extension. "]
val string_of_exception : Exception.t_exception -> string[@@ocaml.doc
                                                           " @return a string to describe the given exception. "]
val string_of_value : Value.t_value -> string[@@ocaml.doc
                                               " @return a string to describe the given value. "]
val string_of_attribute : Value.t_attribute -> string[@@ocaml.doc
                                                       " @return a string to describe the given attribute. "]
val string_of_method : Value.t_method -> string[@@ocaml.doc
                                                 " @return a string to describe the given method. "]
[@@@ocaml.text " {2 Miscellaneous functions} "]
val first_sentence_of_text : text -> text[@@ocaml.doc
                                           " Return the first sentence (until the first dot followed by a blank\n   or the first blank line) of a text.\n   Don't stop in the middle of [Code], [CodePre], [Verbatim], [List], [Enum],\n   [Latex], [Link], [Ref], [Subscript] or [Superscript]. "]
val first_sentence_and_rest_of_text : text -> (text * text)[@@ocaml.doc
                                                             " Return the first sentence (until the first dot followed by a blank\n   or the first blank line) of a text, and the remaining text after.\n   Don't stop in the middle of [Code], [CodePre], [Verbatim], [List], [Enum],\n   [Latex], [Link], [Ref], [Subscript] or [Superscript]."]
val text_no_title_no_list : text -> text[@@ocaml.doc
                                          " Return the given [text] without any title or list. "]
val text_concat : Odoc_types.text -> Odoc_types.text list -> Odoc_types.text
[@@ocaml.doc
  " [concat sep l] concats the given list of text [l], each separated with\n   the text [sep]. "]
val get_titles_in_text : text -> (int * string option * text) list[@@ocaml.doc
                                                                    " Return the list of titles in a [text].\n   A title is a title level, an optional label and a text."]
val create_index_lists : 'a list -> ('a -> string) -> 'a list list[@@ocaml.doc
                                                                    " Take a sorted list of elements, a function to get the name\n   of an element and return the list of list of elements,\n   where each list group elements beginning by the same letter.\n   Since the original list is sorted, elements whose name does not\n   begin with a letter should be in the first returned list."]
val remove_option : Types.type_expr -> Types.type_expr[@@ocaml.doc
                                                        " Take a type and remove the option top constructor. This is\n   useful when printing labels, we then remove the top option constructor\n   for optional labels."]
val is_optional : Asttypes.arg_label -> bool[@@ocaml.doc
                                              " Return [true] if the given label is optional."]
val label_name : Asttypes.arg_label -> string[@@ocaml.doc
                                               " Return the label name for the given label,\n   i.e. removes the beginning '?' if present."]
val use_hidden_modules : Name.t -> Name.t[@@ocaml.doc
                                           " Return the given name where the module name or\n   part of it was removed, according to the list of modules\n   which must be hidden (cf {!Odoc_args.hidden_modules})"]
val verbose : string -> unit[@@ocaml.doc
                              " Print the given string if the verbose mode is activated. "]
val warning : string -> unit[@@ocaml.doc
                              " Print a warning message to stderr.\n   If warnings must be treated as errors, then the\n   error counter is incremented. "]
val print_warnings : bool ref[@@ocaml.doc
                               " A flag to indicate whether ocamldoc warnings must be printed or not. "]
val errors : int ref[@@ocaml.doc
                      " Increment this counter when an error is encountered.\n   The ocamldoc tool will print the number of errors\n   encountered exit with code 1 if this number is greater\n   than 0. "]
val apply_opt : ('a -> 'b) -> 'a option -> 'b option[@@ocaml.doc
                                                      " Apply a function to an optional value. "]
val apply_if_equal : ('a -> 'a) -> 'a -> 'a -> 'a[@@ocaml.doc
                                                   " Apply a function to a first value if it is\n   not different from a second value. If the two values\n   are different, return the second one."]
val text_of_string : string -> text[@@ocaml.doc
                                     " [text_of_string s] returns the text structure from the\n   given string.\n   @raise Text_syntax if a syntax error is encountered. "]
val text_string_of_text : text -> string[@@ocaml.doc
                                          " [text_string_of_text text] returns the string representing\n   the given [text]. This string can then be parsed again\n   by {!Odoc_info.text_of_string}."]
val info_of_string : string -> info[@@ocaml.doc
                                     " [info_of_string s] parses the given string\n   like a regular ocamldoc comment and return an\n   {!Odoc_info.info} structure.\n   @return an empty structure if there was a syntax error. TODO: change this\n"]
val info_string_of_info : info -> string[@@ocaml.doc
                                          " [info_string_of_info info] returns the string representing\n   the given [info]. This string can then be parsed again\n   by {!Odoc_info.info_of_string}."]
val info_of_comment_file : Module.t_module list -> string -> info[@@ocaml.doc
                                                                   " [info_of_comment_file file] parses the given file\n   and return an {!Odoc_info.info} structure. The content of the\n   file must have the same syntax as the content of a special comment.\n   The given module list is used for cross reference.\n   @raise Failure if the file could not be opened or there is a\n   syntax error.\n"]
val remove_ending_newline : string -> string[@@ocaml.doc
                                              " [remove_ending_newline s] returns [s] without the optional ending newline. "]
module Search :
sig
  type result_element = Odoc_search.result_element =
    | Res_module of Module.t_module 
    | Res_module_type of Module.t_module_type 
    | Res_class of Class.t_class 
    | Res_class_type of Class.t_class_type 
    | Res_value of Value.t_value 
    | Res_type of Type.t_type 
    | Res_extension of Extension.t_extension_constructor 
    | Res_exception of Exception.t_exception 
    | Res_attribute of Value.t_attribute 
    | Res_method of Value.t_method 
    | Res_section of string * text 
    | Res_recfield of Type.t_type * Type.record_field 
    | Res_const of Type.t_type * Type.variant_constructor 
  type search_result = result_element list[@@ocaml.doc
                                            " The type representing a research result."]
  val search_by_name : Module.t_module list -> Str.regexp -> search_result
  [@@ocaml.doc
    " Research of the elements whose name matches the given regular expression."]
  val values : Module.t_module list -> Value.t_value list[@@ocaml.doc
                                                           " A function to search all the values in a list of modules. "]
  val extensions :
    Module.t_module list -> Extension.t_extension_constructor list[@@ocaml.doc
                                                                    " A function to search all the extensions in a list of modules. "]
  val exceptions : Module.t_module list -> Exception.t_exception list
  [@@ocaml.doc
    " A function to search all the exceptions in a list of modules. "]
  val types : Module.t_module list -> Type.t_type list[@@ocaml.doc
                                                        " A function to search all the types in a list of modules. "]
  val attributes : Module.t_module list -> Value.t_attribute list[@@ocaml.doc
                                                                   " A function to search all the class attributes in a list of modules. "]
  val methods : Module.t_module list -> Value.t_method list[@@ocaml.doc
                                                             " A function to search all the class methods in a list of modules. "]
  val classes : Module.t_module list -> Class.t_class list[@@ocaml.doc
                                                            " A function to search all the classes in a list of modules. "]
  val class_types : Module.t_module list -> Class.t_class_type list[@@ocaml.doc
                                                                    " A function to search all the class types in a list of modules. "]
  val modules : Module.t_module list -> Module.t_module list[@@ocaml.doc
                                                              " A function to search all the modules in a list of modules. "]
  val module_types : Module.t_module list -> Module.t_module_type list
  [@@ocaml.doc
    " A function to search all the module types in a list of modules. "]
end[@@ocaml.doc " Research in elements "]
module Scan :
sig
  class scanner :
    object
      method  scan_value : Value.t_value -> unit
      method  scan_type_pre : Type.t_type -> bool
      method  scan_type_const :
        Type.t_type -> Type.variant_constructor -> unit
      method  scan_type_recfield : Type.t_type -> Type.record_field -> unit
      method  scan_type : Type.t_type -> unit
      method  scan_extension_constructor :
        Extension.t_extension_constructor -> unit
      method  scan_exception : Exception.t_exception -> unit
      method  scan_attribute : Value.t_attribute -> unit
      method  scan_method : Value.t_method -> unit
      method  scan_included_module : Module.included_module -> unit
      [@@@ocaml.text " Scan of a type extension "]
      method  scan_type_extension_pre : Extension.t_type_extension -> bool
      [@@ocaml.doc
        " Override this method to perform controls on the extension's type,\n            private and info. This method is called before scanning the\n            extension's constructors.\n            @return true if the extension's constructors must be scanned."]
      method  scan_type_extension_constructors :
        Extension.t_type_extension -> unit[@@ocaml.doc
                                            " This method scans the constructors of the given type extension. "]
      method  scan_type_extension : Extension.t_type_extension -> unit
      [@@ocaml.doc
        " Scan of a type extension. Should not be overridden. It calls [scan_type_extension_pre]\n            and if [scan_type_extension_pre] returns [true], then it calls scan_type_extension_constructors."]
      [@@@ocaml.text " Scan of a class. "]
      method  scan_class_comment : text -> unit[@@ocaml.doc
                                                 " Scan of a comment inside a class. "]
      method  scan_class_pre : Class.t_class -> bool[@@ocaml.doc
                                                      " Override this method to perform controls on the class comment\n          and params. This method is called before scanning the class elements.\n          @return true if the class elements must be scanned."]
      method  scan_class_elements : Class.t_class -> unit[@@ocaml.doc
                                                           " This method scans the elements of the given class. "]
      method  scan_class : Class.t_class -> unit[@@ocaml.doc
                                                  " Scan of a class. Should not be overridden. It calls [scan_class_pre]\n          and if [scan_class_pre] returns [true], then it calls scan_class_elements."]
      [@@@ocaml.text " Scan of a class type. "]
      method  scan_class_type_comment : text -> unit[@@ocaml.doc
                                                      " Scan of a comment inside a class type. "]
      method  scan_class_type_pre : Class.t_class_type -> bool[@@ocaml.doc
                                                                " Override this method to perform controls on the class type comment\n           and form. This method is called before scanning the class type elements.\n           @return true if the class type elements must be scanned."]
      method  scan_class_type_elements : Class.t_class_type -> unit[@@ocaml.doc
                                                                    " This method scans the elements of the given class type. "]
      method  scan_class_type : Class.t_class_type -> unit[@@ocaml.doc
                                                            " Scan of a class type. Should not be overridden. It calls [scan_class_type_pre]\n           and if [scan_class_type_pre] returns [true], then it calls scan_class_type_elements."]
      [@@@ocaml.text " Scan of modules. "]
      method  scan_module_comment : text -> unit[@@ocaml.doc
                                                  " Scan of a comment inside a module. "]
      method  scan_module_pre : Module.t_module -> bool[@@ocaml.doc
                                                         " Override this method to perform controls on the module comment\n           and form. This method is called before scanning the module elements.\n           @return true if the module elements must be scanned."]
      method  scan_module_elements : Module.t_module -> unit[@@ocaml.doc
                                                              " This method scans the elements of the given module. "]
      method  scan_module : Module.t_module -> unit[@@ocaml.doc
                                                     " Scan of a module. Should not be overridden. It calls [scan_module_pre]\n          and if [scan_module_pre] returns [true], then it calls scan_module_elements."]
      [@@@ocaml.text " Scan of module types. "]
      method  scan_module_type_comment : text -> unit[@@ocaml.doc
                                                       " Scan of a comment inside a module type. "]
      method  scan_module_type_pre : Module.t_module_type -> bool[@@ocaml.doc
                                                                   " Override this method to perform controls on the module type comment\n           and form. This method is called before scanning the module type elements.\n           @return true if the module type elements must be scanned. "]
      method  scan_module_type_elements : Module.t_module_type -> unit
      [@@ocaml.doc
        " This method scans the elements of the given module type. "]
      method  scan_module_type : Module.t_module_type -> unit[@@ocaml.doc
                                                               " Scan of a module type. Should not be overridden. It calls [scan_module_type_pre]\n           and if [scan_module_type_pre] returns [true], then it calls scan_module_type_elements."]
      [@@@ocaml.text " Main scanning method. "]
      method  scan_module_list : Module.t_module list -> unit[@@ocaml.doc
                                                               " Scan a list of modules. "]
    end
end[@@ocaml.doc " Scanning of collected information "]
module Dep :
sig
  val kernel_deps_of_modules : Module.t_module list -> unit[@@ocaml.doc
                                                             " Modify the module dependencies of the given list of modules,\n       to get the minimum transitivity kernel. "]
  val deps_of_types :
    ?kernel:bool -> Type.t_type list -> (Type.t_type * Name.t list) list
  [@@ocaml.doc
    " Return the list of dependencies between the given types,\n       in the form of a list [(type name, names of types it depends on)].\n       @param kernel indicates if we must keep only the transitivity kernel\n       of the dependencies. Default is [false].\n    "]
end[@@ocaml.doc " Computation of dependencies. "]
[@@@ocaml.text " {1 Some global variables} "]
module Global :
sig
  val errors : int ref
  val warn_error : bool ref
  val out_file : string ref[@@ocaml.doc
                             " The file used by the generators outputting only one file. "]
  val verbose : bool ref[@@ocaml.doc " Verbose mode or not. "]
  val target_dir : string ref[@@ocaml.doc
                               " The directory where files have to be generated. "]
  val title : string option ref[@@ocaml.doc
                                 " The optional title to use in the generated documentation. "]
  val intro_file : string option ref[@@ocaml.doc
                                      " The optional file whose content can be used as intro text. "]
  val with_toc : bool ref[@@ocaml.doc
                           " The flag which indicates if we must generate a table of contents. "]
  val with_index : bool ref[@@ocaml.doc
                             " The flag which indicates if we must generate an index. "]
  val with_header : bool ref[@@ocaml.doc
                              " The flag which indicates if we must generate a header."]
  val with_trailer : bool ref[@@ocaml.doc
                               " The flag which indicates if we must generate a trailer."]
end
val analyse_files :
  ?merge_options:Odoc_types.merge_option list ->
    ?include_dirs:string list ->
      ?labels:bool ->
        ?sort_modules:bool ->
          ?no_stop:bool ->
            ?init:Odoc_module.t_module list ->
              Odoc_global.source_file list -> Module.t_module list[@@ocaml.doc
                                                                    " Analysis of the given source files.\n   @param init is the list of modules already known from a previous analysis.\n   @return the list of analysed top modules. "]
val dump_modules : string -> Odoc_module.t_module list -> unit[@@ocaml.doc
                                                                " Dump of a list of modules into a file.\n   @raise Failure if an error occurs."]
val load_modules : string -> Odoc_module.t_module list[@@ocaml.doc
                                                        " Load of a list of modules from a file.\n   @raise Failure if an error occurs."]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text " Interface to the information collected in source files. "]

type ref_kind = Odoc_types.ref_kind =
| RK_module 
| RK_module_type 
| RK_class 
| RK_class_type 
| RK_value 
| RK_type 
| RK_extension 
| RK_exception 
| RK_attribute 
| RK_method 
| RK_section of text 
| RK_recfield 
| RK_const [@@ocaml.doc " The different kinds of element references. "]
  
and text_element = Odoc_types.text_element =
| Raw of string [@ocaml.doc " Raw text. "]
| Code of string [@ocaml.doc " The string is source code. "]
| CodePre of string
[@ocaml.doc " The string is pre-formatted source code. "]
| Verbatim of string [@ocaml.doc " String 'as is'. "]
| Bold of text [@ocaml.doc " Text in bold style. "]
| Italic of text [@ocaml.doc " Text in italic. "]
| Emphasize of text [@ocaml.doc " Emphasized text. "]
| Center of text [@ocaml.doc " Centered text. "]
| Left of text [@ocaml.doc " Left alignment. "]
| Right of text [@ocaml.doc " Right alignment. "]
| List of text list [@ocaml.doc " A list. "]
| Enum of text list [@ocaml.doc " An enumerated list. "]
| Newline [@ocaml.doc " To force a line break. "]
| Block of text [@ocaml.doc " Like html's block quote. "]
| Title of int * string option * text
[@ocaml.doc " Style number, optional label, and text. "]
| Latex of string [@ocaml.doc " A string for latex. "]
| Link of string * text
[@ocaml.doc " A reference string and the link text. "]
| Ref of string * ref_kind option * text option
[@ocaml.doc
  " A reference to an element. Complete name and kind.\n        An optional text can be given to display this text instead\n        of the element name."]
| Superscript of text [@ocaml.doc " Superscripts. "]
| Subscript of text [@ocaml.doc " Subscripts. "]
| Module_list of string list
[@ocaml.doc " The table of the given modules with their abstract. "]
| Index_list
[@ocaml.doc " The links to the various indexes (values, types, ...) "]
| Custom of string * text [@ocaml.doc " to extend \\{foo syntax "]
| Target of string * string
[@ocaml.doc " (target, code) : to specify code specific to a target format "]
  
and text = text_element list[@@ocaml.doc
                              " A text is a list of [text_element]. The order matters. "]
  

type see_ref = Odoc_types.see_ref =
| See_url of string 
| See_file of string 
| See_doc of string [@@ocaml.doc
                      " The different forms of references in \\@see tags. "]
  

exception Text_syntax of int * int * string
  [@ocaml.doc
    " Raised when parsing string to build a {!Odoc_info.text}\n   structure. [(line, char, string)] "]

type see = (see_ref * text)[@@ocaml.doc " The information in a \\@see tag. "]
  

type param = (string * text)[@@ocaml.doc " Parameter name and description. "]
  

type raised_exception = (string * text)[@@ocaml.doc
                                         " Raised exception name and description. "]
  

type info = Odoc_types.info =
{
i_desc: text option [@ocaml.doc " The description text. "];
i_authors: string list
  [@ocaml.doc " The list of authors in \\@author tags. "];
i_version: string option [@ocaml.doc " The string in the \\@version tag. "];
i_sees: see list [@ocaml.doc " The list of \\@see tags. "];
i_since: string option [@ocaml.doc " The string in the \\@since tag. "];
i_before: (string * text) list
  [@ocaml.doc " the version number and text in \\@before tag "];
i_deprecated: text option
  [@ocaml.doc " The description text of the \\@deprecated tag. "];
i_params: param list [@ocaml.doc " The list of parameter descriptions. "];
i_raised_exceptions: raised_exception list
  [@ocaml.doc " The list of raised exceptions. "];
i_return_value: text option
  [@ocaml.doc " The description text of the return value. "];
i_custom: (string * text) list
  [@ocaml.doc " A text associated to a custom @-tag. "]}[@@ocaml.doc
                                                          " Information in a special comment\n@before 3.12.0 \\@before information was not present.\n"]
  

type location = Odoc_types.location =
{
loc_impl: Location.t option [@ocaml.doc " implementation location "];
loc_inter: Location.t option [@ocaml.doc " interface location "]}[@@ocaml.doc
                                                                   " Location of elements in implementation and interface files. "]
  

val dummy_loc : location[@@ocaml.doc " A dummy location. "]


module Name :
sig
  type t = string
    
  val simple : t -> t[@@ocaml.doc " Access to the simple name. "]
  
  val concat : t -> t -> t[@@ocaml.doc
                            " [concat t1 t2] returns the concatenation of [t1] and [t2]."]
  
  val depth : t -> int[@@ocaml.doc
                        " Return the depth of the name, i.e. the number of levels to the root.\n         Example : [depth \"Toto.Tutu.name\"] = [3]. "]
  
  val get_relative : t -> t -> t[@@ocaml.doc
                                  " Take two names n1 and n2 = n3.n4 and return n4 if n3=n1 or else n2. "]
  
  val get_relative_opt : t -> t -> t[@@ocaml.doc
                                      " Take two names n1 and n2 = n3.n4 and return n4 if n3=n1 and n1<>\"\" or else n2. "]
  
  val father : t -> t[@@ocaml.doc
                       " Return the name of the 'father' (like [dirname] for a file name)."]
  
end[@@ocaml.doc " Representation of element names. "]

module Parameter :
sig
  [@@@ocaml.text " {1 Types} "]
  type simple_name = Odoc_parameter.simple_name =
  {
  sn_name: string ;
  sn_type: Types.type_expr ;
  mutable sn_text: text option }[@@ocaml.doc
                                  " Representation of a simple parameter name "]
    
  type param_info = Odoc_parameter.param_info =
  | Simple_name of simple_name 
  | Tuple of param_info list * Types.type_expr [@@ocaml.doc
                                                 " Representation of parameter names. We need it to represent parameter names in tuples.\n       The value [Tuple ([], t)] stands for an anonymous parameter."]
    
  type parameter = param_info[@@ocaml.doc
                               " A parameter is just a param_info."]
    
  [@@@ocaml.text " {1 Functions} "]
  val complete_name : parameter -> string[@@ocaml.doc
                                           " Access to the name as a string. For tuples, parentheses and commas are added. "]
  
  val typ : parameter -> Types.type_expr[@@ocaml.doc
                                          " Access to the complete type. "]
  
  val names : parameter -> string list[@@ocaml.doc
                                        " Access to the list of names ; only one for a simple parameter, or\n       a list for a tuple. "]
  
  val desc_by_name : parameter -> string -> text option[@@ocaml.doc
                                                         " Access to the description of a specific name.\n       @raise Not_found if no description is associated to the given name. "]
  
  val type_by_name : parameter -> string -> Types.type_expr[@@ocaml.doc
                                                             " Access to the type of a specific name.\n       @raise Not_found if no type is associated to the given name. "]
  
end[@@ocaml.doc
     " Representation and manipulation of method / function / class / module parameters."]

module Extension :
sig
  type private_flag = Odoc_extension.private_flag =
  | Private 
  | Public 
    
  type extension_alias = Odoc_extension.extension_alias =
  {
  xa_name: Name.t [@ocaml.doc " The complete name of the target extension. "];
  mutable xa_xt: t_extension_constructor option
    [@ocaml.doc " The target extension, if we found it."]}[@@ocaml.doc
                                                            " Used when the extension is a rebind of another extension,\n       when we have [extension Xt = Target_xt]."]
    
  and t_extension_constructor = Odoc_extension.t_extension_constructor =
  {
  xt_name: Name.t ;
  xt_args: Odoc_type.constructor_args ;
  xt_ret: Types.type_expr option
    [@ocaml.doc " the optional return type of the extension "];
  xt_type_extension: t_type_extension
    [@ocaml.doc " the type extension containing this constructor "];
  xt_alias: extension_alias option
    [@ocaml.doc " [None] when the extension is not a rebind. "];
  mutable xt_loc: Odoc_types.location ;
  mutable xt_text: Odoc_types.info option
    [@ocaml.doc " optional user description "]}
    
  and t_type_extension = Odoc_extension.t_type_extension =
  {
  mutable te_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  te_type_name: Name.t [@ocaml.doc " The type of the extension "];
  te_type_parameters: Types.type_expr list ;
  te_private: private_flag ;
  mutable te_constructors: t_extension_constructor list ;
  mutable te_loc: location ;
  mutable te_code: string option }
    
  val extension_constructors :
    t_type_extension -> t_extension_constructor list[@@ocaml.doc
                                                      " Access to the extensions in a group. "]
  
end[@@ocaml.doc " Representation and manipulation of extensions. "]

module Exception :
sig
  type exception_alias = Odoc_exception.exception_alias =
  {
  ea_name: Name.t [@ocaml.doc " The complete name of the target exception. "];
  mutable ea_ex: t_exception option
    [@ocaml.doc " The target exception, if we found it."]}[@@ocaml.doc
                                                            " Used when the exception is a rebind of another exception,\n       when we have [exception Ex = Target_ex]."]
    
  and t_exception = Odoc_exception.t_exception =
  {
  ex_name: Name.t ;
  mutable ex_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  ex_args: Odoc_type.constructor_args ;
  ex_ret: Types.type_expr option
    [@ocaml.doc " The optional return type of the exception. "];
  ex_alias: exception_alias option
    [@ocaml.doc " [None] when the exception is not a rebind. "];
  mutable ex_loc: location ;
  mutable ex_code: string option }
    
end[@@ocaml.doc " Representation and manipulation of exceptions. "]

module Type :
sig
  type private_flag = Odoc_type.private_flag =
  | Private 
  | Public 
    
  type record_field = Odoc_type.record_field =
  {
  rf_name: string [@ocaml.doc " Name of the field. "];
  rf_mutable: bool [@ocaml.doc " [true] if mutable. "];
  rf_type: Types.type_expr [@ocaml.doc " Type of the field. "];
  mutable rf_text: info option
    [@ocaml.doc " Optional description in the associated comment."]}[@@ocaml.doc
                                                                    " Description of a record type field. "]
    
  type constructor_args = Odoc_type.constructor_args =
  | Cstr_record of record_field list 
  | Cstr_tuple of Types.type_expr list [@@ocaml.doc
                                         " Description of a variant type constructor. "]
    
  type variant_constructor = Odoc_type.variant_constructor =
  {
  vc_name: string [@ocaml.doc " Name of the constructor. "];
  vc_args: constructor_args ;
  vc_ret: Types.type_expr option ;
  mutable vc_text: info option
    [@ocaml.doc " Optional description in the associated comment. "]}
    
  type type_kind = Odoc_type.type_kind =
  | Type_abstract [@ocaml.doc " Type is abstract, for example [type t]. "]
  | Type_variant of variant_constructor list [@ocaml.doc " constructors "]
  | Type_record of record_field list [@ocaml.doc " fields "]
  | Type_open [@ocaml.doc " Type is open "][@@ocaml.doc
                                             " The various kinds of a type. "]
    
  type object_field = Odoc_type.object_field =
  {
  of_name: string ;
  of_type: Types.type_expr ;
  mutable of_text: Odoc_types.info option
    [@ocaml.doc " optional user description "]}
    
  type type_manifest = Odoc_type.type_manifest =
  | Other of Types.type_expr
  [@ocaml.doc " Type manifest directly taken from Typedtree. "]
  | Object_type of object_field list 
    
  type t_type = Odoc_type.t_type =
  {
  ty_name: Name.t [@ocaml.doc " Complete name of the type. "];
  mutable ty_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  ty_parameters: (Types.type_expr * bool * bool) list
    [@ocaml.doc " type parameters: (type, covariant, contravariant) "];
  ty_kind: type_kind [@ocaml.doc " Type kind. "];
  ty_private: private_flag [@ocaml.doc " Private or public type. "];
  ty_manifest: type_manifest option ;
  mutable ty_loc: location ;
  mutable ty_code: string option }[@@ocaml.doc " Representation of a type. "]
    
end[@@ocaml.doc " Representation and manipulation of types."]

module Value :
sig
  type t_value = Odoc_value.t_value =
  {
  val_name: Name.t [@ocaml.doc " Complete name of the value. "];
  mutable val_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  val_type: Types.type_expr [@ocaml.doc " Type of the value. "];
  val_recursive: bool [@ocaml.doc " [true] if the value is recursive. "];
  mutable val_parameters: Odoc_parameter.parameter list
    [@ocaml.doc " The parameters, if any. "];
  mutable val_code: string option
    [@ocaml.doc
      " The code of the value, if we had the only the implementation file. "];
  mutable val_loc: location }[@@ocaml.doc " Representation of a value. "]
    
  type t_attribute = Odoc_value.t_attribute =
  {
  att_value: t_value
    [@ocaml.doc
      " an attribute has almost all the same information as a value "];
  att_mutable: bool [@ocaml.doc " [true] if the attribute is mutable. "];
  att_virtual: bool [@ocaml.doc " [true] if the attribute is virtual. "]}
  [@@ocaml.doc " Representation of a class attribute. "]
    
  type t_method = Odoc_value.t_method =
  {
  met_value: t_value
    [@ocaml.doc " a method has almost all the same information as a value "];
  met_private: bool [@ocaml.doc " [true] if the method is private."];
  met_virtual: bool [@ocaml.doc " [true] if the method is virtual. "]}
  [@@ocaml.doc " Representation of a class method. "]
    
  val is_function : t_value -> bool[@@ocaml.doc
                                     " Return [true] if the value is a function, i.e. it has a functional type. "]
  
  val value_parameter_text_by_name : t_value -> string -> text option
  [@@ocaml.doc
    " Access to the description associated to the given parameter name."]
  
end[@@ocaml.doc
     " Representation and manipulation of values, class attributes and class methods. "]

module Class :
sig
  [@@@ocaml.text " {1 Types} "]
  type class_element = Odoc_class.class_element =
  | Class_attribute of Value.t_attribute 
  | Class_method of Value.t_method 
  | Class_comment of text [@@ocaml.doc
                            " To keep the order of elements in a class. "]
    
  type cct = Odoc_class.cct =
  | Cl of t_class 
  | Cltype of t_class_type * Types.type_expr list
  [@ocaml.doc " Class type and type parameters. "][@@ocaml.doc
                                                    " Used when we can reference a t_class or a t_class_type. "]
    
  and inherited_class = Odoc_class.inherited_class =
  {
  ic_name: Name.t [@ocaml.doc " Complete name of the inherited class. "];
  mutable ic_class: cct option
    [@ocaml.doc " The associated t_class or t_class_type. "];
  ic_text: text option [@ocaml.doc " The inheritance description, if any. "]}
    
  and class_apply = Odoc_class.class_apply =
  {
  capp_name: Name.t [@ocaml.doc " The complete name of the applied class. "];
  mutable capp_class: t_class option
    [@ocaml.doc " The associated t_class if we found it. "];
  capp_params: Types.type_expr list
    [@ocaml.doc " The type of expressions the class is applied to. "];
  capp_params_code: string list
    [@ocaml.doc " The code of these expressions. "]}
    
  and class_constr = Odoc_class.class_constr =
  {
  cco_name: Name.t [@ocaml.doc " The complete name of the applied class. "];
  mutable cco_class: cct option
    [@ocaml.doc " The associated class or class type if we found it. "];
  cco_type_parameters: Types.type_expr list
    [@ocaml.doc " The type parameters of the class, if needed. "]}
    
  and class_kind = Odoc_class.class_kind =
  | Class_structure of inherited_class list * class_element list
  [@ocaml.doc
    " An explicit class structure, used in implementation and interface. "]
  | Class_apply of class_apply
  [@ocaml.doc " Application/alias of a class, used in implementation only. "]
  | Class_constr of class_constr
  [@ocaml.doc
    " A class used to give the type of the defined class,\n           instead of a structure, used in interface only.\n           For example, it will be used with the name [M1.M2....bar]\n           when the class foo is defined like this :\n           [class foo : int -> bar] "]
  | Class_constraint of class_kind * class_type_kind
  [@ocaml.doc " A class definition with a constraint. "]
    
  and t_class = Odoc_class.t_class =
  {
  cl_name: Name.t [@ocaml.doc " Complete name of the class. "];
  mutable cl_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  cl_type: Types.class_type [@ocaml.doc " Type of the class. "];
  cl_type_parameters: Types.type_expr list [@ocaml.doc " Type parameters. "];
  cl_virtual: bool [@ocaml.doc " [true] when the class is virtual. "];
  mutable cl_kind: class_kind [@ocaml.doc " The way the class is defined. "];
  mutable cl_parameters: Parameter.parameter list
    [@ocaml.doc " The parameters of the class. "];
  mutable cl_loc: location }[@@ocaml.doc " Representation of a class. "]
    
  and class_type_alias = Odoc_class.class_type_alias =
  {
  cta_name: Name.t [@ocaml.doc " Complete name of the target class type. "];
  mutable cta_class: cct option
    [@ocaml.doc " The target t_class or t_class_type, if we found it."];
  cta_type_parameters: Types.type_expr list
    [@ocaml.doc " The type parameters. FIXME : use strings? "]}
    
  and class_type_kind = Odoc_class.class_type_kind =
  | Class_signature of inherited_class list * class_element list 
  | Class_type of class_type_alias
  [@ocaml.doc " A class type eventually applied to type args. "]
    
  and t_class_type = Odoc_class.t_class_type =
  {
  clt_name: Name.t [@ocaml.doc " Complete name of the type. "];
  mutable clt_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  clt_type: Types.class_type ;
  clt_type_parameters: Types.type_expr list [@ocaml.doc " Type parameters. "];
  clt_virtual: bool [@ocaml.doc " [true] if the class type is virtual "];
  mutable clt_kind: class_type_kind
    [@ocaml.doc " The way the class type is defined. "];
  mutable clt_loc: location }[@@ocaml.doc
                               " Representation of a class type. "]
    
  [@@@ocaml.text " {1 Functions} "]
  val class_elements : ?trans:bool -> t_class -> class_element list[@@ocaml.doc
                                                                    " Access to the elements of a class. "]
  
  val class_attributes : ?trans:bool -> t_class -> Value.t_attribute list
  [@@ocaml.doc " Access to the list of class attributes. "]
  
  val class_parameter_text_by_name : t_class -> string -> text option
  [@@ocaml.doc
    " Access to the description associated to the given class parameter name. "]
  
  val class_methods : ?trans:bool -> t_class -> Value.t_method list[@@ocaml.doc
                                                                    " Access to the methods of a class. "]
  
  val class_comments : ?trans:bool -> t_class -> text list[@@ocaml.doc
                                                            " Access to the comments of a class. "]
  
  val class_type_elements : ?trans:bool -> t_class_type -> class_element list
  [@@ocaml.doc " Access to the elements of a class type. "]
  
  val class_type_attributes :
    ?trans:bool -> t_class_type -> Value.t_attribute list[@@ocaml.doc
                                                           " Access to the list of class type attributes. "]
  
  val class_type_parameter_text_by_name :
    t_class_type -> string -> text option[@@ocaml.doc
                                           " Access to the description associated to the given class type parameter name. "]
  
  val class_type_methods : ?trans:bool -> t_class_type -> Value.t_method list
  [@@ocaml.doc " Access to the methods of a class type. "]
  
  val class_type_comments : ?trans:bool -> t_class_type -> text list[@@ocaml.doc
                                                                    " Access to the comments of a class type. "]
  
end[@@ocaml.doc
     " Representation and manipulation of classes and class types."]

module Module :
sig
  [@@@ocaml.text " {1 Types} "]
  type module_element = Odoc_module.module_element =
  | Element_module of t_module 
  | Element_module_type of t_module_type 
  | Element_included_module of included_module 
  | Element_class of Class.t_class 
  | Element_class_type of Class.t_class_type 
  | Element_value of Value.t_value 
  | Element_type_extension of Extension.t_type_extension 
  | Element_exception of Exception.t_exception 
  | Element_type of Type.t_type 
  | Element_module_comment of text [@@ocaml.doc
                                     " To keep the order of elements in a module. "]
    
  and mmt = Odoc_module.mmt =
  | Mod of t_module 
  | Modtype of t_module_type [@@ocaml.doc
                               " Used where we can reference t_module or t_module_type. "]
    
  and included_module = Odoc_module.included_module =
  {
  im_name: Name.t [@ocaml.doc " Complete name of the included module. "];
  mutable im_module: mmt option
    [@ocaml.doc " The included module or module type, if we found it. "];
  mutable im_info: Odoc_types.info option
    [@ocaml.doc " comment associated with the include directive "]}
    
  and module_alias = Odoc_module.module_alias =
  {
  ma_name: Name.t [@ocaml.doc " Complete name of the target module. "];
  mutable ma_module: mmt option
    [@ocaml.doc " The real module or module type if we could associate it. "]}
    
  and module_parameter = Odoc_module.module_parameter =
  {
  mp_name: string [@ocaml.doc " the name "];
  mp_type: Types.module_type option [@ocaml.doc " the type "];
  mp_type_code: string [@ocaml.doc " the original code "];
  mp_kind: module_type_kind [@ocaml.doc " the way the parameter was built "]}
    
  and module_kind = Odoc_module.module_kind =
  | Module_struct of module_element list
  [@ocaml.doc " A complete module structure. "]
  | Module_alias of module_alias
  [@ocaml.doc " Complete name and corresponding module if we found it "]
  | Module_functor of module_parameter * module_kind
  [@ocaml.doc
    " A functor, with its parameter and the rest of its definition "]
  | Module_apply of module_kind * module_kind
  [@ocaml.doc " A module defined by application of a functor. "]
  | Module_with of module_type_kind * string
  [@ocaml.doc
    " A module whose type is a with ... constraint.\n                        Should appear in interface files only. "]
  | Module_constraint of module_kind * module_type_kind
  [@ocaml.doc " A module constraint by a module type. "]
  | Module_typeof of string
  [@ocaml.doc " by now only the code of the module expression "]
  | Module_unpack of string * module_type_alias
  [@ocaml.doc " code of the expression and module type alias "][@@ocaml.doc
                                                                 " Different kinds of a module. "]
    
  and t_module = Odoc_module.t_module =
  {
  m_name: Name.t [@ocaml.doc " Complete name of the module. "];
  mutable m_type: Types.module_type [@ocaml.doc " The type of the module. "];
  mutable m_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  m_is_interface: bool
    [@ocaml.doc " [true] for modules read from interface files "];
  m_file: string [@ocaml.doc " The file the module is defined in. "];
  mutable m_kind: module_kind [@ocaml.doc " The way the module is defined. "];
  mutable m_loc: location ;
  mutable m_top_deps: Name.t list
    [@ocaml.doc " The toplevels module names this module depends on. "];
  mutable m_code: string option [@ocaml.doc " The whole code of the module "];
  mutable m_code_intf: string option
    [@ocaml.doc " The whole code of the interface of the module "];
  m_text_only: bool
    [@ocaml.doc " [true] if the module comes from a text file "]}[@@ocaml.doc
                                                                   " Representation of a module. "]
    
  and module_type_alias = Odoc_module.module_type_alias =
  {
  mta_name: Name.t [@ocaml.doc " Complete name of the target module type. "];
  mutable mta_module: t_module_type option
    [@ocaml.doc " The real module type if we could associate it. "]}
    
  and module_type_kind = Odoc_module.module_type_kind =
  | Module_type_struct of module_element list
  [@ocaml.doc " A complete module signature. "]
  | Module_type_functor of module_parameter * module_type_kind
  [@ocaml.doc
    " A functor, with its parameter and the rest of its definition "]
  | Module_type_alias of module_type_alias
  [@ocaml.doc
    " Complete alias name and corresponding module type if we found it. "]
  | Module_type_with of module_type_kind * string
  [@ocaml.doc " The module type kind and the code of the with constraint. "]
  | Module_type_typeof of string
  [@ocaml.doc " by now only the code of the module expression "][@@ocaml.doc
                                                                  " Different kinds of module type. "]
    
  and t_module_type = Odoc_module.t_module_type =
  {
  mt_name: Name.t [@ocaml.doc " Complete name of the module type. "];
  mutable mt_info: info option
    [@ocaml.doc " Information found in the optional associated comment. "];
  mutable mt_type: Types.module_type option
    [@ocaml.doc " [None] means that the module type is abstract. "];
  mt_is_interface: bool
    [@ocaml.doc " [true] for modules read from interface files. "];
  mt_file: string [@ocaml.doc " The file the module type is defined in. "];
  mutable mt_kind: module_type_kind option
    [@ocaml.doc
      " The way the module is defined. [None] means that module type is abstract.\n                 It is always [None] when the module type was extracted from the implementation file.\n                 That means module types are only analysed in interface files. "];
  mutable mt_loc: location }[@@ocaml.doc
                              " Representation of a module type. "]
    
  [@@@ocaml.text " {1 Functions for modules} "]
  val module_elements : ?trans:bool -> t_module -> module_element list
  [@@ocaml.doc " Access to the elements of a module. "]
  
  val module_modules : ?trans:bool -> t_module -> t_module list[@@ocaml.doc
                                                                 " Access to the submodules of a module. "]
  
  val module_module_types : ?trans:bool -> t_module -> t_module_type list
  [@@ocaml.doc " Access to the module types of a module. "]
  
  val module_included_modules :
    ?trans:bool -> t_module -> included_module list[@@ocaml.doc
                                                     " Access to the included modules of a module. "]
  
  val module_type_extensions :
    ?trans:bool -> t_module -> Extension.t_type_extension list[@@ocaml.doc
                                                                " Access to the type extensions of a module. "]
  
  val module_exceptions :
    ?trans:bool -> t_module -> Exception.t_exception list[@@ocaml.doc
                                                           " Access to the exceptions of a module. "]
  
  val module_types : ?trans:bool -> t_module -> Type.t_type list[@@ocaml.doc
                                                                  " Access to the types of a module. "]
  
  val module_values : ?trans:bool -> t_module -> Value.t_value list[@@ocaml.doc
                                                                    " Access to the values of a module. "]
  
  val module_functions : ?trans:bool -> t_module -> Value.t_value list
  [@@ocaml.doc " Access to functional values of a module. "]
  
  val module_simple_values : ?trans:bool -> t_module -> Value.t_value list
  [@@ocaml.doc " Access to non-functional values of a module. "]
  
  val module_classes : ?trans:bool -> t_module -> Class.t_class list[@@ocaml.doc
                                                                    " Access to the classes of a module. "]
  
  val module_class_types : ?trans:bool -> t_module -> Class.t_class_type list
  [@@ocaml.doc " Access to the class types of a module. "]
  
  val module_all_classes : ?trans:bool -> t_module -> Class.t_class list
  [@@ocaml.doc
    " The list of classes defined in this module and all its submodules and functors. "]
  
  val module_is_functor : t_module -> bool[@@ocaml.doc
                                            " [true] if the module is functor. "]
  
  val module_parameters :
    ?trans:bool -> t_module -> (module_parameter * text option) list[@@ocaml.doc
                                                                    " The list of couples (module parameter, optional description). "]
  
  val module_comments : ?trans:bool -> t_module -> text list[@@ocaml.doc
                                                              " The list of module comments. "]
  
  [@@@ocaml.text " {1 Functions for module types} "]
  val module_type_elements :
    ?trans:bool -> t_module_type -> module_element list[@@ocaml.doc
                                                         " Access to the elements of a module type. "]
  
  val module_type_modules : ?trans:bool -> t_module_type -> t_module list
  [@@ocaml.doc " Access to the submodules of a module type. "]
  
  val module_type_module_types :
    ?trans:bool -> t_module_type -> t_module_type list[@@ocaml.doc
                                                        " Access to the module types of a module type. "]
  
  val module_type_included_modules :
    ?trans:bool -> t_module_type -> included_module list[@@ocaml.doc
                                                          " Access to the included modules of a module type. "]
  
  val module_type_exceptions :
    ?trans:bool -> t_module_type -> Exception.t_exception list[@@ocaml.doc
                                                                " Access to the exceptions of a module type. "]
  
  val module_type_types : ?trans:bool -> t_module_type -> Type.t_type list
  [@@ocaml.doc " Access to the types of a module type. "]
  
  val module_type_values : ?trans:bool -> t_module_type -> Value.t_value list
  [@@ocaml.doc " Access to the values of a module type. "]
  
  val module_type_functions :
    ?trans:bool -> t_module_type -> Value.t_value list[@@ocaml.doc
                                                        " Access to functional values of a module type. "]
  
  val module_type_simple_values :
    ?trans:bool -> t_module_type -> Value.t_value list[@@ocaml.doc
                                                        " Access to non-functional values of a module type. "]
  
  val module_type_classes :
    ?trans:bool -> t_module_type -> Class.t_class list[@@ocaml.doc
                                                        " Access to the classes of a module type. "]
  
  val module_type_class_types :
    ?trans:bool -> t_module_type -> Class.t_class_type list[@@ocaml.doc
                                                             " Access to the class types of a module type. "]
  
  val module_type_all_classes :
    ?trans:bool -> t_module_type -> Class.t_class list[@@ocaml.doc
                                                        " The list of classes defined in this module type and all its submodules and functors. "]
  
  val module_type_is_functor : t_module_type -> bool[@@ocaml.doc
                                                      " [true] if the module type is functor. "]
  
  val module_type_parameters :
    ?trans:bool -> t_module_type -> (module_parameter * text option) list
  [@@ocaml.doc
    " The list of couples (module parameter, optional description). "]
  
  val module_type_comments : ?trans:bool -> t_module_type -> text list
  [@@ocaml.doc " The list of module comments. "]
  
end[@@ocaml.doc
     " Representation and manipulation of modules and module types. "]

[@@@ocaml.text " {2 Getting strings from values} "]

val reset_type_names : unit -> unit[@@ocaml.doc
                                     " This function is used to reset the names of type variables.\n   It must be called when printing the whole type of a function,\n   but not when printing the type of its parameters. Same for\n   classes (call it) and methods and attributes (don't call it)."]


val string_of_variance : Type.t_type -> (bool * bool) -> string[@@ocaml.doc
                                                                 " [string_of_variance t (covariant, invariant)] returns [\"+\"] if\n   the given information means \"covariant\", [\"-\"] if it means\n   \"contravariant\", orelse [\"\"], and always [\"\"] if the given\n   type is not an abstract type with no manifest (i.e. no need\n   for the variance to be printed)."]


val string_of_type_expr : Types.type_expr -> string[@@ocaml.doc
                                                     " This function returns a string representing a Types.type_expr. "]


val string_of_class_params : Class.t_class -> string[@@ocaml.doc
                                                      " @return a string to display the parameters of the given class,\n   in the same form as the compiler. "]


val string_of_type_list :
  ?par:bool -> string -> Types.type_expr list -> string[@@ocaml.doc
                                                         " This function returns a string to represent the given list of types,\n   with a given separator. "]


val string_of_type_param_list : Type.t_type -> string[@@ocaml.doc
                                                       " This function returns a string to represent the list of type parameters\n   for the given type. "]


val string_of_type_extension_param_list :
  Extension.t_type_extension -> string[@@ocaml.doc
                                        " This function returns a string to represent the list of type parameters\n   for the given type extension. "]


val string_of_class_type_param_list : Types.type_expr list -> string[@@ocaml.doc
                                                                    " This function returns a string to represent the given list of\n   type parameters of a class or class type,\n   with a given separator. "]


val string_of_module_type :
  ?code:string -> ?complete:bool -> Types.module_type -> string[@@ocaml.doc
                                                                 " This function returns a string representing a [Types.module_type].\n   @param complete indicates if we must print complete signatures\n   or just [sig end]. Default is [false].\n   @param code if [complete = false] and the type contains something else\n   than identificators and functors, then the given code is used.\n"]


val string_of_class_type : ?complete:bool -> Types.class_type -> string
[@@ocaml.doc
  " This function returns a string representing a [Types.class_type].\n   @param complete indicates if we must print complete signatures\n   or just [object end]. Default is [false].\n"]


val string_of_text : text -> string[@@ocaml.doc
                                     " Get a string from a text. "]


val string_of_info : info -> string[@@ocaml.doc
                                     " Get a string from an info structure. "]


val string_of_type : Type.t_type -> string[@@ocaml.doc
                                            " @return a string to describe the given type. "]


val string_of_record : Type.record_field list -> string


val string_of_type_extension : Extension.t_type_extension -> string[@@ocaml.doc
                                                                    " @return a string to describe the given type extension. "]


val string_of_exception : Exception.t_exception -> string[@@ocaml.doc
                                                           " @return a string to describe the given exception. "]


val string_of_value : Value.t_value -> string[@@ocaml.doc
                                               " @return a string to describe the given value. "]


val string_of_attribute : Value.t_attribute -> string[@@ocaml.doc
                                                       " @return a string to describe the given attribute. "]


val string_of_method : Value.t_method -> string[@@ocaml.doc
                                                 " @return a string to describe the given method. "]


[@@@ocaml.text " {2 Miscellaneous functions} "]

val first_sentence_of_text : text -> text[@@ocaml.doc
                                           " Return the first sentence (until the first dot followed by a blank\n   or the first blank line) of a text.\n   Don't stop in the middle of [Code], [CodePre], [Verbatim], [List], [Enum],\n   [Latex], [Link], [Ref], [Subscript] or [Superscript]. "]


val first_sentence_and_rest_of_text : text -> (text * text)[@@ocaml.doc
                                                             " Return the first sentence (until the first dot followed by a blank\n   or the first blank line) of a text, and the remaining text after.\n   Don't stop in the middle of [Code], [CodePre], [Verbatim], [List], [Enum],\n   [Latex], [Link], [Ref], [Subscript] or [Superscript]."]


val text_no_title_no_list : text -> text[@@ocaml.doc
                                          " Return the given [text] without any title or list. "]


val text_concat : Odoc_types.text -> Odoc_types.text list -> Odoc_types.text
[@@ocaml.doc
  " [concat sep l] concats the given list of text [l], each separated with\n   the text [sep]. "]


val get_titles_in_text : text -> (int * string option * text) list[@@ocaml.doc
                                                                    " Return the list of titles in a [text].\n   A title is a title level, an optional label and a text."]


val create_index_lists : 'a list -> ('a -> string) -> 'a list list[@@ocaml.doc
                                                                    " Take a sorted list of elements, a function to get the name\n   of an element and return the list of list of elements,\n   where each list group elements beginning by the same letter.\n   Since the original list is sorted, elements whose name does not\n   begin with a letter should be in the first returned list."]


val remove_option : Types.type_expr -> Types.type_expr[@@ocaml.doc
                                                        " Take a type and remove the option top constructor. This is\n   useful when printing labels, we then remove the top option constructor\n   for optional labels."]


val is_optional : Asttypes.arg_label -> bool[@@ocaml.doc
                                              " Return [true] if the given label is optional."]


val label_name : Asttypes.arg_label -> string[@@ocaml.doc
                                               " Return the label name for the given label,\n   i.e. removes the beginning '?' if present."]


val use_hidden_modules : Name.t -> Name.t[@@ocaml.doc
                                           " Return the given name where the module name or\n   part of it was removed, according to the list of modules\n   which must be hidden (cf {!Odoc_args.hidden_modules})"]


val verbose : string -> unit[@@ocaml.doc
                              " Print the given string if the verbose mode is activated. "]


val warning : string -> unit[@@ocaml.doc
                              " Print a warning message to stderr.\n   If warnings must be treated as errors, then the\n   error counter is incremented. "]


val print_warnings : bool ref[@@ocaml.doc
                               " A flag to indicate whether ocamldoc warnings must be printed or not. "]


val errors : int ref[@@ocaml.doc
                      " Increment this counter when an error is encountered.\n   The ocamldoc tool will print the number of errors\n   encountered exit with code 1 if this number is greater\n   than 0. "]


val apply_opt : ('a -> 'b) -> 'a option -> 'b option[@@ocaml.doc
                                                      " Apply a function to an optional value. "]


val apply_if_equal : ('a -> 'a) -> 'a -> 'a -> 'a[@@ocaml.doc
                                                   " Apply a function to a first value if it is\n   not different from a second value. If the two values\n   are different, return the second one."]


val text_of_string : string -> text[@@ocaml.doc
                                     " [text_of_string s] returns the text structure from the\n   given string.\n   @raise Text_syntax if a syntax error is encountered. "]


val text_string_of_text : text -> string[@@ocaml.doc
                                          " [text_string_of_text text] returns the string representing\n   the given [text]. This string can then be parsed again\n   by {!Odoc_info.text_of_string}."]


val info_of_string : string -> info[@@ocaml.doc
                                     " [info_of_string s] parses the given string\n   like a regular ocamldoc comment and return an\n   {!Odoc_info.info} structure.\n   @return an empty structure if there was a syntax error. TODO: change this\n"]


val info_string_of_info : info -> string[@@ocaml.doc
                                          " [info_string_of_info info] returns the string representing\n   the given [info]. This string can then be parsed again\n   by {!Odoc_info.info_of_string}."]


val info_of_comment_file : Module.t_module list -> string -> info[@@ocaml.doc
                                                                   " [info_of_comment_file file] parses the given file\n   and return an {!Odoc_info.info} structure. The content of the\n   file must have the same syntax as the content of a special comment.\n   The given module list is used for cross reference.\n   @raise Failure if the file could not be opened or there is a\n   syntax error.\n"]


val remove_ending_newline : string -> string[@@ocaml.doc
                                              " [remove_ending_newline s] returns [s] without the optional ending newline. "]


module Search :
sig
  type result_element = Odoc_search.result_element =
  | Res_module of Module.t_module 
  | Res_module_type of Module.t_module_type 
  | Res_class of Class.t_class 
  | Res_class_type of Class.t_class_type 
  | Res_value of Value.t_value 
  | Res_type of Type.t_type 
  | Res_extension of Extension.t_extension_constructor 
  | Res_exception of Exception.t_exception 
  | Res_attribute of Value.t_attribute 
  | Res_method of Value.t_method 
  | Res_section of string * text 
  | Res_recfield of Type.t_type * Type.record_field 
  | Res_const of Type.t_type * Type.variant_constructor 
    
  type search_result = result_element list[@@ocaml.doc
                                            " The type representing a research result."]
    
  val search_by_name : Module.t_module list -> Str.regexp -> search_result
  [@@ocaml.doc
    " Research of the elements whose name matches the given regular expression."]
  
  val values : Module.t_module list -> Value.t_value list[@@ocaml.doc
                                                           " A function to search all the values in a list of modules. "]
  
  val extensions :
    Module.t_module list -> Extension.t_extension_constructor list[@@ocaml.doc
                                                                    " A function to search all the extensions in a list of modules. "]
  
  val exceptions : Module.t_module list -> Exception.t_exception list
  [@@ocaml.doc
    " A function to search all the exceptions in a list of modules. "]
  
  val types : Module.t_module list -> Type.t_type list[@@ocaml.doc
                                                        " A function to search all the types in a list of modules. "]
  
  val attributes : Module.t_module list -> Value.t_attribute list[@@ocaml.doc
                                                                   " A function to search all the class attributes in a list of modules. "]
  
  val methods : Module.t_module list -> Value.t_method list[@@ocaml.doc
                                                             " A function to search all the class methods in a list of modules. "]
  
  val classes : Module.t_module list -> Class.t_class list[@@ocaml.doc
                                                            " A function to search all the classes in a list of modules. "]
  
  val class_types : Module.t_module list -> Class.t_class_type list[@@ocaml.doc
                                                                    " A function to search all the class types in a list of modules. "]
  
  val modules : Module.t_module list -> Module.t_module list[@@ocaml.doc
                                                              " A function to search all the modules in a list of modules. "]
  
  val module_types : Module.t_module list -> Module.t_module_type list
  [@@ocaml.doc
    " A function to search all the module types in a list of modules. "]
  
end[@@ocaml.doc " Research in elements "]

module Scan :
sig
  class scanner :
    object
      method  scan_value : Value.t_value -> unit
      method  scan_type_pre : Type.t_type -> bool
      method  scan_type_const :
        Type.t_type -> Type.variant_constructor -> unit
      method  scan_type_recfield : Type.t_type -> Type.record_field -> unit
      method  scan_type : Type.t_type -> unit
      method  scan_extension_constructor :
        Extension.t_extension_constructor -> unit
      method  scan_exception : Exception.t_exception -> unit
      method  scan_attribute : Value.t_attribute -> unit
      method  scan_method : Value.t_method -> unit
      method  scan_included_module : Module.included_module -> unit
      [@@@ocaml.text " Scan of a type extension "]
      method  scan_type_extension_pre : Extension.t_type_extension -> bool
      [@@ocaml.doc
        " Override this method to perform controls on the extension's type,\n            private and info. This method is called before scanning the\n            extension's constructors.\n            @return true if the extension's constructors must be scanned."]
      method  scan_type_extension_constructors :
        Extension.t_type_extension -> unit[@@ocaml.doc
                                            " This method scans the constructors of the given type extension. "]
      method  scan_type_extension : Extension.t_type_extension -> unit
      [@@ocaml.doc
        " Scan of a type extension. Should not be overridden. It calls [scan_type_extension_pre]\n            and if [scan_type_extension_pre] returns [true], then it calls scan_type_extension_constructors."]
      [@@@ocaml.text " Scan of a class. "]
      method  scan_class_comment : text -> unit[@@ocaml.doc
                                                 " Scan of a comment inside a class. "]
      method  scan_class_pre : Class.t_class -> bool[@@ocaml.doc
                                                      " Override this method to perform controls on the class comment\n          and params. This method is called before scanning the class elements.\n          @return true if the class elements must be scanned."]
      method  scan_class_elements : Class.t_class -> unit[@@ocaml.doc
                                                           " This method scans the elements of the given class. "]
      method  scan_class : Class.t_class -> unit[@@ocaml.doc
                                                  " Scan of a class. Should not be overridden. It calls [scan_class_pre]\n          and if [scan_class_pre] returns [true], then it calls scan_class_elements."]
      [@@@ocaml.text " Scan of a class type. "]
      method  scan_class_type_comment : text -> unit[@@ocaml.doc
                                                      " Scan of a comment inside a class type. "]
      method  scan_class_type_pre : Class.t_class_type -> bool[@@ocaml.doc
                                                                " Override this method to perform controls on the class type comment\n           and form. This method is called before scanning the class type elements.\n           @return true if the class type elements must be scanned."]
      method  scan_class_type_elements : Class.t_class_type -> unit[@@ocaml.doc
                                                                    " This method scans the elements of the given class type. "]
      method  scan_class_type : Class.t_class_type -> unit[@@ocaml.doc
                                                            " Scan of a class type. Should not be overridden. It calls [scan_class_type_pre]\n           and if [scan_class_type_pre] returns [true], then it calls scan_class_type_elements."]
      [@@@ocaml.text " Scan of modules. "]
      method  scan_module_comment : text -> unit[@@ocaml.doc
                                                  " Scan of a comment inside a module. "]
      method  scan_module_pre : Module.t_module -> bool[@@ocaml.doc
                                                         " Override this method to perform controls on the module comment\n           and form. This method is called before scanning the module elements.\n           @return true if the module elements must be scanned."]
      method  scan_module_elements : Module.t_module -> unit[@@ocaml.doc
                                                              " This method scans the elements of the given module. "]
      method  scan_module : Module.t_module -> unit[@@ocaml.doc
                                                     " Scan of a module. Should not be overridden. It calls [scan_module_pre]\n          and if [scan_module_pre] returns [true], then it calls scan_module_elements."]
      [@@@ocaml.text " Scan of module types. "]
      method  scan_module_type_comment : text -> unit[@@ocaml.doc
                                                       " Scan of a comment inside a module type. "]
      method  scan_module_type_pre : Module.t_module_type -> bool[@@ocaml.doc
                                                                   " Override this method to perform controls on the module type comment\n           and form. This method is called before scanning the module type elements.\n           @return true if the module type elements must be scanned. "]
      method  scan_module_type_elements : Module.t_module_type -> unit
      [@@ocaml.doc
        " This method scans the elements of the given module type. "]
      method  scan_module_type : Module.t_module_type -> unit[@@ocaml.doc
                                                               " Scan of a module type. Should not be overridden. It calls [scan_module_type_pre]\n           and if [scan_module_type_pre] returns [true], then it calls scan_module_type_elements."]
      [@@@ocaml.text " Main scanning method. "]
      method  scan_module_list : Module.t_module list -> unit[@@ocaml.doc
                                                               " Scan a list of modules. "]
    end
end[@@ocaml.doc " Scanning of collected information "]

module Dep :
sig
  val kernel_deps_of_modules : Module.t_module list -> unit[@@ocaml.doc
                                                             " Modify the module dependencies of the given list of modules,\n       to get the minimum transitivity kernel. "]
  
  val deps_of_types :
    ?kernel:bool -> Type.t_type list -> (Type.t_type * Name.t list) list
  [@@ocaml.doc
    " Return the list of dependencies between the given types,\n       in the form of a list [(type name, names of types it depends on)].\n       @param kernel indicates if we must keep only the transitivity kernel\n       of the dependencies. Default is [false].\n    "]
  
end[@@ocaml.doc " Computation of dependencies. "]

[@@@ocaml.text " {1 Some global variables} "]

module Global :
sig
  val errors : int ref
  
  val warn_error : bool ref
  
  val out_file : string ref[@@ocaml.doc
                             " The file used by the generators outputting only one file. "]
  
  val verbose : bool ref[@@ocaml.doc " Verbose mode or not. "]
  
  val target_dir : string ref[@@ocaml.doc
                               " The directory where files have to be generated. "]
  
  val title : string option ref[@@ocaml.doc
                                 " The optional title to use in the generated documentation. "]
  
  val intro_file : string option ref[@@ocaml.doc
                                      " The optional file whose content can be used as intro text. "]
  
  val with_toc : bool ref[@@ocaml.doc
                           " The flag which indicates if we must generate a table of contents. "]
  
  val with_index : bool ref[@@ocaml.doc
                             " The flag which indicates if we must generate an index. "]
  
  val with_header : bool ref[@@ocaml.doc
                              " The flag which indicates if we must generate a header."]
  
  val with_trailer : bool ref[@@ocaml.doc
                               " The flag which indicates if we must generate a trailer."]
  
end

val analyse_files :
  ?merge_options:Odoc_types.merge_option list ->
    ?include_dirs:string list ->
      ?labels:bool ->
        ?sort_modules:bool ->
          ?no_stop:bool ->
            ?init:Odoc_module.t_module list ->
              Odoc_global.source_file list -> Module.t_module list[@@ocaml.doc
                                                                    " Analysis of the given source files.\n   @param init is the list of modules already known from a previous analysis.\n   @return the list of analysed top modules. "]


val dump_modules : string -> Odoc_module.t_module list -> unit[@@ocaml.doc
                                                                " Dump of a list of modules into a file.\n   @raise Failure if an error occurs."]


val load_modules : string -> Odoc_module.t_module list[@@ocaml.doc
                                                        " Load of a list of modules from a file.\n   @raise Failure if an error occurs."]

gospel: internal error, uncaught exception:
        File "gospel/src/typing.ml", line 515, characters 22-28: Assertion failed
        
