
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text
  " List operations.\n\n   Some functions are flagged as not tail-recursive.  A tail-recursive\n   function uses constant stack space, while a non-tail-recursive function\n   uses stack space proportional to the length of its list argument, which\n   can be a problem with very long lists.  When the function takes several\n   list arguments, an approximate formula giving stack usage (in some\n   unspecified constant unit) is shown in parentheses.\n\n   The above considerations can usually be ignored if your lists are not\n   longer than about 10000 elements.\n"]
val length : 'a list -> int[@@ocaml.doc
                             " Return the length (number of elements) of the given list. "]
val hd : 'a list -> 'a[@@ocaml.doc
                        " Return the first element of the given list. Raise\n   [Failure \"hd\"] if the list is empty. "]
val compare_lengths : 'a list -> 'b list -> int[@@ocaml.doc
                                                 " Compare the lengths of two lists. [compare_lengths l1 l2] is\n   equivalent to [compare (length l1) (length l2)], except that\n   the computation stops after itering on the shortest list.\n   @since 4.05.0\n "]
val compare_length_with : 'a list -> len:int -> int[@@ocaml.doc
                                                     " Compare the length of a list to an integer. [compare_length_with l n] is\n   equivalent to [compare (length l) n], except that\n   the computation stops after at most [n] iterations on the list.\n   @since 4.05.0\n"]
val cons : 'a -> 'a list -> 'a list[@@ocaml.doc
                                     " [cons x xs] is [x :: xs]\n    @since 4.05.0\n"]
val tl : 'a list -> 'a list[@@ocaml.doc
                             " Return the given list without its first element. Raise\n   [Failure \"tl\"] if the list is empty. "]
val nth : 'a list -> int -> 'a[@@ocaml.doc
                                " Return the [n]-th element of the given list.\n   The first element (head of the list) is at position 0.\n   Raise [Failure \"nth\"] if the list is too short.\n   Raise [Invalid_argument \"List.nth\"] if [n] is negative. "]
val nth_opt : 'a list -> int -> 'a option[@@ocaml.doc
                                           " Return the [n]-th element of the given list.\n    The first element (head of the list) is at position 0.\n    Return [None] if the list is too short.\n    Raise [Invalid_argument \"List.nth\"] if [n] is negative.\n    @since 4.05\n"]
val rev : 'a list -> 'a list[@@ocaml.doc " List reversal. "]
val init : len:int -> f:(int -> 'a) -> 'a list[@@ocaml.doc
                                                " [List.init len f] is [f 0; f 1; ...; f (len-1)], evaluated left to right.\n\n    @raise Invalid_argument if [len < 0].\n    @since 4.06.0\n"]
val append : 'a list -> 'a list -> 'a list[@@ocaml.doc
                                            " Catenate two lists.  Same function as the infix operator [@].\n   Not tail-recursive (length of the first argument).  The [@]\n   operator is not tail-recursive either. "]
val rev_append : 'a list -> 'a list -> 'a list[@@ocaml.doc
                                                " [List.rev_append l1 l2] reverses [l1] and concatenates it with [l2].\n   This is equivalent to [(]{!List.rev}[ l1) @ l2], but [rev_append] is\n   tail-recursive and more efficient. "]
val concat : 'a list list -> 'a list[@@ocaml.doc
                                      " Concatenate a list of lists.  The elements of the argument are all\n   concatenated together (in the same order) to give the result.\n   Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]
val flatten : 'a list list -> 'a list[@@ocaml.doc
                                       " Same as [concat].  Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]
[@@@ocaml.text " {1 Iterators} "]
val iter : f:('a -> unit) -> 'a list -> unit[@@ocaml.doc
                                              " [List.iter f [a1; ...; an]] applies function [f] in turn to\n   [a1; ...; an]. It is equivalent to\n   [begin f a1; f a2; ...; f an; () end]. "]
val iteri : f:(int -> 'a -> unit) -> 'a list -> unit[@@ocaml.doc
                                                      " Same as {!List.iter}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]
val map : f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                              " [List.map f [a1; ...; an]] applies function [f] to [a1, ..., an],\n   and builds the list [[f a1; ...; f an]]\n   with the results returned by [f].  Not tail-recursive. "]
val mapi : f:(int -> 'a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                                      " Same as {!List.map}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]
val rev_map : f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                                  " [List.rev_map f l] gives the same result as\n   {!List.rev}[ (]{!List.map}[ f l)], but is tail-recursive and\n   more efficient. "]
val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a[@@ocaml.doc
                                                                " [List.fold_left f a [b1; ...; bn]] is\n   [f (... (f (f a b1) b2) ...) bn]. "]
val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b[@@ocaml.doc
                                                                 " [List.fold_right f [a1; ...; an] b] is\n   [f a1 (f a2 (... (f an b) ...))].  Not tail-recursive. "]
[@@@ocaml.text " {1 Iterators on two lists} "]
val iter2 : f:('a -> 'b -> unit) -> 'a list -> 'b list -> unit[@@ocaml.doc
                                                                " [List.iter2 f [a1; ...; an] [b1; ...; bn]] calls in turn\n   [f a1 b1; ...; f an bn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
val map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                                " [List.map2 f [a1; ...; an] [b1; ...; bn]] is\n   [[f a1 b1; ...; f an bn]].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]
val rev_map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                                    " [List.rev_map2 f l1 l2] gives the same result as\n   {!List.rev}[ (]{!List.map2}[ f l1 l2)], but is tail-recursive and\n   more efficient. "]
val fold_left2 :
  f:('a -> 'b -> 'c -> 'a) -> init:'a -> 'b list -> 'c list -> 'a[@@ocaml.doc
                                                                   " [List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]] is\n   [f (... (f (f a b1 c1) b2 c2) ...) bn cn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
val fold_right2 :
  f:('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> init:'c -> 'c[@@ocaml.doc
                                                                   " [List.fold_right2 f [a1; ...; an] [b1; ...; bn] c] is\n   [f a1 b1 (f a2 b2 (... (f an bn c) ...))].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]
[@@@ocaml.text " {1 List scanning} "]
val for_all : f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                                 " [for_all p [a1; ...; an]] checks if all elements of the list\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)]. "]
val exists : f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                                " [exists p [a1; ...; an]] checks if at least one element of\n   the list satisfies the predicate [p]. That is, it returns\n   [(p a1) || (p a2) || ... || (p an)]. "]
val for_all2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                                   " Same as {!List.for_all}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
val exists2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                                  " Same as {!List.exists}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
val mem : 'a -> set:'a list -> bool[@@ocaml.doc
                                     " [mem a l] is true if and only if [a] is equal\n   to an element of [l]. "]
val memq : 'a -> set:'a list -> bool[@@ocaml.doc
                                      " Same as {!List.mem}, but uses physical equality instead of structural\n   equality to compare list elements. "]
[@@@ocaml.text " {1 List searching} "]
val find : f:('a -> bool) -> 'a list -> 'a[@@ocaml.doc
                                            " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Raise [Not_found] if there is no value that satisfies [p] in the\n   list [l]. "]
val find_opt : f:('a -> bool) -> 'a list -> 'a option[@@ocaml.doc
                                                       " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Returns [None] if there is no value that satisfies [p] in the\n   list [l].\n   @since 4.05 "]
val filter : f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                                   " [filter p l] returns all the elements of the list [l]\n   that satisfy the predicate [p].  The order of the elements\n   in the input list is preserved.  "]
val find_all : f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                                     " [find_all] is another name for {!List.filter}. "]
val partition : f:('a -> bool) -> 'a list -> ('a list * 'a list)[@@ocaml.doc
                                                                  " [partition p l] returns a pair of lists [(l1, l2)], where\n   [l1] is the list of all the elements of [l] that\n   satisfy the predicate [p], and [l2] is the list of all the\n   elements of [l] that do not satisfy [p].\n   The order of the elements in the input list is preserved. "]
[@@@ocaml.text " {1 Association lists} "]
val assoc : 'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                        " [assoc a l] returns the value associated with key [a] in the list of\n   pairs [l]. That is,\n   [assoc a [ ...; (a,b); ...] = b]\n   if [(a,b)] is the leftmost binding of [a] in list [l].\n   Raise [Not_found] if there is no value associated with [a] in the\n   list [l]. "]
val assoc_opt : 'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                                   " [assoc_opt a l] returns the value associated with key [a] in the list of\n    pairs [l]. That is,\n    [assoc a [ ...; (a,b); ...] = b]\n    if [(a,b)] is the leftmost binding of [a] in list [l].\n    Returns [None] if there is no value associated with [a] in the\n    list [l].\n    @since 4.05\n"]
val assq : 'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                       " Same as {!List.assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]
val assq_opt : 'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                                  " Same as {!List.assoc_opt}, but uses physical equality instead of\n   structural equality to compare keys.\n   @since 4.05.0 "]
val mem_assoc : 'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                                  " Same as {!List.assoc}, but simply return true if a binding exists,\n   and false if no bindings exist for the given key. "]
val mem_assq : 'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                                 " Same as {!List.mem_assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]
val remove_assoc : 'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                                           " [remove_assoc a l] returns the list of\n   pairs [l] without the first pair with key [a], if any.\n   Not tail-recursive. "]
val remove_assq : 'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                                          " Same as {!List.remove_assoc}, but uses physical equality instead\n   of structural equality to compare keys.  Not tail-recursive. "]
[@@@ocaml.text " {1 Lists of pairs} "]
val split : ('a * 'b) list -> ('a list * 'b list)[@@ocaml.doc
                                                   " Transform a list of pairs into a pair of lists:\n   [split [(a1,b1); ...; (an,bn)]] is [([a1; ...; an], [b1; ...; bn])].\n   Not tail-recursive.\n"]
val combine : 'a list -> 'b list -> ('a * 'b) list[@@ocaml.doc
                                                    " Transform a pair of lists into a list of pairs:\n   [combine [a1; ...; an] [b1; ...; bn]] is\n   [[(a1,b1); ...; (an,bn)]].\n   Raise [Invalid_argument] if the two lists\n   have different lengths.  Not tail-recursive. "]
[@@@ocaml.text " {1 Sorting} "]
val sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                        " Sort a list in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see Array.sort for\n   a complete specification).  For example,\n   {!Stdlib.compare} is a suitable comparison function.\n   The resulting list is sorted in increasing order.\n   [List.sort] is guaranteed to run in constant heap space\n   (in addition to the size of the result list) and logarithmic\n   stack space.\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]
val stable_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                               " Same as {!List.sort}, but the sorting algorithm is guaranteed to\n   be stable (i.e. elements that compare equal are kept in their\n   original order) .\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]
val fast_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                             " Same as {!List.sort} or {!List.stable_sort}, whichever is\n    faster on typical input. "]
val sort_uniq : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                             " Same as {!List.sort}, but also remove duplicates.\n    @since 4.03.0 "]
val merge : cmp:('a -> 'a -> int) -> 'a list -> 'a list -> 'a list[@@ocaml.doc
                                                                    " Merge two lists:\n    Assuming that [l1] and [l2] are sorted according to the\n    comparison function [cmp], [merge cmp l1 l2] will return a\n    sorted list containing all the elements of [l1] and [l2].\n    If several elements compare equal, the elements of [l1] will be\n    before the elements of [l2].\n    Not tail-recursive (sum of the lengths of the arguments).\n"]
[@@@ocaml.text " {6 Iterators} "]
val to_seq : 'a list -> 'a Seq.t[@@ocaml.doc
                                  " Iterate on the list\n    @since 4.07 "]
val of_seq : 'a Seq.t -> 'a list[@@ocaml.doc
                                  " Create a list from the iterator\n    @since 4.07 "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text
  " List operations.\n\n   Some functions are flagged as not tail-recursive.  A tail-recursive\n   function uses constant stack space, while a non-tail-recursive function\n   uses stack space proportional to the length of its list argument, which\n   can be a problem with very long lists.  When the function takes several\n   list arguments, an approximate formula giving stack usage (in some\n   unspecified constant unit) is shown in parentheses.\n\n   The above considerations can usually be ignored if your lists are not\n   longer than about 10000 elements.\n"]

val length : 'a list -> int[@@ocaml.doc
                             " Return the length (number of elements) of the given list. "]


val hd : 'a list -> 'a[@@ocaml.doc
                        " Return the first element of the given list. Raise\n   [Failure \"hd\"] if the list is empty. "]


val compare_lengths : 'a list -> 'b list -> int[@@ocaml.doc
                                                 " Compare the lengths of two lists. [compare_lengths l1 l2] is\n   equivalent to [compare (length l1) (length l2)], except that\n   the computation stops after itering on the shortest list.\n   @since 4.05.0\n "]


val compare_length_with : 'a list -> len:int -> int[@@ocaml.doc
                                                     " Compare the length of a list to an integer. [compare_length_with l n] is\n   equivalent to [compare (length l) n], except that\n   the computation stops after at most [n] iterations on the list.\n   @since 4.05.0\n"]


val cons : 'a -> 'a list -> 'a list[@@ocaml.doc
                                     " [cons x xs] is [x :: xs]\n    @since 4.05.0\n"]


val tl : 'a list -> 'a list[@@ocaml.doc
                             " Return the given list without its first element. Raise\n   [Failure \"tl\"] if the list is empty. "]


val nth : 'a list -> int -> 'a[@@ocaml.doc
                                " Return the [n]-th element of the given list.\n   The first element (head of the list) is at position 0.\n   Raise [Failure \"nth\"] if the list is too short.\n   Raise [Invalid_argument \"List.nth\"] if [n] is negative. "]


val nth_opt : 'a list -> int -> 'a option[@@ocaml.doc
                                           " Return the [n]-th element of the given list.\n    The first element (head of the list) is at position 0.\n    Return [None] if the list is too short.\n    Raise [Invalid_argument \"List.nth\"] if [n] is negative.\n    @since 4.05\n"]


val rev : 'a list -> 'a list[@@ocaml.doc " List reversal. "]


val init : len:int -> f:(int -> 'a) -> 'a list[@@ocaml.doc
                                                " [List.init len f] is [f 0; f 1; ...; f (len-1)], evaluated left to right.\n\n    @raise Invalid_argument if [len < 0].\n    @since 4.06.0\n"]


val append : 'a list -> 'a list -> 'a list[@@ocaml.doc
                                            " Catenate two lists.  Same function as the infix operator [@].\n   Not tail-recursive (length of the first argument).  The [@]\n   operator is not tail-recursive either. "]


val rev_append : 'a list -> 'a list -> 'a list[@@ocaml.doc
                                                " [List.rev_append l1 l2] reverses [l1] and concatenates it with [l2].\n   This is equivalent to [(]{!List.rev}[ l1) @ l2], but [rev_append] is\n   tail-recursive and more efficient. "]


val concat : 'a list list -> 'a list[@@ocaml.doc
                                      " Concatenate a list of lists.  The elements of the argument are all\n   concatenated together (in the same order) to give the result.\n   Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]


val flatten : 'a list list -> 'a list[@@ocaml.doc
                                       " Same as [concat].  Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]


[@@@ocaml.text " {1 Iterators} "]

val iter : f:('a -> unit) -> 'a list -> unit[@@ocaml.doc
                                              " [List.iter f [a1; ...; an]] applies function [f] in turn to\n   [a1; ...; an]. It is equivalent to\n   [begin f a1; f a2; ...; f an; () end]. "]


val iteri : f:(int -> 'a -> unit) -> 'a list -> unit[@@ocaml.doc
                                                      " Same as {!List.iter}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]


val map : f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                              " [List.map f [a1; ...; an]] applies function [f] to [a1, ..., an],\n   and builds the list [[f a1; ...; f an]]\n   with the results returned by [f].  Not tail-recursive. "]


val mapi : f:(int -> 'a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                                      " Same as {!List.map}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]


val rev_map : f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                                  " [List.rev_map f l] gives the same result as\n   {!List.rev}[ (]{!List.map}[ f l)], but is tail-recursive and\n   more efficient. "]


val fold_left : f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a[@@ocaml.doc
                                                                " [List.fold_left f a [b1; ...; bn]] is\n   [f (... (f (f a b1) b2) ...) bn]. "]


val fold_right : f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b[@@ocaml.doc
                                                                 " [List.fold_right f [a1; ...; an] b] is\n   [f a1 (f a2 (... (f an b) ...))].  Not tail-recursive. "]


[@@@ocaml.text " {1 Iterators on two lists} "]

val iter2 : f:('a -> 'b -> unit) -> 'a list -> 'b list -> unit[@@ocaml.doc
                                                                " [List.iter2 f [a1; ...; an] [b1; ...; bn]] calls in turn\n   [f a1 b1; ...; f an bn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]


val map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                                " [List.map2 f [a1; ...; an] [b1; ...; bn]] is\n   [[f a1 b1; ...; f an bn]].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]


val rev_map2 : f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                                    " [List.rev_map2 f l1 l2] gives the same result as\n   {!List.rev}[ (]{!List.map2}[ f l1 l2)], but is tail-recursive and\n   more efficient. "]


val fold_left2 :
  f:('a -> 'b -> 'c -> 'a) -> init:'a -> 'b list -> 'c list -> 'a[@@ocaml.doc
                                                                   " [List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]] is\n   [f (... (f (f a b1 c1) b2 c2) ...) bn cn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]


val fold_right2 :
  f:('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> init:'c -> 'c[@@ocaml.doc
                                                                   " [List.fold_right2 f [a1; ...; an] [b1; ...; bn] c] is\n   [f a1 b1 (f a2 b2 (... (f an bn c) ...))].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]


[@@@ocaml.text " {1 List scanning} "]

val for_all : f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                                 " [for_all p [a1; ...; an]] checks if all elements of the list\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)]. "]


val exists : f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                                " [exists p [a1; ...; an]] checks if at least one element of\n   the list satisfies the predicate [p]. That is, it returns\n   [(p a1) || (p a2) || ... || (p an)]. "]


val for_all2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                                   " Same as {!List.for_all}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]


val exists2 : f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                                  " Same as {!List.exists}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]


val mem : 'a -> set:'a list -> bool[@@ocaml.doc
                                     " [mem a l] is true if and only if [a] is equal\n   to an element of [l]. "]


val memq : 'a -> set:'a list -> bool[@@ocaml.doc
                                      " Same as {!List.mem}, but uses physical equality instead of structural\n   equality to compare list elements. "]


[@@@ocaml.text " {1 List searching} "]

val find : f:('a -> bool) -> 'a list -> 'a[@@ocaml.doc
                                            " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Raise [Not_found] if there is no value that satisfies [p] in the\n   list [l]. "]


val find_opt : f:('a -> bool) -> 'a list -> 'a option[@@ocaml.doc
                                                       " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Returns [None] if there is no value that satisfies [p] in the\n   list [l].\n   @since 4.05 "]


val filter : f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                                   " [filter p l] returns all the elements of the list [l]\n   that satisfy the predicate [p].  The order of the elements\n   in the input list is preserved.  "]


val find_all : f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                                     " [find_all] is another name for {!List.filter}. "]


val partition : f:('a -> bool) -> 'a list -> ('a list * 'a list)[@@ocaml.doc
                                                                  " [partition p l] returns a pair of lists [(l1, l2)], where\n   [l1] is the list of all the elements of [l] that\n   satisfy the predicate [p], and [l2] is the list of all the\n   elements of [l] that do not satisfy [p].\n   The order of the elements in the input list is preserved. "]


[@@@ocaml.text " {1 Association lists} "]

val assoc : 'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                        " [assoc a l] returns the value associated with key [a] in the list of\n   pairs [l]. That is,\n   [assoc a [ ...; (a,b); ...] = b]\n   if [(a,b)] is the leftmost binding of [a] in list [l].\n   Raise [Not_found] if there is no value associated with [a] in the\n   list [l]. "]


val assoc_opt : 'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                                   " [assoc_opt a l] returns the value associated with key [a] in the list of\n    pairs [l]. That is,\n    [assoc a [ ...; (a,b); ...] = b]\n    if [(a,b)] is the leftmost binding of [a] in list [l].\n    Returns [None] if there is no value associated with [a] in the\n    list [l].\n    @since 4.05\n"]


val assq : 'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                       " Same as {!List.assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]


val assq_opt : 'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                                  " Same as {!List.assoc_opt}, but uses physical equality instead of\n   structural equality to compare keys.\n   @since 4.05.0 "]


val mem_assoc : 'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                                  " Same as {!List.assoc}, but simply return true if a binding exists,\n   and false if no bindings exist for the given key. "]


val mem_assq : 'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                                 " Same as {!List.mem_assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]


val remove_assoc : 'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                                           " [remove_assoc a l] returns the list of\n   pairs [l] without the first pair with key [a], if any.\n   Not tail-recursive. "]


val remove_assq : 'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                                          " Same as {!List.remove_assoc}, but uses physical equality instead\n   of structural equality to compare keys.  Not tail-recursive. "]


[@@@ocaml.text " {1 Lists of pairs} "]

val split : ('a * 'b) list -> ('a list * 'b list)[@@ocaml.doc
                                                   " Transform a list of pairs into a pair of lists:\n   [split [(a1,b1); ...; (an,bn)]] is [([a1; ...; an], [b1; ...; bn])].\n   Not tail-recursive.\n"]


val combine : 'a list -> 'b list -> ('a * 'b) list[@@ocaml.doc
                                                    " Transform a pair of lists into a list of pairs:\n   [combine [a1; ...; an] [b1; ...; bn]] is\n   [[(a1,b1); ...; (an,bn)]].\n   Raise [Invalid_argument] if the two lists\n   have different lengths.  Not tail-recursive. "]


[@@@ocaml.text " {1 Sorting} "]

val sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                        " Sort a list in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see Array.sort for\n   a complete specification).  For example,\n   {!Stdlib.compare} is a suitable comparison function.\n   The resulting list is sorted in increasing order.\n   [List.sort] is guaranteed to run in constant heap space\n   (in addition to the size of the result list) and logarithmic\n   stack space.\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]


val stable_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                               " Same as {!List.sort}, but the sorting algorithm is guaranteed to\n   be stable (i.e. elements that compare equal are kept in their\n   original order) .\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]


val fast_sort : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                             " Same as {!List.sort} or {!List.stable_sort}, whichever is\n    faster on typical input. "]


val sort_uniq : cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                             " Same as {!List.sort}, but also remove duplicates.\n    @since 4.03.0 "]


val merge : cmp:('a -> 'a -> int) -> 'a list -> 'a list -> 'a list[@@ocaml.doc
                                                                    " Merge two lists:\n    Assuming that [l1] and [l2] are sorted according to the\n    comparison function [cmp], [merge cmp l1 l2] will return a\n    sorted list containing all the elements of [l1] and [l2].\n    If several elements compare equal, the elements of [l1] will be\n    before the elements of [l2].\n    Not tail-recursive (sum of the lengths of the arguments).\n"]


[@@@ocaml.text " {6 Iterators} "]

val to_seq : 'a list -> 'a Seq.t[@@ocaml.doc
                                  " Iterate on the list\n    @since 4.07 "]


val of_seq : 'a Seq.t -> 'a list[@@ocaml.doc
                                  " Create a list from the iterator\n    @since 4.07 "]


*******************************
********* Typed GOSPEL ********
*******************************
module listLabels.mli

  Namespace: listLabels.mli
    Type symbols
      
    Logic Symbols
      
    Exception Symbols
      
    Namespaces
      
    Type Namespaces
      
  Signatures
    (*@ open Gospelstdlib *)
    
    [@@@ocaml.text
      " List operations.\n\n   Some functions are flagged as not tail-recursive.  A tail-recursive\n   function uses constant stack space, while a non-tail-recursive function\n   uses stack space proportional to the length of its list argument, which\n   can be a problem with very long lists.  When the function takes several\n   list arguments, an approximate formula giving stack usage (in some\n   unspecified constant unit) is shown in parentheses.\n\n   The above considerations can usually be ignored if your lists are not\n   longer than about 10000 elements.\n"]
    
    val length :
    'a list -> int[@@ocaml.doc
                    " Return the length (number of elements) of the given list. "]
    
    
    val hd :
    'a list -> 'a[@@ocaml.doc
                   " Return the first element of the given list. Raise\n   [Failure \"hd\"] if the list is empty. "]
    
    
    val compare_lengths :
    'a list -> 'b list -> int[@@ocaml.doc
                               " Compare the lengths of two lists. [compare_lengths l1 l2] is\n   equivalent to [compare (length l1) (length l2)], except that\n   the computation stops after itering on the shortest list.\n   @since 4.05.0\n "]
    
    
    val compare_length_with :
    'a list -> len:int -> int[@@ocaml.doc
                               " Compare the length of a list to an integer. [compare_length_with l n] is\n   equivalent to [compare (length l) n], except that\n   the computation stops after at most [n] iterations on the list.\n   @since 4.05.0\n"]
    
    
    val cons :
    'a -> 'a list -> 'a list[@@ocaml.doc
                              " [cons x xs] is [x :: xs]\n    @since 4.05.0\n"]
    
    
    val tl :
    'a list -> 'a list[@@ocaml.doc
                        " Return the given list without its first element. Raise\n   [Failure \"tl\"] if the list is empty. "]
    
    
    val nth :
    'a list -> int -> 'a[@@ocaml.doc
                          " Return the [n]-th element of the given list.\n   The first element (head of the list) is at position 0.\n   Raise [Failure \"nth\"] if the list is too short.\n   Raise [Invalid_argument \"List.nth\"] if [n] is negative. "]
    
    
    val nth_opt :
    'a list -> int -> 'a option[@@ocaml.doc
                                 " Return the [n]-th element of the given list.\n    The first element (head of the list) is at position 0.\n    Return [None] if the list is too short.\n    Raise [Invalid_argument \"List.nth\"] if [n] is negative.\n    @since 4.05\n"]
    
    
    val rev : 'a list -> 'a list[@@ocaml.doc " List reversal. "]
    
    
    val init :
    len:int -> f:(int -> 'a) -> 'a list[@@ocaml.doc
                                         " [List.init len f] is [f 0; f 1; ...; f (len-1)], evaluated left to right.\n\n    @raise Invalid_argument if [len < 0].\n    @since 4.06.0\n"]
    
    
    val append :
    'a list -> 'a list -> 'a list[@@ocaml.doc
                                   " Catenate two lists.  Same function as the infix operator [@].\n   Not tail-recursive (length of the first argument).  The [@]\n   operator is not tail-recursive either. "]
    
    
    val rev_append :
    'a list -> 'a list -> 'a list[@@ocaml.doc
                                   " [List.rev_append l1 l2] reverses [l1] and concatenates it with [l2].\n   This is equivalent to [(]{!List.rev}[ l1) @ l2], but [rev_append] is\n   tail-recursive and more efficient. "]
    
    
    val concat :
    'a list list -> 'a list[@@ocaml.doc
                             " Concatenate a list of lists.  The elements of the argument are all\n   concatenated together (in the same order) to give the result.\n   Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]
    
    
    val flatten :
    'a list list -> 'a list[@@ocaml.doc
                             " Same as [concat].  Not tail-recursive\n   (length of the argument + length of the longest sub-list). "]
    
    
    [@@@ocaml.text " {1 Iterators} "]
    
    val iter :
    f:('a -> unit) -> 'a list -> unit[@@ocaml.doc
                                       " [List.iter f [a1; ...; an]] applies function [f] in turn to\n   [a1; ...; an]. It is equivalent to\n   [begin f a1; f a2; ...; f an; () end]. "]
    
    
    val iteri :
    f:(int -> 'a -> unit) -> 'a list -> unit[@@ocaml.doc
                                              " Same as {!List.iter}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]
    
    
    val map :
    f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                        " [List.map f [a1; ...; an]] applies function [f] to [a1, ..., an],\n   and builds the list [[f a1; ...; f an]]\n   with the results returned by [f].  Not tail-recursive. "]
    
    
    val mapi :
    f:(int -> 'a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                               " Same as {!List.map}, but the function is applied to the index of\n   the element as first argument (counting from 0), and the element\n   itself as second argument.\n   @since 4.00.0\n"]
    
    
    val rev_map :
    f:('a -> 'b) -> 'a list -> 'b list[@@ocaml.doc
                                        " [List.rev_map f l] gives the same result as\n   {!List.rev}[ (]{!List.map}[ f l)], but is tail-recursive and\n   more efficient. "]
    
    
    val fold_left :
    f:('a -> 'b -> 'a) -> init:'a -> 'b list -> 'a[@@ocaml.doc
                                                    " [List.fold_left f a [b1; ...; bn]] is\n   [f (... (f (f a b1) b2) ...) bn]. "]
    
    
    val fold_right :
    f:('a -> 'b -> 'b) -> 'a list -> init:'b -> 'b[@@ocaml.doc
                                                    " [List.fold_right f [a1; ...; an] b] is\n   [f a1 (f a2 (... (f an b) ...))].  Not tail-recursive. "]
    
    
    [@@@ocaml.text " {1 Iterators on two lists} "]
    
    val iter2 :
    f:('a -> 'b -> unit) -> 'a list -> 'b list -> unit[@@ocaml.doc
                                                        " [List.iter2 f [a1; ...; an] [b1; ...; bn]] calls in turn\n   [f a1 b1; ...; f an bn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
    
    
    val map2 :
    f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                         " [List.map2 f [a1; ...; an] [b1; ...; bn]] is\n   [[f a1 b1; ...; f an bn]].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]
    
    
    val rev_map2 :
    f:('a -> 'b -> 'c) -> 'a list -> 'b list -> 'c list[@@ocaml.doc
                                                         " [List.rev_map2 f l1 l2] gives the same result as\n   {!List.rev}[ (]{!List.map2}[ f l1 l2)], but is tail-recursive and\n   more efficient. "]
    
    
    val fold_left2 :
    f:('a -> 'b -> 'c -> 'a) -> init:'a -> 'b list -> 'c list -> 'a[@@ocaml.doc
                                                                    " [List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]] is\n   [f (... (f (f a b1 c1) b2 c2) ...) bn cn].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
    
    
    val fold_right2 :
    f:('a -> 'b -> 'c -> 'c) -> 'a list -> 'b list -> init:'c -> 'c[@@ocaml.doc
                                                                    " [List.fold_right2 f [a1; ...; an] [b1; ...; bn] c] is\n   [f a1 b1 (f a2 b2 (... (f an bn c) ...))].\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths.  Not tail-recursive. "]
    
    
    [@@@ocaml.text " {1 List scanning} "]
    
    val for_all :
    f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                       " [for_all p [a1; ...; an]] checks if all elements of the list\n   satisfy the predicate [p]. That is, it returns\n   [(p a1) && (p a2) && ... && (p an)]. "]
    
    
    val exists :
    f:('a -> bool) -> 'a list -> bool[@@ocaml.doc
                                       " [exists p [a1; ...; an]] checks if at least one element of\n   the list satisfies the predicate [p]. That is, it returns\n   [(p a1) || (p a2) || ... || (p an)]. "]
    
    
    val for_all2 :
    f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                        " Same as {!List.for_all}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
    
    
    val exists2 :
    f:('a -> 'b -> bool) -> 'a list -> 'b list -> bool[@@ocaml.doc
                                                        " Same as {!List.exists}, but for a two-argument predicate.\n   Raise [Invalid_argument] if the two lists are determined\n   to have different lengths. "]
    
    
    val mem :
    'a -> set:'a list -> bool[@@ocaml.doc
                               " [mem a l] is true if and only if [a] is equal\n   to an element of [l]. "]
    
    
    val memq :
    'a -> set:'a list -> bool[@@ocaml.doc
                               " Same as {!List.mem}, but uses physical equality instead of structural\n   equality to compare list elements. "]
    
    
    [@@@ocaml.text " {1 List searching} "]
    
    val find :
    f:('a -> bool) -> 'a list -> 'a[@@ocaml.doc
                                     " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Raise [Not_found] if there is no value that satisfies [p] in the\n   list [l]. "]
    
    
    val find_opt :
    f:('a -> bool) -> 'a list -> 'a option[@@ocaml.doc
                                            " [find p l] returns the first element of the list [l]\n   that satisfies the predicate [p].\n   Returns [None] if there is no value that satisfies [p] in the\n   list [l].\n   @since 4.05 "]
    
    
    val filter :
    f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                          " [filter p l] returns all the elements of the list [l]\n   that satisfy the predicate [p].  The order of the elements\n   in the input list is preserved.  "]
    
    
    val find_all :
    f:('a -> bool) -> 'a list -> 'a list[@@ocaml.doc
                                          " [find_all] is another name for {!List.filter}. "]
    
    
    val partition :
    f:('a -> bool) -> 'a list -> ('a list * 'a list)[@@ocaml.doc
                                                      " [partition p l] returns a pair of lists [(l1, l2)], where\n   [l1] is the list of all the elements of [l] that\n   satisfy the predicate [p], and [l2] is the list of all the\n   elements of [l] that do not satisfy [p].\n   The order of the elements in the input list is preserved. "]
    
    
    [@@@ocaml.text " {1 Association lists} "]
    
    val assoc :
    'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                " [assoc a l] returns the value associated with key [a] in the list of\n   pairs [l]. That is,\n   [assoc a [ ...; (a,b); ...] = b]\n   if [(a,b)] is the leftmost binding of [a] in list [l].\n   Raise [Not_found] if there is no value associated with [a] in the\n   list [l]. "]
    
    
    val assoc_opt :
    'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                       " [assoc_opt a l] returns the value associated with key [a] in the list of\n    pairs [l]. That is,\n    [assoc a [ ...; (a,b); ...] = b]\n    if [(a,b)] is the leftmost binding of [a] in list [l].\n    Returns [None] if there is no value associated with [a] in the\n    list [l].\n    @since 4.05\n"]
    
    
    val assq :
    'a -> ('a * 'b) list -> 'b[@@ocaml.doc
                                " Same as {!List.assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]
    
    
    val assq_opt :
    'a -> ('a * 'b) list -> 'b option[@@ocaml.doc
                                       " Same as {!List.assoc_opt}, but uses physical equality instead of\n   structural equality to compare keys.\n   @since 4.05.0 "]
    
    
    val mem_assoc :
    'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                      " Same as {!List.assoc}, but simply return true if a binding exists,\n   and false if no bindings exist for the given key. "]
    
    
    val mem_assq :
    'a -> map:('a * 'b) list -> bool[@@ocaml.doc
                                      " Same as {!List.mem_assoc}, but uses physical equality instead of\n   structural equality to compare keys. "]
    
    
    val remove_assoc :
    'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                            " [remove_assoc a l] returns the list of\n   pairs [l] without the first pair with key [a], if any.\n   Not tail-recursive. "]
    
    
    val remove_assq :
    'a -> ('a * 'b) list -> ('a * 'b) list[@@ocaml.doc
                                            " Same as {!List.remove_assoc}, but uses physical equality instead\n   of structural equality to compare keys.  Not tail-recursive. "]
    
    
    [@@@ocaml.text " {1 Lists of pairs} "]
    
    val split :
    ('a * 'b) list -> ('a list * 'b list)[@@ocaml.doc
                                           " Transform a list of pairs into a pair of lists:\n   [split [(a1,b1); ...; (an,bn)]] is [([a1; ...; an], [b1; ...; bn])].\n   Not tail-recursive.\n"]
    
    
    val combine :
    'a list -> 'b list -> ('a * 'b) list[@@ocaml.doc
                                          " Transform a pair of lists into a list of pairs:\n   [combine [a1; ...; an] [b1; ...; bn]] is\n   [[(a1,b1); ...; (an,bn)]].\n   Raise [Invalid_argument] if the two lists\n   have different lengths.  Not tail-recursive. "]
    
    
    [@@@ocaml.text " {1 Sorting} "]
    
    val sort :
    cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                 " Sort a list in increasing order according to a comparison\n   function.  The comparison function must return 0 if its arguments\n   compare as equal, a positive integer if the first is greater,\n   and a negative integer if the first is smaller (see Array.sort for\n   a complete specification).  For example,\n   {!Stdlib.compare} is a suitable comparison function.\n   The resulting list is sorted in increasing order.\n   [List.sort] is guaranteed to run in constant heap space\n   (in addition to the size of the result list) and logarithmic\n   stack space.\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]
    
    
    val stable_sort :
    cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                 " Same as {!List.sort}, but the sorting algorithm is guaranteed to\n   be stable (i.e. elements that compare equal are kept in their\n   original order) .\n\n   The current implementation uses Merge Sort. It runs in constant\n   heap space and logarithmic stack space.\n"]
    
    
    val fast_sort :
    cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                 " Same as {!List.sort} or {!List.stable_sort}, whichever is\n    faster on typical input. "]
    
    
    val sort_uniq :
    cmp:('a -> 'a -> int) -> 'a list -> 'a list[@@ocaml.doc
                                                 " Same as {!List.sort}, but also remove duplicates.\n    @since 4.03.0 "]
    
    
    val merge :
    cmp:('a -> 'a -> int) -> 'a list -> 'a list -> 'a list[@@ocaml.doc
                                                            " Merge two lists:\n    Assuming that [l1] and [l2] are sorted according to the\n    comparison function [cmp], [merge cmp l1 l2] will return a\n    sorted list containing all the elements of [l1] and [l2].\n    If several elements compare equal, the elements of [l1] will be\n    before the elements of [l2].\n    Not tail-recursive (sum of the lengths of the arguments).\n"]
    
    
    [@@@ocaml.text " {6 Iterators} "]
    
    val to_seq :
    'a list -> 'a Seq.t[@@ocaml.doc " Iterate on the list\n    @since 4.07 "]
    
    
    val of_seq :
    'a Seq.t -> 'a list[@@ocaml.doc
                         " Create a list from the iterator\n    @since 4.07 "]
    


*** OK ***

