
*******************************
********** Parsed file ********
*******************************
[@@@ocaml.text " Regular expressions and high-level string processing "]
[@@@ocaml.text " {1 Regular expressions} "]
type regexp[@@ocaml.doc " The type of compiled regular expressions. "]
val regexp : string -> regexp[@@ocaml.doc
                               " Compile a regular expression. The following constructs are\n    recognized:\n   - [.     ] Matches any character except newline.\n   - [*     ] (postfix) Matches the preceding expression zero, one or\n              several times\n   - [+     ] (postfix) Matches the preceding expression one or\n              several times\n   - [?     ] (postfix) Matches the preceding expression once or\n              not at all\n   - [[..]  ] Character set. Ranges are denoted with [-], as in [[a-z]].\n              An initial [^], as in [[^0-9]], complements the set.\n              To include a [\\]] character in a set, make it the first\n              character of the set. To include a [-] character in a set,\n              make it the first or the last character of the set.\n   - [^     ] Matches at beginning of line: either at the beginning of\n              the matched string, or just after a '\\n' character.\n   - [$     ] Matches at end of line: either at the end of the matched\n              string, or just before a '\\n' character.\n   - [\\|    ] (infix) Alternative between two expressions.\n   - [\\(..\\)] Grouping and naming of the enclosed expression.\n   - [\\1    ] The text matched by the first [\\(...\\)] expression\n     ([\\2] for the second expression, and so on up to [\\9]).\n   - [\\b    ] Matches word boundaries.\n   - [\\     ] Quotes special characters.  The special characters\n              are [$^\\.*+?[]].\n\n   Note: the argument to [regexp] is usually a string literal. In this\n   case, any backslash character in the regular expression must be\n   doubled to make it past the OCaml string parser. For example, the\n   following expression:\n   {[ let r = Str.regexp \"hello \\\\([A-Za-z]+\\\\)\" in\n      Str.replace_first r \"\\\\1\" \"hello world\" ]}\n   returns the string [\"world\"].\n\n   In particular, if you want a regular expression that matches a single\n   backslash character, you need to quote it in the argument to [regexp]\n   (according to the last item of the list above) by adding a second\n   backslash. Then you need to quote both backslashes (according to the\n   syntax of string constants in OCaml) by doubling them again, so you\n   need to write four backslash characters: [Str.regexp \"\\\\\\\\\"].\n"]
val regexp_case_fold : string -> regexp[@@ocaml.doc
                                         " Same as [regexp], but the compiled expression will match text\n    in a case-insensitive way: uppercase and lowercase letters will\n    be considered equivalent. "]
val quote : string -> string[@@ocaml.doc
                              " [Str.quote s] returns a regexp string that matches exactly\n   [s] and nothing else. "]
val regexp_string : string -> regexp[@@ocaml.doc
                                      " [Str.regexp_string s] returns a regular expression\n   that matches exactly [s] and nothing else."]
val regexp_string_case_fold : string -> regexp[@@ocaml.doc
                                                " [Str.regexp_string_case_fold] is similar to {!Str.regexp_string},\n   but the regexp matches in a case-insensitive way. "]
[@@@ocaml.text " {1 String matching and searching} "]
val string_match : regexp -> string -> int -> bool[@@ocaml.doc
                                                    " [string_match r s start] tests whether a substring of [s] that\n   starts at position [start] matches the regular expression [r].\n   The first character of a string has position [0], as usual. "]
val search_forward : regexp -> string -> int -> int[@@ocaml.doc
                                                     " [search_forward r s start] searches the string [s] for a substring\n   matching the regular expression [r]. The search starts at position\n   [start] and proceeds towards the end of the string.\n   Return the position of the first character of the matched\n   substring.\n   @raise Not_found if no substring matches. "]
val search_backward : regexp -> string -> int -> int[@@ocaml.doc
                                                      " [search_backward r s last] searches the string [s] for a\n  substring matching the regular expression [r]. The search first\n  considers substrings that start at position [last] and proceeds\n  towards the beginning of string. Return the position of the first\n  character of the matched substring.\n  @raise Not_found if no substring matches. "]
val string_partial_match : regexp -> string -> int -> bool[@@ocaml.doc
                                                            " Similar to {!Str.string_match}, but also returns true if\n   the argument string is a prefix of a string that matches.\n   This includes the case of a true complete match. "]
val matched_string : string -> string[@@ocaml.doc
                                       " [matched_string s] returns the substring of [s] that was matched\n   by the last call to one of the following matching or searching\n   functions:\n   - {!Str.string_match}\n   - {!Str.search_forward}\n   - {!Str.search_backward}\n   - {!Str.string_partial_match}\n   - {!Str.global_substitute}\n   - {!Str.substitute_first}\n\n   provided that none of the following functions was called inbetween:\n   - {!Str.global_replace}\n   - {!Str.replace_first}\n   - {!Str.split}\n   - {!Str.bounded_split}\n   - {!Str.split_delim}\n   - {!Str.bounded_split_delim}\n   - {!Str.full_split}\n   - {!Str.bounded_full_split}\n\n   Note: in the case of [global_substitute] and [substitute_first],\n   a call to [matched_string] is only valid within the [subst] argument,\n   not after [global_substitute] or [substitute_first] returns.\n\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function. "]
val match_beginning : unit -> int[@@ocaml.doc
                                   " [match_beginning()] returns the position of the first character\n   of the substring that was matched by the last call to a matching\n   or searching function (see {!Str.matched_string} for details). "]
val match_end : unit -> int[@@ocaml.doc
                             " [match_end()] returns the position of the character following the\n   last character of the substring that was matched by the last call\n   to a matching or searching function (see {!Str.matched_string} for\n   details). "]
val matched_group : int -> string -> string[@@ocaml.doc
                                             " [matched_group n s] returns the substring of [s] that was matched\n   by the [n]th group [\\(...\\)] of the regular expression that was\n   matched by the last call to a matching or searching function (see\n   {!Str.matched_string} for details).\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function.\n   @raise Not_found if the [n]th group\n   of the regular expression was not matched.  This can happen\n   with groups inside alternatives [\\|], options [?]\n   or repetitions [*].  For instance, the empty string will match\n   [\\(a\\)*], but [matched_group 1 \"\"] will raise [Not_found]\n   because the first group itself was not matched. "]
val group_beginning : int -> int[@@ocaml.doc
                                  " [group_beginning n] returns the position of the first character\n   of the substring that was matched by the [n]th group of\n   the regular expression that was matched by the last call to a\n   matching or searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]
val group_end : int -> int[@@ocaml.doc
                            " [group_end n] returns\n   the position of the character following the last character of\n   substring that was matched by the [n]th group of the regular\n   expression that was matched by the last call to a matching or\n   searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]
[@@@ocaml.text " {1 Replacement} "]
val global_replace : regexp -> string -> string -> string[@@ocaml.doc
                                                           " [global_replace regexp templ s] returns a string identical to [s],\n   except that all substrings of [s] that match [regexp] have been\n   replaced by [templ]. The replacement template [templ] can contain\n   [\\1], [\\2], etc; these sequences will be replaced by the text\n   matched by the corresponding group in the regular expression.\n   [\\0] stands for the text matched by the whole regular expression. "]
val replace_first : regexp -> string -> string -> string[@@ocaml.doc
                                                          " Same as {!Str.global_replace}, except that only the first substring\n   matching the regular expression is replaced. "]
val global_substitute : regexp -> (string -> string) -> string -> string
[@@ocaml.doc
  " [global_substitute regexp subst s] returns a string identical\n   to [s], except that all substrings of [s] that match [regexp]\n   have been replaced by the result of function [subst]. The\n   function [subst] is called once for each matching substring,\n   and receives [s] (the whole text) as argument. "]
val substitute_first : regexp -> (string -> string) -> string -> string
[@@ocaml.doc
  " Same as {!Str.global_substitute}, except that only the first substring\n   matching the regular expression is replaced. "]
val replace_matched : string -> string -> string[@@ocaml.doc
                                                  " [replace_matched repl s] returns the replacement text [repl]\n   in which [\\1], [\\2], etc. have been replaced by the text\n   matched by the corresponding groups in the regular expression\n   that was matched by the last call to a matching or searching\n   function (see {!Str.matched_string} for details).\n   [s] must be the same string that was passed to the matching or\n   searching function. "]
[@@@ocaml.text " {1 Splitting} "]
val split : regexp -> string -> string list[@@ocaml.doc
                                             " [split r s] splits [s] into substrings, taking as delimiters\n   the substrings that match [r], and returns the list of substrings.\n   For instance, [split (regexp \"[ \\t]+\") s] splits [s] into\n   blank-separated words.  An occurrence of the delimiter at the\n   beginning or at the end of the string is ignored. "]
val bounded_split : regexp -> string -> int -> string list[@@ocaml.doc
                                                            " Same as {!Str.split}, but splits into at most [n] substrings,\n   where [n] is the extra integer parameter. "]
val split_delim : regexp -> string -> string list[@@ocaml.doc
                                                   " Same as {!Str.split} but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result.\n   For instance, [split_delim (regexp \" \") \" abc \"]\n   returns [[\"\"; \"abc\"; \"\"]], while [split] with the same\n   arguments returns [[\"abc\"]]. "]
val bounded_split_delim : regexp -> string -> int -> string list[@@ocaml.doc
                                                                  " Same as {!Str.bounded_split}, but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result. "]
type split_result =
  | Text of string 
  | Delim of string 
val full_split : regexp -> string -> split_result list[@@ocaml.doc
                                                        " Same as {!Str.split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text].  For instance,\n   [full_split (regexp \"[{}]\") \"{ab}\"] returns\n   [[Delim \"{\"; Text \"ab\"; Delim \"}\"]]. "]
val bounded_full_split : regexp -> string -> int -> split_result list
[@@ocaml.doc
  " Same as {!Str.bounded_split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text]. "]
[@@@ocaml.text " {1 Extracting substrings} "]
val string_before : string -> int -> string[@@ocaml.doc
                                             " [string_before s n] returns the substring of all characters of [s]\n   that precede position [n] (excluding the character at\n   position [n]). "]
val string_after : string -> int -> string[@@ocaml.doc
                                            " [string_after s n] returns the substring of all characters of [s]\n   that follow position [n] (including the character at\n   position [n]). "]
val first_chars : string -> int -> string[@@ocaml.doc
                                           " [first_chars s n] returns the first [n] characters of [s].\n   This is the same function as {!Str.string_before}. "]
val last_chars : string -> int -> string[@@ocaml.doc
                                          " [last_chars s n] returns the last [n] characters of [s]. "]

*******************************
****** GOSPEL translation *****
*******************************
(*@ open Gospelstdlib *)

[@@@ocaml.text " Regular expressions and high-level string processing "]

[@@@ocaml.text " {1 Regular expressions} "]

type regexp[@@ocaml.doc " The type of compiled regular expressions. "]
  

val regexp : string -> regexp[@@ocaml.doc
                               " Compile a regular expression. The following constructs are\n    recognized:\n   - [.     ] Matches any character except newline.\n   - [*     ] (postfix) Matches the preceding expression zero, one or\n              several times\n   - [+     ] (postfix) Matches the preceding expression one or\n              several times\n   - [?     ] (postfix) Matches the preceding expression once or\n              not at all\n   - [[..]  ] Character set. Ranges are denoted with [-], as in [[a-z]].\n              An initial [^], as in [[^0-9]], complements the set.\n              To include a [\\]] character in a set, make it the first\n              character of the set. To include a [-] character in a set,\n              make it the first or the last character of the set.\n   - [^     ] Matches at beginning of line: either at the beginning of\n              the matched string, or just after a '\\n' character.\n   - [$     ] Matches at end of line: either at the end of the matched\n              string, or just before a '\\n' character.\n   - [\\|    ] (infix) Alternative between two expressions.\n   - [\\(..\\)] Grouping and naming of the enclosed expression.\n   - [\\1    ] The text matched by the first [\\(...\\)] expression\n     ([\\2] for the second expression, and so on up to [\\9]).\n   - [\\b    ] Matches word boundaries.\n   - [\\     ] Quotes special characters.  The special characters\n              are [$^\\.*+?[]].\n\n   Note: the argument to [regexp] is usually a string literal. In this\n   case, any backslash character in the regular expression must be\n   doubled to make it past the OCaml string parser. For example, the\n   following expression:\n   {[ let r = Str.regexp \"hello \\\\([A-Za-z]+\\\\)\" in\n      Str.replace_first r \"\\\\1\" \"hello world\" ]}\n   returns the string [\"world\"].\n\n   In particular, if you want a regular expression that matches a single\n   backslash character, you need to quote it in the argument to [regexp]\n   (according to the last item of the list above) by adding a second\n   backslash. Then you need to quote both backslashes (according to the\n   syntax of string constants in OCaml) by doubling them again, so you\n   need to write four backslash characters: [Str.regexp \"\\\\\\\\\"].\n"]


val regexp_case_fold : string -> regexp[@@ocaml.doc
                                         " Same as [regexp], but the compiled expression will match text\n    in a case-insensitive way: uppercase and lowercase letters will\n    be considered equivalent. "]


val quote : string -> string[@@ocaml.doc
                              " [Str.quote s] returns a regexp string that matches exactly\n   [s] and nothing else. "]


val regexp_string : string -> regexp[@@ocaml.doc
                                      " [Str.regexp_string s] returns a regular expression\n   that matches exactly [s] and nothing else."]


val regexp_string_case_fold : string -> regexp[@@ocaml.doc
                                                " [Str.regexp_string_case_fold] is similar to {!Str.regexp_string},\n   but the regexp matches in a case-insensitive way. "]


[@@@ocaml.text " {1 String matching and searching} "]

val string_match : regexp -> string -> int -> bool[@@ocaml.doc
                                                    " [string_match r s start] tests whether a substring of [s] that\n   starts at position [start] matches the regular expression [r].\n   The first character of a string has position [0], as usual. "]


val search_forward : regexp -> string -> int -> int[@@ocaml.doc
                                                     " [search_forward r s start] searches the string [s] for a substring\n   matching the regular expression [r]. The search starts at position\n   [start] and proceeds towards the end of the string.\n   Return the position of the first character of the matched\n   substring.\n   @raise Not_found if no substring matches. "]


val search_backward : regexp -> string -> int -> int[@@ocaml.doc
                                                      " [search_backward r s last] searches the string [s] for a\n  substring matching the regular expression [r]. The search first\n  considers substrings that start at position [last] and proceeds\n  towards the beginning of string. Return the position of the first\n  character of the matched substring.\n  @raise Not_found if no substring matches. "]


val string_partial_match : regexp -> string -> int -> bool[@@ocaml.doc
                                                            " Similar to {!Str.string_match}, but also returns true if\n   the argument string is a prefix of a string that matches.\n   This includes the case of a true complete match. "]


val matched_string : string -> string[@@ocaml.doc
                                       " [matched_string s] returns the substring of [s] that was matched\n   by the last call to one of the following matching or searching\n   functions:\n   - {!Str.string_match}\n   - {!Str.search_forward}\n   - {!Str.search_backward}\n   - {!Str.string_partial_match}\n   - {!Str.global_substitute}\n   - {!Str.substitute_first}\n\n   provided that none of the following functions was called inbetween:\n   - {!Str.global_replace}\n   - {!Str.replace_first}\n   - {!Str.split}\n   - {!Str.bounded_split}\n   - {!Str.split_delim}\n   - {!Str.bounded_split_delim}\n   - {!Str.full_split}\n   - {!Str.bounded_full_split}\n\n   Note: in the case of [global_substitute] and [substitute_first],\n   a call to [matched_string] is only valid within the [subst] argument,\n   not after [global_substitute] or [substitute_first] returns.\n\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function. "]


val match_beginning : unit -> int[@@ocaml.doc
                                   " [match_beginning()] returns the position of the first character\n   of the substring that was matched by the last call to a matching\n   or searching function (see {!Str.matched_string} for details). "]


val match_end : unit -> int[@@ocaml.doc
                             " [match_end()] returns the position of the character following the\n   last character of the substring that was matched by the last call\n   to a matching or searching function (see {!Str.matched_string} for\n   details). "]


val matched_group : int -> string -> string[@@ocaml.doc
                                             " [matched_group n s] returns the substring of [s] that was matched\n   by the [n]th group [\\(...\\)] of the regular expression that was\n   matched by the last call to a matching or searching function (see\n   {!Str.matched_string} for details).\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function.\n   @raise Not_found if the [n]th group\n   of the regular expression was not matched.  This can happen\n   with groups inside alternatives [\\|], options [?]\n   or repetitions [*].  For instance, the empty string will match\n   [\\(a\\)*], but [matched_group 1 \"\"] will raise [Not_found]\n   because the first group itself was not matched. "]


val group_beginning : int -> int[@@ocaml.doc
                                  " [group_beginning n] returns the position of the first character\n   of the substring that was matched by the [n]th group of\n   the regular expression that was matched by the last call to a\n   matching or searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]


val group_end : int -> int[@@ocaml.doc
                            " [group_end n] returns\n   the position of the character following the last character of\n   substring that was matched by the [n]th group of the regular\n   expression that was matched by the last call to a matching or\n   searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]


[@@@ocaml.text " {1 Replacement} "]

val global_replace : regexp -> string -> string -> string[@@ocaml.doc
                                                           " [global_replace regexp templ s] returns a string identical to [s],\n   except that all substrings of [s] that match [regexp] have been\n   replaced by [templ]. The replacement template [templ] can contain\n   [\\1], [\\2], etc; these sequences will be replaced by the text\n   matched by the corresponding group in the regular expression.\n   [\\0] stands for the text matched by the whole regular expression. "]


val replace_first : regexp -> string -> string -> string[@@ocaml.doc
                                                          " Same as {!Str.global_replace}, except that only the first substring\n   matching the regular expression is replaced. "]


val global_substitute : regexp -> (string -> string) -> string -> string
[@@ocaml.doc
  " [global_substitute regexp subst s] returns a string identical\n   to [s], except that all substrings of [s] that match [regexp]\n   have been replaced by the result of function [subst]. The\n   function [subst] is called once for each matching substring,\n   and receives [s] (the whole text) as argument. "]


val substitute_first : regexp -> (string -> string) -> string -> string
[@@ocaml.doc
  " Same as {!Str.global_substitute}, except that only the first substring\n   matching the regular expression is replaced. "]


val replace_matched : string -> string -> string[@@ocaml.doc
                                                  " [replace_matched repl s] returns the replacement text [repl]\n   in which [\\1], [\\2], etc. have been replaced by the text\n   matched by the corresponding groups in the regular expression\n   that was matched by the last call to a matching or searching\n   function (see {!Str.matched_string} for details).\n   [s] must be the same string that was passed to the matching or\n   searching function. "]


[@@@ocaml.text " {1 Splitting} "]

val split : regexp -> string -> string list[@@ocaml.doc
                                             " [split r s] splits [s] into substrings, taking as delimiters\n   the substrings that match [r], and returns the list of substrings.\n   For instance, [split (regexp \"[ \\t]+\") s] splits [s] into\n   blank-separated words.  An occurrence of the delimiter at the\n   beginning or at the end of the string is ignored. "]


val bounded_split : regexp -> string -> int -> string list[@@ocaml.doc
                                                            " Same as {!Str.split}, but splits into at most [n] substrings,\n   where [n] is the extra integer parameter. "]


val split_delim : regexp -> string -> string list[@@ocaml.doc
                                                   " Same as {!Str.split} but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result.\n   For instance, [split_delim (regexp \" \") \" abc \"]\n   returns [[\"\"; \"abc\"; \"\"]], while [split] with the same\n   arguments returns [[\"abc\"]]. "]


val bounded_split_delim : regexp -> string -> int -> string list[@@ocaml.doc
                                                                  " Same as {!Str.bounded_split}, but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result. "]


type split_result =
| Text of string 
| Delim of string 
  

val full_split : regexp -> string -> split_result list[@@ocaml.doc
                                                        " Same as {!Str.split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text].  For instance,\n   [full_split (regexp \"[{}]\") \"{ab}\"] returns\n   [[Delim \"{\"; Text \"ab\"; Delim \"}\"]]. "]


val bounded_full_split : regexp -> string -> int -> split_result list
[@@ocaml.doc
  " Same as {!Str.bounded_split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text]. "]


[@@@ocaml.text " {1 Extracting substrings} "]

val string_before : string -> int -> string[@@ocaml.doc
                                             " [string_before s n] returns the substring of all characters of [s]\n   that precede position [n] (excluding the character at\n   position [n]). "]


val string_after : string -> int -> string[@@ocaml.doc
                                            " [string_after s n] returns the substring of all characters of [s]\n   that follow position [n] (including the character at\n   position [n]). "]


val first_chars : string -> int -> string[@@ocaml.doc
                                           " [first_chars s n] returns the first [n] characters of [s].\n   This is the same function as {!Str.string_before}. "]


val last_chars : string -> int -> string[@@ocaml.doc
                                          " [last_chars s n] returns the last [n] characters of [s]. "]


*******************************
********* Typed GOSPEL ********
*******************************
module str.mli

  Namespace: str.mli
    Type symbols
       regexp
       split_result
      
    Logic Symbols
      function Delim (_:string) : split_result
      function Text (_:string) : split_result
      
    Exception Symbols
      
    Namespaces
      
    Type Namespaces
      
  Signatures
    (*@ open Gospelstdlib *)
    
    [@@@ocaml.text " Regular expressions and high-level string processing "]
    
    [@@@ocaml.text " {1 Regular expressions} "]
    
    type regexp
    
    
    val regexp#1 :
    string -> regexp[@@ocaml.doc
                      " Compile a regular expression. The following constructs are\n    recognized:\n   - [.     ] Matches any character except newline.\n   - [*     ] (postfix) Matches the preceding expression zero, one or\n              several times\n   - [+     ] (postfix) Matches the preceding expression one or\n              several times\n   - [?     ] (postfix) Matches the preceding expression once or\n              not at all\n   - [[..]  ] Character set. Ranges are denoted with [-], as in [[a-z]].\n              An initial [^], as in [[^0-9]], complements the set.\n              To include a [\\]] character in a set, make it the first\n              character of the set. To include a [-] character in a set,\n              make it the first or the last character of the set.\n   - [^     ] Matches at beginning of line: either at the beginning of\n              the matched string, or just after a '\\n' character.\n   - [$     ] Matches at end of line: either at the end of the matched\n              string, or just before a '\\n' character.\n   - [\\|    ] (infix) Alternative between two expressions.\n   - [\\(..\\)] Grouping and naming of the enclosed expression.\n   - [\\1    ] The text matched by the first [\\(...\\)] expression\n     ([\\2] for the second expression, and so on up to [\\9]).\n   - [\\b    ] Matches word boundaries.\n   - [\\     ] Quotes special characters.  The special characters\n              are [$^\\.*+?[]].\n\n   Note: the argument to [regexp] is usually a string literal. In this\n   case, any backslash character in the regular expression must be\n   doubled to make it past the OCaml string parser. For example, the\n   following expression:\n   {[ let r = Str.regexp \"hello \\\\([A-Za-z]+\\\\)\" in\n      Str.replace_first r \"\\\\1\" \"hello world\" ]}\n   returns the string [\"world\"].\n\n   In particular, if you want a regular expression that matches a single\n   backslash character, you need to quote it in the argument to [regexp]\n   (according to the last item of the list above) by adding a second\n   backslash. Then you need to quote both backslashes (according to the\n   syntax of string constants in OCaml) by doubling them again, so you\n   need to write four backslash characters: [Str.regexp \"\\\\\\\\\"].\n"]
    
    
    val regexp_case_fold :
    string -> regexp[@@ocaml.doc
                      " Same as [regexp], but the compiled expression will match text\n    in a case-insensitive way: uppercase and lowercase letters will\n    be considered equivalent. "]
    
    
    val quote :
    string -> string[@@ocaml.doc
                      " [Str.quote s] returns a regexp string that matches exactly\n   [s] and nothing else. "]
    
    
    val regexp_string :
    string -> regexp[@@ocaml.doc
                      " [Str.regexp_string s] returns a regular expression\n   that matches exactly [s] and nothing else."]
    
    
    val regexp_string_case_fold :
    string -> regexp[@@ocaml.doc
                      " [Str.regexp_string_case_fold] is similar to {!Str.regexp_string},\n   but the regexp matches in a case-insensitive way. "]
    
    
    [@@@ocaml.text " {1 String matching and searching} "]
    
    val string_match :
    regexp -> string -> int -> bool[@@ocaml.doc
                                     " [string_match r s start] tests whether a substring of [s] that\n   starts at position [start] matches the regular expression [r].\n   The first character of a string has position [0], as usual. "]
    
    
    val search_forward :
    regexp -> string -> int -> int[@@ocaml.doc
                                    " [search_forward r s start] searches the string [s] for a substring\n   matching the regular expression [r]. The search starts at position\n   [start] and proceeds towards the end of the string.\n   Return the position of the first character of the matched\n   substring.\n   @raise Not_found if no substring matches. "]
    
    
    val search_backward :
    regexp -> string -> int -> int[@@ocaml.doc
                                    " [search_backward r s last] searches the string [s] for a\n  substring matching the regular expression [r]. The search first\n  considers substrings that start at position [last] and proceeds\n  towards the beginning of string. Return the position of the first\n  character of the matched substring.\n  @raise Not_found if no substring matches. "]
    
    
    val string_partial_match :
    regexp -> string -> int -> bool[@@ocaml.doc
                                     " Similar to {!Str.string_match}, but also returns true if\n   the argument string is a prefix of a string that matches.\n   This includes the case of a true complete match. "]
    
    
    val matched_string :
    string -> string[@@ocaml.doc
                      " [matched_string s] returns the substring of [s] that was matched\n   by the last call to one of the following matching or searching\n   functions:\n   - {!Str.string_match}\n   - {!Str.search_forward}\n   - {!Str.search_backward}\n   - {!Str.string_partial_match}\n   - {!Str.global_substitute}\n   - {!Str.substitute_first}\n\n   provided that none of the following functions was called inbetween:\n   - {!Str.global_replace}\n   - {!Str.replace_first}\n   - {!Str.split}\n   - {!Str.bounded_split}\n   - {!Str.split_delim}\n   - {!Str.bounded_split_delim}\n   - {!Str.full_split}\n   - {!Str.bounded_full_split}\n\n   Note: in the case of [global_substitute] and [substitute_first],\n   a call to [matched_string] is only valid within the [subst] argument,\n   not after [global_substitute] or [substitute_first] returns.\n\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function. "]
    
    
    val match_beginning :
    unit -> int[@@ocaml.doc
                 " [match_beginning()] returns the position of the first character\n   of the substring that was matched by the last call to a matching\n   or searching function (see {!Str.matched_string} for details). "]
    
    
    val match_end :
    unit -> int[@@ocaml.doc
                 " [match_end()] returns the position of the character following the\n   last character of the substring that was matched by the last call\n   to a matching or searching function (see {!Str.matched_string} for\n   details). "]
    
    
    val matched_group :
    int -> string -> string[@@ocaml.doc
                             " [matched_group n s] returns the substring of [s] that was matched\n   by the [n]th group [\\(...\\)] of the regular expression that was\n   matched by the last call to a matching or searching function (see\n   {!Str.matched_string} for details).\n   The user must make sure that the parameter [s] is the same string\n   that was passed to the matching or searching function.\n   @raise Not_found if the [n]th group\n   of the regular expression was not matched.  This can happen\n   with groups inside alternatives [\\|], options [?]\n   or repetitions [*].  For instance, the empty string will match\n   [\\(a\\)*], but [matched_group 1 \"\"] will raise [Not_found]\n   because the first group itself was not matched. "]
    
    
    val group_beginning :
    int -> int[@@ocaml.doc
                " [group_beginning n] returns the position of the first character\n   of the substring that was matched by the [n]th group of\n   the regular expression that was matched by the last call to a\n   matching or searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]
    
    
    val group_end :
    int -> int[@@ocaml.doc
                " [group_end n] returns\n   the position of the character following the last character of\n   substring that was matched by the [n]th group of the regular\n   expression that was matched by the last call to a matching or\n   searching function (see {!Str.matched_string} for details).\n   @raise Not_found if the [n]th group of the regular expression\n   was not matched.\n   @raise Invalid_argument if there are fewer than [n] groups in\n   the regular expression. "]
    
    
    [@@@ocaml.text " {1 Replacement} "]
    
    val global_replace :
    regexp -> string -> string -> string[@@ocaml.doc
                                          " [global_replace regexp templ s] returns a string identical to [s],\n   except that all substrings of [s] that match [regexp] have been\n   replaced by [templ]. The replacement template [templ] can contain\n   [\\1], [\\2], etc; these sequences will be replaced by the text\n   matched by the corresponding group in the regular expression.\n   [\\0] stands for the text matched by the whole regular expression. "]
    
    
    val replace_first :
    regexp -> string -> string -> string[@@ocaml.doc
                                          " Same as {!Str.global_replace}, except that only the first substring\n   matching the regular expression is replaced. "]
    
    
    val global_substitute :
    regexp -> (string -> string) -> string -> string[@@ocaml.doc
                                                      " [global_substitute regexp subst s] returns a string identical\n   to [s], except that all substrings of [s] that match [regexp]\n   have been replaced by the result of function [subst]. The\n   function [subst] is called once for each matching substring,\n   and receives [s] (the whole text) as argument. "]
    
    
    val substitute_first :
    regexp -> (string -> string) -> string -> string[@@ocaml.doc
                                                      " Same as {!Str.global_substitute}, except that only the first substring\n   matching the regular expression is replaced. "]
    
    
    val replace_matched :
    string -> string -> string[@@ocaml.doc
                                " [replace_matched repl s] returns the replacement text [repl]\n   in which [\\1], [\\2], etc. have been replaced by the text\n   matched by the corresponding groups in the regular expression\n   that was matched by the last call to a matching or searching\n   function (see {!Str.matched_string} for details).\n   [s] must be the same string that was passed to the matching or\n   searching function. "]
    
    
    [@@@ocaml.text " {1 Splitting} "]
    
    val split :
    regexp -> string -> string list[@@ocaml.doc
                                     " [split r s] splits [s] into substrings, taking as delimiters\n   the substrings that match [r], and returns the list of substrings.\n   For instance, [split (regexp \"[ \\t]+\") s] splits [s] into\n   blank-separated words.  An occurrence of the delimiter at the\n   beginning or at the end of the string is ignored. "]
    
    
    val bounded_split :
    regexp -> string -> int -> string list[@@ocaml.doc
                                            " Same as {!Str.split}, but splits into at most [n] substrings,\n   where [n] is the extra integer parameter. "]
    
    
    val split_delim :
    regexp -> string -> string list[@@ocaml.doc
                                     " Same as {!Str.split} but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result.\n   For instance, [split_delim (regexp \" \") \" abc \"]\n   returns [[\"\"; \"abc\"; \"\"]], while [split] with the same\n   arguments returns [[\"abc\"]]. "]
    
    
    val bounded_split_delim :
    regexp -> string -> int -> string list[@@ocaml.doc
                                            " Same as {!Str.bounded_split}, but occurrences of the\n   delimiter at the beginning and at the end of the string are\n   recognized and returned as empty strings in the result. "]
    
    
    type split_result = Text of string
                        function Text (_:string) : split_result
                     | Delim of string
                       function Delim (_:string) : split_result
    
    
    val full_split :
    regexp -> string -> split_result list[@@ocaml.doc
                                           " Same as {!Str.split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text].  For instance,\n   [full_split (regexp \"[{}]\") \"{ab}\"] returns\n   [[Delim \"{\"; Text \"ab\"; Delim \"}\"]]. "]
    
    
    val bounded_full_split :
    regexp -> string -> int -> split_result list[@@ocaml.doc
                                                  " Same as {!Str.bounded_split_delim}, but returns\n   the delimiters as well as the substrings contained between\n   delimiters.  The former are tagged [Delim] in the result list;\n   the latter are tagged [Text]. "]
    
    
    [@@@ocaml.text " {1 Extracting substrings} "]
    
    val string_before :
    string -> int -> string[@@ocaml.doc
                             " [string_before s n] returns the substring of all characters of [s]\n   that precede position [n] (excluding the character at\n   position [n]). "]
    
    
    val string_after :
    string -> int -> string[@@ocaml.doc
                             " [string_after s n] returns the substring of all characters of [s]\n   that follow position [n] (including the character at\n   position [n]). "]
    
    
    val first_chars :
    string -> int -> string[@@ocaml.doc
                             " [first_chars s n] returns the first [n] characters of [s].\n   This is the same function as {!Str.string_before}. "]
    
    
    val last_chars :
    string -> int -> string[@@ocaml.doc
                             " [last_chars s n] returns the last [n] characters of [s]. "]
    


*** OK ***

